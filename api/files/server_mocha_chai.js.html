<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>server/mocha/chai.js - Itsa</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Itsa"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/BaseClass.html">BaseClass</a></li>
            
                <li><a href="../classes/Classes.html">Classes</a></li>
            
                <li><a href="../classes/DD.html">DD</a></li>
            
                <li><a href="../classes/document.html">document</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/FocusManager.html">FocusManager</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/HTMLElement.html">HTMLElement</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/NodePlugin.html">NodePlugin</a></li>
            
                <li><a href="../classes/NS-vdom.html">NS-vdom</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Panel.html">Panel</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/String.html">String</a></li>
            
                <li><a href="../classes/USERAGENT.html">USERAGENT</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vnode.html">vnode</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/attribute-extractor.html">attribute-extractor</a></li>
            
                <li><a href="../modules/drag.html">drag</a></li>
            
                <li><a href="../modules/drag-drop.html">drag-drop</a></li>
            
                <li><a href="../modules/element-array.html">element-array</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-blurnode.html">event-blurnode</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-focusnode.html">event-focusnode</a></li>
            
                <li><a href="../modules/event-hover.html">event-hover</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/event-mobile.html">event-mobile</a></li>
            
                <li><a href="../modules/event-objectobserve.html">event-objectobserve</a></li>
            
                <li><a href="../modules/extend-document.html">extend-document</a></li>
            
                <li><a href="../modules/extend-element.html">extend-element</a></li>
            
                <li><a href="../modules/extra_classes.js.html">extra/classes.js</a></li>
            
                <li><a href="../modules/focusmanager.html">focusmanager</a></li>
            
                <li><a href="../modules/html-parser.html">html-parser</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/itsa.build.html">itsa.build</a></li>
            
                <li><a href="../modules/js-ext.html">js-ext</a></li>
            
                <li><a href="../modules/lib_array.js.html">lib/array.js</a></li>
            
                <li><a href="../modules/lib_function.js.html">lib/function.js</a></li>
            
                <li><a href="../modules/lib_object.js.html">lib/object.js</a></li>
            
                <li><a href="../modules/lib_promise.s.html">lib/promise.s</a></li>
            
                <li><a href="../modules/lib_string.js.html">lib/string.js</a></li>
            
                <li><a href="../modules/node-parser.html">node-parser</a></li>
            
                <li><a href="../modules/node-plugin.html">node-plugin</a></li>
            
                <li><a href="../modules/node-win.html">node-win</a></li>
            
                <li><a href="../modules/panel.html">panel</a></li>
            
                <li><a href="../modules/useragent.html">useragent</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/vdom.html">vdom</a></li>
            
                <li><a href="../modules/vdom-ns.html">vdom-ns</a></li>
            
                <li><a href="../modules/vnode.html">vnode</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: server/mocha/chai.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
;(function(){

/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || &#x27;root&#x27;;
    var err = new Error(&#x27;Failed to require &quot;&#x27; + orig + &#x27;&quot; from &quot;&#x27; + parent + &#x27;&quot;&#x27;);
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module&#x27;s
  // registered function
  if (!module._resolving &amp;&amp; !module.exports) {
    var mod = {};
    mod.exports = {};
    mod.client = mod.component = true;
    module._resolving = true;
    module.call(this, mod.exports, require.relative(resolved), mod);
    delete module._resolving;
    module.exports = mod.exports;
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve &#x60;path&#x60;.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === &#x27;/&#x27;) path = path.slice(1);

  var paths = [
    path,
    path + &#x27;.js&#x27;,
    path + &#x27;.json&#x27;,
    path + &#x27;/index.js&#x27;,
    path + &#x27;/index.json&#x27;
  ];

  for (var i = 0; i &lt; paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
  }
};

/**
 * Normalize &#x60;path&#x60; relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if (&#x27;.&#x27; != path.charAt(0)) return path;

  curr = curr.split(&#x27;/&#x27;);
  path = path.split(&#x27;/&#x27;);

  for (var i = 0; i &lt; path.length; ++i) {
    if (&#x27;..&#x27; == path[i]) {
      curr.pop();
    } else if (&#x27;.&#x27; != path[i] &amp;&amp; &#x27;&#x27; != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join(&#x27;/&#x27;);
};

/**
 * Register module at &#x60;path&#x60; with callback &#x60;definition&#x60;.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error(&#x27;Failed to alias &quot;&#x27; + from + &#x27;&quot;, it does not exist&#x27;);
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the &#x60;parent&#x60; path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, &#x27;..&#x27;);

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if (&#x27;/&#x27; == c) return path.slice(1);
    if (&#x27;.&#x27; == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest &quot;deps&quot;
    // directory
    var segs = parent.split(&#x27;/&#x27;);
    var i = lastIndexOf(segs, &#x27;deps&#x27;) + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join(&#x27;/&#x27;) + &#x27;/deps/&#x27; + path;
    return path;
  };

  /**
   * Check if module is defined at &#x60;path&#x60;.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register(&quot;chaijs-assertion-error/index.js&quot;, function(exports, require, module){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer &lt;jake@qualiancy.com&gt;
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new &#x60;{}&#x60;.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i &lt; args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript &#x60;Error&#x60; constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude(&#x27;name&#x27;, &#x27;message&#x27;, &#x27;stack&#x27;, &#x27;constructor&#x27;, &#x27;toJSON&#x27;)
    , props = extend(_props || {});

  // default values
  this.message = message || &#x27;Unspecified AssertionError&#x27;;
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf &amp;&amp; Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = &#x27;AssertionError&#x27;;

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: &#x60;true&#x60;)
 * @return {Object} object that can be &#x60;JSON.stringify&#x60;
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude(&#x27;constructor&#x27;, &#x27;toJSON&#x27;, &#x27;stack&#x27;)
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack &amp;&amp; this.stack) {
    props.stack = this.stack;
  }

  return props;
};

});
require.register(&quot;chaijs-type-detect/lib/type.js&quot;, function(exports, require, module){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    &#x27;[object Array]&#x27;: &#x27;array&#x27;
  , &#x27;[object RegExp]&#x27;: &#x27;regexp&#x27;
  , &#x27;[object Function]&#x27;: &#x27;function&#x27;
  , &#x27;[object Arguments]&#x27;: &#x27;arguments&#x27;
  , &#x27;[object Date]&#x27;: &#x27;date&#x27;
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return &#x27;null&#x27;;
  if (obj === undefined) return &#x27;undefined&#x27;;
  if (obj === Object(obj)) return &#x27;object&#x27;;
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * &#x60;&#x60;&#x60;js
 * var lib = new type.Library;
 * &#x60;&#x60;&#x60;
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement &#x60;typeof&#x60; detection to the library.
 *
 * &#x60;&#x60;&#x60;js
 * if (&#x27;string&#x27; === lib.of(&#x27;hello world&#x27;)) {
 *   // ...
 * }
 * &#x60;&#x60;&#x60;
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the &#x60;.test()&#x60; assertion.
 *
 * Can be defined as a regular expression:
 *
 * &#x60;&#x60;&#x60;js
 * lib.define(&#x27;int&#x27;, /^[0-9]+$/);
 * &#x60;&#x60;&#x60;
 *
 * ... or as a function:
 *
 * &#x60;&#x60;&#x60;js
 * lib.define(&#x27;bln&#x27;, function (obj) {
 *   if (&#x27;boolean&#x27; === lib.of(obj)) return true;
 *   var blns = [ &#x27;yes&#x27;, &#x27;no&#x27;, &#x27;true&#x27;, &#x27;false&#x27;, 1, 0 ];
 *   if (&#x27;string&#x27; === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * &#x60;&#x60;&#x60;
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * &#x60;&#x60;&#x60;js
 * assert(lib.test(&#x27;1&#x27;, &#x27;int&#x27;));
 * assert(lib.test(&#x27;yes&#x27;, &#x27;bln&#x27;));
 * &#x60;&#x60;&#x60;
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test &amp;&amp; &#x27;regexp&#x27; === getType(test)) {
    return test.test(obj);
  } else if (test &amp;&amp; &#x27;function&#x27; === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError(&#x27;Type test &quot;&#x27; + type + &#x27;&quot; not defined or invalid.&#x27;);
  }
};

});
require.register(&quot;chaijs-deep-eql/lib/eql.js&quot;, function(exports, require, module){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require(&#x27;type-detect&#x27;);

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require(&#x27;buffer&#x27;).Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if (&#x27;date&#x27; === type(a)) {
    return dateEqual(a, b);
  } else if (&#x27;regexp&#x27; === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if (&#x27;arguments&#x27; === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if ((&#x27;object&#x27; !== type(a) &amp;&amp; &#x27;object&#x27; !== type(b))
  &amp;&amp; (&#x27;array&#x27; !== type(a) &amp;&amp; &#x27;array&#x27; !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and &#x60;-0&#x60; does not equal &#x60;+0&#x60;.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a &amp;&amp; b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of &#x60;array&#x60; (not &#x60;object&#x60;) and arguments
 * have a type of &#x60;arguments&#x60; (not &#x60;array&#x60;/&#x60;object&#x60;).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using &#x60;saveValue&#x60;.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if (&#x27;date&#x27; !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for &#x60;sameValue&#x60;.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if (&#x27;regexp&#x27; !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two &#x60;arguments&#x60; objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if (&#x27;arguments&#x27; !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i &lt; a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to &#x60;iterableEqual&#x60; specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for &#x60;objectEqual&#x60; ensuring non-existing
 * values don&#x27;t get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null &amp;&amp; a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to &#x60;deepEqual&#x60; for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i &lt; m.length; i++) {
      if ((m[i][0] === a &amp;&amp; m[i][1] === b)
      ||  (m[i][0] === b &amp;&amp; m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i &gt;= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

});
require.register(&quot;chai/index.js&quot;, function(exports, require, module){
module.exports = require(&#x27;./lib/chai&#x27;);

});
require.register(&quot;chai/lib/chai.js&quot;, function(exports, require, module){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = &#x27;1.9.1&#x27;;

/*!
 * Assertion Error
 */

exports.AssertionError = require(&#x27;assertion-error&#x27;);

/*!
 * Utils for plugins (not exported)
 */

var util = require(&#x27;./chai/utils&#x27;);

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Configuration
 */

var config = require(&#x27;./chai/config&#x27;);
exports.config = config;

/*!
 * Primary &#x60;Assertion&#x60; prototype
 */

var assertion = require(&#x27;./chai/assertion&#x27;);
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require(&#x27;./chai/core/assertions&#x27;);
exports.use(core);

/*!
 * Expect interface
 */

var expect = require(&#x27;./chai/interface/expect&#x27;);
exports.use(expect);

/*!
 * Should interface
 */

var should = require(&#x27;./chai/interface/should&#x27;);
exports.use(should);

/*!
 * Assert interface
 */

var assert = require(&#x27;./chai/interface/assert&#x27;);
exports.use(assert);

});
require.register(&quot;chai/lib/chai/assertion.js&quot;, function(exports, require, module){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

var config = require(&#x27;./config&#x27;);

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, &#x27;ssfi&#x27;, stack || arguments.callee);
    flag(this, &#x27;object&#x27;, obj);
    flag(this, &#x27;message&#x27;, msg);
  }

  Object.defineProperty(Assertion, &#x27;includeStack&#x27;, {
    get: function() {
      console.warn(&#x27;Assertion.includeStack is deprecated, use chai.config.includeStack instead.&#x27;);
      return config.includeStack;
    },
    set: function(value) {
      console.warn(&#x27;Assertion.includeStack is deprecated, use chai.config.includeStack instead.&#x27;);
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, &#x27;showDiff&#x27;, {
    get: function() {
      console.warn(&#x27;Assertion.showDiff is deprecated, use chai.config.showDiff instead.&#x27;);
      return config.showDiff;
    },
    set: function(value) {
      console.warn(&#x27;Assertion.showDiff is deprecated, use chai.config.showDiff instead.&#x27;);
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /*!
   * ### .assert(expression, message, negateMessage, expected, actual)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn&#x27;t pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String} message to display if fails
   * @param {String} negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to &#x60;this.obj&#x60;
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, &#x27;ssfi&#x27;));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored &#x60;actual&#x60; value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, &#x27;_obj&#x27;,
    { get: function () {
        return flag(this, &#x27;object&#x27;);
      }
    , set: function (val) {
        flag(this, &#x27;object&#x27;, val);
      }
  });
};

});
require.register(&quot;chai/lib/chai/config.js&quot;, function(exports, require, module){
module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the &#x60;showDiff&#x60; flag should be included in the thrown
   * AssertionErrors. &#x60;false&#x60; will always be &#x60;false&#x60;; &#x60;true&#x60;
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded,
   * the value is truncated.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};

});
require.register(&quot;chai/lib/chai/core/assertions.js&quot;, function(exports, require, module){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @api public
   */

  [ &#x27;to&#x27;, &#x27;be&#x27;, &#x27;been&#x27;
  , &#x27;is&#x27;, &#x27;and&#x27;, &#x27;has&#x27;, &#x27;have&#x27;
  , &#x27;with&#x27;, &#x27;that&#x27;, &#x27;at&#x27;
  , &#x27;of&#x27;, &#x27;same&#x27; ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal(&#x27;bar&#x27;);
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: &#x27;baz&#x27; }).to.have.property(&#x27;foo&#x27;)
   *       .and.not.equal(&#x27;bar&#x27;);
   *
   * @name not
   * @api public
   */

  Assertion.addProperty(&#x27;not&#x27;, function () {
    flag(this, &#x27;negate&#x27;, true);
  });

  /**
   * ### .deep
   *
   * Sets the &#x60;deep&#x60; flag, later used by the &#x60;equal&#x60; and
   * &#x60;property&#x60; assertions.
   *
   *     expect(foo).to.deep.equal({ bar: &#x27;baz&#x27; });
   *     expect({ foo: { bar: { baz: &#x27;quux&#x27; } } })
   *       .to.have.deep.property(&#x27;foo.bar.baz&#x27;, &#x27;quux&#x27;);
   *
   * @name deep
   * @api public
   */

  Assertion.addProperty(&#x27;deep&#x27;, function () {
    flag(this, &#x27;deep&#x27;, true);
  });

  /**
   * ### .a(type)
   *
   * The &#x60;a&#x60; and &#x60;an&#x60; assertions are aliases that can be
   * used either as language chains or to assert a value&#x27;s
   * type.
   *
   *     // typeof
   *     expect(&#x27;test&#x27;).to.be.a(&#x27;string&#x27;);
   *     expect({ foo: &#x27;bar&#x27; }).to.be.an(&#x27;object&#x27;);
   *     expect(null).to.be.a(&#x27;null&#x27;);
   *     expect(undefined).to.be.an(&#x27;undefined&#x27;);
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    type = type.toLowerCase();
    var obj = flag(this, &#x27;object&#x27;)
      , article = ~[ &#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27; ].indexOf(type.charAt(0)) ? &#x27;an &#x27; : &#x27;a &#x27;;

    this.assert(
        type === _.type(obj)
      , &#x27;expected #{this} to be &#x27; + article + type
      , &#x27;expected #{this} not to be &#x27; + article + type
    );
  }

  Assertion.addChainableMethod(&#x27;an&#x27;, an);
  Assertion.addChainableMethod(&#x27;a&#x27;, an);

  /**
   * ### .include(value)
   *
   * The &#x60;include&#x60; and &#x60;contain&#x60; assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the &#x60;contain&#x60; flag for the &#x60;keys&#x60; assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect(&#x27;foobar&#x27;).to.contain(&#x27;foo&#x27;);
   *     expect({ foo: &#x27;bar&#x27;, hello: &#x27;universe&#x27; }).to.include.keys(&#x27;foo&#x27;);
   *
   * @name include
   * @alias contain
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, &#x27;contains&#x27;, true);
  }

  function include (val, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);
    var expected = false;
    if (_.type(obj) === &#x27;array&#x27; &amp;&amp; _.type(val) === &#x27;object&#x27;) {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === &#x27;object&#x27;) {
      if (!flag(this, &#x27;negate&#x27;)) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {}
      for (var k in val) subset[k] = obj[k]
      expected = _.eql(subset, val);
    } else {
      expected = obj &amp;&amp; ~obj.indexOf(val)
    }
    this.assert(
        expected
      , &#x27;expected #{this} to include &#x27; + _.inspect(val)
      , &#x27;expected #{this} to not include &#x27; + _.inspect(val));
  }

  Assertion.addChainableMethod(&#x27;include&#x27;, include, includeChainingBehavior);
  Assertion.addChainableMethod(&#x27;contain&#x27;, include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect(&#x27;everthing&#x27;).to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @api public
   */

  Assertion.addProperty(&#x27;ok&#x27;, function () {
    this.assert(
        flag(this, &#x27;object&#x27;)
      , &#x27;expected #{this} to be truthy&#x27;
      , &#x27;expected #{this} to be falsy&#x27;);
  });

  /**
   * ### .true
   *
   * Asserts that the target is &#x60;true&#x60;.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @api public
   */

  Assertion.addProperty(&#x27;true&#x27;, function () {
    this.assert(
        true === flag(this, &#x27;object&#x27;)
      , &#x27;expected #{this} to be true&#x27;
      , &#x27;expected #{this} to be false&#x27;
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is &#x60;false&#x60;.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @api public
   */

  Assertion.addProperty(&#x27;false&#x27;, function () {
    this.assert(
        false === flag(this, &#x27;object&#x27;)
      , &#x27;expected #{this} to be false&#x27;
      , &#x27;expected #{this} to be true&#x27;
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is &#x60;null&#x60;.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).not.to.be.null;
   *
   * @name null
   * @api public
   */

  Assertion.addProperty(&#x27;null&#x27;, function () {
    this.assert(
        null === flag(this, &#x27;object&#x27;)
      , &#x27;expected #{this} to be null&#x27;
      , &#x27;expected #{this} not to be null&#x27;
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is &#x60;undefined&#x60;.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @api public
   */

  Assertion.addProperty(&#x27;undefined&#x27;, function () {
    this.assert(
        undefined === flag(this, &#x27;object&#x27;)
      , &#x27;expected #{this} to be undefined&#x27;
      , &#x27;expected #{this} not to be undefined&#x27;
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither &#x60;null&#x60; nor &#x60;undefined&#x60;.
   *
   *     var foo = &#x27;hi&#x27;
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @api public
   */

  Assertion.addProperty(&#x27;exist&#x27;, function () {
    this.assert(
        null != flag(this, &#x27;object&#x27;)
      , &#x27;expected #{this} to exist&#x27;
      , &#x27;expected #{this} to not exist&#x27;
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target&#x27;s length is &#x60;0&#x60;. For arrays, it checks
   * the &#x60;length&#x60; property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect(&#x27;&#x27;).to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @api public
   */

  Assertion.addProperty(&#x27;empty&#x27;, function () {
    var obj = flag(this, &#x27;object&#x27;)
      , expected = obj;

    if (Array.isArray(obj) || &#x27;string&#x27; === typeof object) {
      expected = obj.length;
    } else if (typeof obj === &#x27;object&#x27;) {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , &#x27;expected #{this} to be empty&#x27;
      , &#x27;expected #{this} not to be empty&#x27;
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, &#x27;object&#x27;)
      , type = Object.prototype.toString.call(obj);
    this.assert(
        &#x27;[object Arguments]&#x27; === type
      , &#x27;expected #{this} to be arguments but got &#x27; + type
      , &#x27;expected #{this} to not be arguments&#x27;
    );
  }

  Assertion.addProperty(&#x27;arguments&#x27;, checkArguments);
  Assertion.addProperty(&#x27;Arguments&#x27;, checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (&#x60;===&#x60;) to &#x60;value&#x60;.
   * Alternately, if the &#x60;deep&#x60; flag is set, asserts that
   * the target is deeply equal to &#x60;value&#x60;.
   *
   *     expect(&#x27;hello&#x27;).to.equal(&#x27;hello&#x27;);
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: &#x27;bar&#x27; }).to.not.equal({ foo: &#x27;bar&#x27; });
   *     expect({ foo: &#x27;bar&#x27; }).to.deep.equal({ foo: &#x27;bar&#x27; });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);
    if (flag(this, &#x27;deep&#x27;)) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , &#x27;expected #{this} to equal #{exp}&#x27;
        , &#x27;expected #{this} to not equal #{exp}&#x27;
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod(&#x27;equal&#x27;, assertEqual);
  Assertion.addMethod(&#x27;equals&#x27;, assertEqual);
  Assertion.addMethod(&#x27;eq&#x27;, assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to &#x60;value&#x60;.
   *
   *     expect({ foo: &#x27;bar&#x27; }).to.eql({ foo: &#x27;bar&#x27; });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    this.assert(
        _.eql(obj, flag(this, &#x27;object&#x27;))
      , &#x27;expected #{this} to deeply equal #{exp}&#x27;
      , &#x27;expected #{this} to not deeply equal #{exp}&#x27;
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod(&#x27;eql&#x27;, assertEql);
  Assertion.addMethod(&#x27;eqls&#x27;, assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than &#x60;value&#x60;.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with &#x60;length&#x60; to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#x27;foo&#x27;).to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);
    if (flag(this, &#x27;doLength&#x27;)) {
      new Assertion(obj, msg).to.have.property(&#x27;length&#x27;);
      var len = obj.length;
      this.assert(
          len &gt; n
        , &#x27;expected #{this} to have a length above #{exp} but got #{act}&#x27;
        , &#x27;expected #{this} to not have a length above #{exp}&#x27;
        , n
        , len
      );
    } else {
      this.assert(
          obj &gt; n
        , &#x27;expected #{this} to be above &#x27; + n
        , &#x27;expected #{this} to be at most &#x27; + n
      );
    }
  }

  Assertion.addMethod(&#x27;above&#x27;, assertAbove);
  Assertion.addMethod(&#x27;gt&#x27;, assertAbove);
  Assertion.addMethod(&#x27;greaterThan&#x27;, assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to &#x60;value&#x60;.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with &#x60;length&#x60; to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#x27;foo&#x27;).to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);
    if (flag(this, &#x27;doLength&#x27;)) {
      new Assertion(obj, msg).to.have.property(&#x27;length&#x27;);
      var len = obj.length;
      this.assert(
          len &gt;= n
        , &#x27;expected #{this} to have a length at least #{exp} but got #{act}&#x27;
        , &#x27;expected #{this} to have a length below #{exp}&#x27;
        , n
        , len
      );
    } else {
      this.assert(
          obj &gt;= n
        , &#x27;expected #{this} to be at least &#x27; + n
        , &#x27;expected #{this} to be below &#x27; + n
      );
    }
  }

  Assertion.addMethod(&#x27;least&#x27;, assertLeast);
  Assertion.addMethod(&#x27;gte&#x27;, assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than &#x60;value&#x60;.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with &#x60;length&#x60; to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#x27;foo&#x27;).to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);
    if (flag(this, &#x27;doLength&#x27;)) {
      new Assertion(obj, msg).to.have.property(&#x27;length&#x27;);
      var len = obj.length;
      this.assert(
          len &lt; n
        , &#x27;expected #{this} to have a length below #{exp} but got #{act}&#x27;
        , &#x27;expected #{this} to not have a length below #{exp}&#x27;
        , n
        , len
      );
    } else {
      this.assert(
          obj &lt; n
        , &#x27;expected #{this} to be below &#x27; + n
        , &#x27;expected #{this} to be at least &#x27; + n
      );
    }
  }

  Assertion.addMethod(&#x27;below&#x27;, assertBelow);
  Assertion.addMethod(&#x27;lt&#x27;, assertBelow);
  Assertion.addMethod(&#x27;lessThan&#x27;, assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to &#x60;value&#x60;.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with &#x60;length&#x60; to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#x27;foo&#x27;).to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);
    if (flag(this, &#x27;doLength&#x27;)) {
      new Assertion(obj, msg).to.have.property(&#x27;length&#x27;);
      var len = obj.length;
      this.assert(
          len &lt;= n
        , &#x27;expected #{this} to have a length at most #{exp} but got #{act}&#x27;
        , &#x27;expected #{this} to have a length above #{exp}&#x27;
        , n
        , len
      );
    } else {
      this.assert(
          obj &lt;= n
        , &#x27;expected #{this} to be at most &#x27; + n
        , &#x27;expected #{this} to be above &#x27; + n
      );
    }
  }

  Assertion.addMethod(&#x27;most&#x27;, assertMost);
  Assertion.addMethod(&#x27;lte&#x27;, assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with &#x60;length&#x60; to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect(&#x27;foo&#x27;).to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod(&#x27;within&#x27;, function (start, finish, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;)
      , range = start + &#x27;..&#x27; + finish;
    if (flag(this, &#x27;doLength&#x27;)) {
      new Assertion(obj, msg).to.have.property(&#x27;length&#x27;);
      var len = obj.length;
      this.assert(
          len &gt;= start &amp;&amp; len &lt;= finish
        , &#x27;expected #{this} to have a length within &#x27; + range
        , &#x27;expected #{this} to not have a length within &#x27; + range
      );
    } else {
      this.assert(
          obj &gt;= start &amp;&amp; obj &lt;= finish
        , &#x27;expected #{this} to be within &#x27; + range
        , &#x27;expected #{this} to not be within &#x27; + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of &#x60;constructor&#x60;.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea(&#x27;chai&#x27;);
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, &#x27;object&#x27;) instanceof constructor
      , &#x27;expected #{this} to be an instance of &#x27; + name
      , &#x27;expected #{this} to not be an instance of &#x27; + name
    );
  };

  Assertion.addMethod(&#x27;instanceof&#x27;, assertInstanceOf);
  Assertion.addMethod(&#x27;instanceOf&#x27;, assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property &#x60;name&#x60;, optionally asserting that
   * the value of that property is strictly equal to  &#x60;value&#x60;.
   * If the &#x60;deep&#x60; flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: &#x27;bar&#x27; };
   *     expect(obj).to.have.property(&#x27;foo&#x27;);
   *     expect(obj).to.have.property(&#x27;foo&#x27;, &#x27;bar&#x27;);
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: &#x27;matcha&#x27; }
   *       , teas: [ &#x27;chai&#x27;, &#x27;matcha&#x27;, { tea: &#x27;konacha&#x27; } ]
   *     };

   *     expect(deepObj).to.have.deep.property(&#x27;green.tea&#x27;, &#x27;matcha&#x27;);
   *     expect(deepObj).to.have.deep.property(&#x27;teas[1]&#x27;, &#x27;matcha&#x27;);
   *     expect(deepObj).to.have.deep.property(&#x27;teas[2].tea&#x27;, &#x27;konacha&#x27;);
   *
   * You can also use an array as the starting point of a &#x60;deep.property&#x60;
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ &#x27;chai&#x27;, &#x27;matcha&#x27;, &#x27;konacha&#x27; ]
   *       , [ { tea: &#x27;chai&#x27; }
   *         , { tea: &#x27;matcha&#x27; }
   *         , { tea: &#x27;konacha&#x27; } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property(&#x27;[0][1]&#x27;, &#x27;matcha&#x27;);
   *     expect(arr).to.have.deep.property(&#x27;[1][2].tea&#x27;, &#x27;konacha&#x27;);
   *
   * Furthermore, &#x60;property&#x60; changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property(&#x27;foo&#x27;)
   *       .that.is.a(&#x27;string&#x27;);
   *     expect(deepObj).to.have.property(&#x27;green&#x27;)
   *       .that.is.an(&#x27;object&#x27;)
   *       .that.deep.equals({ tea: &#x27;matcha&#x27; });
   *     expect(deepObj).to.have.property(&#x27;teas&#x27;)
   *       .that.is.an(&#x27;array&#x27;)
   *       .with.deep.property(&#x27;[2]&#x27;)
   *         .that.deep.equals({ tea: &#x27;konacha&#x27; });
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @api public
   */

  Assertion.addMethod(&#x27;property&#x27;, function (name, val, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);

    var descriptor = flag(this, &#x27;deep&#x27;) ? &#x27;deep property &#x27; : &#x27;property &#x27;
      , negate = flag(this, &#x27;negate&#x27;)
      , obj = flag(this, &#x27;object&#x27;)
      , value = flag(this, &#x27;deep&#x27;)
        ? _.getPathValue(name, obj)
        : obj[name];

    if (negate &amp;&amp; undefined !== val) {
      if (undefined === value) {
        msg = (msg != null) ? msg + &#x27;: &#x27; : &#x27;&#x27;;
        throw new Error(msg + _.inspect(obj) + &#x27; has no &#x27; + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          undefined !== value
        , &#x27;expected #{this} to have a &#x27; + descriptor + _.inspect(name)
        , &#x27;expected #{this} to not have &#x27; + descriptor + _.inspect(name));
    }

    if (undefined !== val) {
      this.assert(
          val === value
        , &#x27;expected #{this} to have a &#x27; + descriptor + _.inspect(name) + &#x27; of #{exp}, but got #{act}&#x27;
        , &#x27;expected #{this} to not have a &#x27; + descriptor + _.inspect(name) + &#x27; of #{act}&#x27;
        , val
        , value
      );
    }

    flag(this, &#x27;object&#x27;, value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property &#x60;name&#x60;.
   *
   *     expect(&#x27;test&#x27;).to.have.ownProperty(&#x27;length&#x27;);
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);
    this.assert(
        obj.hasOwnProperty(name)
      , &#x27;expected #{this} to have own property &#x27; + _.inspect(name)
      , &#x27;expected #{this} to not have own property &#x27; + _.inspect(name)
    );
  }

  Assertion.addMethod(&#x27;ownProperty&#x27;, assertOwnProperty);
  Assertion.addMethod(&#x27;haveOwnProperty&#x27;, assertOwnProperty);

  /**
   * ### .length(value)
   *
   * Asserts that the target&#x27;s &#x60;length&#x60; property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.length(3);
   *     expect(&#x27;foobar&#x27;).to.have.length(6);
   *
   * Can also be used as a chain precursor to a value
   * comparison for the length property.
   *
   *     expect(&#x27;foo&#x27;).to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect(&#x27;foo&#x27;).to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect(&#x27;foo&#x27;).to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name length
   * @alias lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @api public
   */

  function assertLengthChain () {
    flag(this, &#x27;doLength&#x27;, true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);
    new Assertion(obj, msg).to.have.property(&#x27;length&#x27;);
    var len = obj.length;

    this.assert(
        len == n
      , &#x27;expected #{this} to have a length of #{exp} but got #{act}&#x27;
      , &#x27;expected #{this} to not have a length of #{act}&#x27;
      , n
      , len
    );
  }

  Assertion.addChainableMethod(&#x27;length&#x27;, assertLength, assertLengthChain);
  Assertion.addMethod(&#x27;lengthOf&#x27;, assertLength, assertLengthChain);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect(&#x27;foobar&#x27;).to.match(/^foo/);
   *
   * @name match
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod(&#x27;match&#x27;, function (re, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);
    this.assert(
        re.exec(obj)
      , &#x27;expected #{this} to match &#x27; + re
      , &#x27;expected #{this} not to match &#x27; + re
    );
  });

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect(&#x27;foobar&#x27;).to.have.string(&#x27;bar&#x27;);
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod(&#x27;string&#x27;, function (str, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);
    new Assertion(obj, msg).is.a(&#x27;string&#x27;);

    this.assert(
        ~obj.indexOf(str)
      , &#x27;expected #{this} to contain &#x27; + _.inspect(str)
      , &#x27;expected #{this} to not contain &#x27; + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target has exactly the given keys, or
   * asserts the inclusion of some keys when using the
   * &#x60;include&#x60; or &#x60;contain&#x60; modifiers.
   *
   *     expect({ foo: 1, bar: 2 }).to.have.keys([&#x27;foo&#x27;, &#x27;bar&#x27;]);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys(&#x27;foo&#x27;, &#x27;bar&#x27;);
   *
   * @name keys
   * @alias key
   * @param {String...|Array} keys
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, &#x27;object&#x27;)
      , str
      , ok = true;

    keys = keys instanceof Array
      ? keys
      : Array.prototype.slice.call(arguments);

    if (!keys.length) throw new Error(&#x27;keys required&#x27;);

    var actual = Object.keys(obj)
      , len = keys.length;

    // Inclusion
    ok = keys.every(function(key){
      return ~actual.indexOf(key);
    });

    // Strict
    if (!flag(this, &#x27;negate&#x27;) &amp;&amp; !flag(this, &#x27;contains&#x27;)) {
      ok = ok &amp;&amp; keys.length == actual.length;
    }

    // Key string
    if (len &gt; 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      str = keys.join(&#x27;, &#x27;) + &#x27;, and &#x27; + last;
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len &gt; 1 ? &#x27;keys &#x27; : &#x27;key &#x27;) + str;

    // Have / include
    str = (flag(this, &#x27;contains&#x27;) ? &#x27;contain &#x27; : &#x27;have &#x27;) + str;

    // Assertion
    this.assert(
        ok
      , &#x27;expected #{this} to &#x27; + str
      , &#x27;expected #{this} to not &#x27; + str
    );
  }

  Assertion.addMethod(&#x27;keys&#x27;, assertKeys);
  Assertion.addMethod(&#x27;key&#x27;, assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using &#x60;instanceof&#x60;), optionally with a RegExp or string inclusion test
   * for the error&#x27;s message.
   *
   *     var err = new ReferenceError(&#x27;This is a bad function.&#x27;);
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw(&#x27;good function&#x27;);
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *     expect(fn).to.not.throw(new RangeError(&#x27;Out of range.&#x27;));
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use &#x60;and&#x60;.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);
    new Assertion(obj, msg).is.a(&#x27;function&#x27;);

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor &amp;&amp; (constructor instanceof RegExp || &#x27;string&#x27; === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor &amp;&amp; constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === &#x27;function&#x27;) {
      name = constructor.prototype.name || constructor.name;
      if (name === &#x27;Error&#x27; &amp;&amp; constructor !== Error) {
        name = (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , &#x27;expected #{this} to throw #{exp} but #{act} was thrown&#x27;
          , &#x27;expected #{this} to not throw #{exp}&#x27;
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, &#x27;object&#x27;, err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , &#x27;expected #{this} to throw #{exp} but #{act} was thrown&#x27;
          , &#x27;expected #{this} to not throw #{exp} but #{act} was thrown&#x27;
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, &#x27;object&#x27;, err);
          return this;
        }
      }

      // next, check message
      var message = &#x27;object&#x27; === _.type(err) &amp;&amp; &quot;message&quot; in err
        ? err.message
        : &#x27;&#x27; + err;

      if ((message != null) &amp;&amp; errMsg &amp;&amp; errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , &#x27;expected #{this} to throw error matching #{exp} but got #{act}&#x27;
          , &#x27;expected #{this} to throw error not matching #{exp}&#x27;
          , errMsg
          , message
        );

        flag(this, &#x27;object&#x27;, err);
        return this;
      } else if ((message != null) &amp;&amp; errMsg &amp;&amp; &#x27;string&#x27; === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , &#x27;expected #{this} to throw error including #{exp} but got #{act}&#x27;
          , &#x27;expected #{this} to throw error not including #{act}&#x27;
          , errMsg
          , message
        );

        flag(this, &#x27;object&#x27;, err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = &#x27;&#x27;
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? &#x27;#{exp}&#x27; //_.inspect(desiredError)
          : &#x27;an error&#x27;;

    if (thrown) {
      actuallyGot = &#x27; but #{act} was thrown&#x27;
    }

    this.assert(
        thrown === true
      , &#x27;expected #{this} to throw &#x27; + expectedThrown + actuallyGot
      , &#x27;expected #{this} to not throw &#x27; + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, &#x27;object&#x27;, thrownError);
  };

  Assertion.addMethod(&#x27;throw&#x27;, assertThrows);
  Assertion.addMethod(&#x27;throws&#x27;, assertThrows);
  Assertion.addMethod(&#x27;Throw&#x27;, assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo(&#x27;bar&#x27;);
   *     expect(obj).to.respondTo(&#x27;bar&#x27;);
   *
   * To check if a constructor will respond to a static function,
   * set the &#x60;itself&#x60; flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo(&#x27;baz&#x27;);
   *
   * @name respondTo
   * @param {String} method
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod(&#x27;respondTo&#x27;, function (method, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;)
      , itself = flag(this, &#x27;itself&#x27;)
      , context = (&#x27;function&#x27; === _.type(obj) &amp;&amp; !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        &#x27;function&#x27; === typeof context
      , &#x27;expected #{this} to respond to &#x27; + _.inspect(method)
      , &#x27;expected #{this} to not respond to &#x27; + _.inspect(method)
    );
  });

  /**
   * ### .itself
   *
   * Sets the &#x60;itself&#x60; flag, later used by the &#x60;respondTo&#x60; assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo(&#x27;bar&#x27;);
   *     expect(Foo).itself.not.to.respondTo(&#x27;baz&#x27;);
   *
   * @name itself
   * @api public
   */

  Assertion.addProperty(&#x27;itself&#x27;, function () {
    flag(this, &#x27;itself&#x27;, true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num &gt; 0; });
   *
   * @name satisfy
   * @param {Function} matcher
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod(&#x27;satisfy&#x27;, function (matcher, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);
    this.assert(
        matcher(obj)
      , &#x27;expected #{this} to satisfy &#x27; + _.objDisplay(matcher)
      , &#x27;expected #{this} to not satisfy&#x27; + _.objDisplay(matcher)
      , this.negate ? false : true
      , matcher(obj)
    );
  });

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal &#x60;expected&#x60;, to within a +/- &#x60;delta&#x60; range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod(&#x27;closeTo&#x27;, function (expected, delta, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);
    this.assert(
        Math.abs(obj - expected) &lt;= delta
      , &#x27;expected #{this} to be close to &#x27; + expected + &#x27; +/- &#x27; + delta
      , &#x27;expected #{this} not to be close to &#x27; + expected + &#x27; +/- &#x27; + delta
    );
  });

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of &#x60;set&#x60;,
   * or that the target and &#x60;set&#x60; have the same strictly-equal (===) members.
   * Alternately, if the &#x60;deep&#x60; flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod(&#x27;members&#x27;, function (subset, msg) {
    if (msg) flag(this, &#x27;message&#x27;, msg);
    var obj = flag(this, &#x27;object&#x27;);

    new Assertion(obj).to.be.an(&#x27;array&#x27;);
    new Assertion(subset).to.be.an(&#x27;array&#x27;);

    var cmp = flag(this, &#x27;deep&#x27;) ? _.eql : undefined;

    if (flag(this, &#x27;contains&#x27;)) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , &#x27;expected #{this} to be a superset of #{act}&#x27;
        , &#x27;expected #{this} to not be a superset of #{act}&#x27;
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) &amp;&amp; isSubsetOf(subset, obj, cmp)
        , &#x27;expected #{this} to have the same members as #{act}&#x27;
        , &#x27;expected #{this} to not have the same members as #{act}&#x27;
        , obj
        , subset
    );
  });
};

});
require.register(&quot;chai/lib/chai/interface/assert.js&quot;, function(exports, require, module){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert(&#x27;foo&#x27; !== &#x27;bar&#x27;, &#x27;foo is not bar&#x27;);
   *     assert(Array.isArray([]), &#x27;empty arrays are arrays&#x27;);
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , &#x27;[ negation message unavailable ]&#x27;
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js &#x60;assert&#x60; module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || &#x27;assert.fail()&#x27;;
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .ok(object, [message])
   *
   * Asserts that &#x60;object&#x60; is truthy.
   *
   *     assert.ok(&#x27;everything&#x27;, &#x27;everything is ok&#x27;);
   *     assert.ok(false, &#x27;this will fail&#x27;);
   *
   * @name ok
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.ok = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .notOk(object, [message])
   *
   * Asserts that &#x60;object&#x60; is falsy.
   *
   *     assert.notOk(&#x27;everything&#x27;, &#x27;this will fail&#x27;);
   *     assert.notOk(false, &#x27;this will pass&#x27;);
   *
   * @name notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.notOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (&#x60;==&#x60;) of &#x60;actual&#x60; and &#x60;expected&#x60;.
   *
   *     assert.equal(3, &#x27;3&#x27;, &#x27;== coerces values to strings&#x27;);
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, &#x27;object&#x27;)
      , &#x27;expected #{this} to equal #{exp}&#x27;
      , &#x27;expected #{this} to not equal #{act}&#x27;
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (&#x60;!=&#x60;) of &#x60;actual&#x60; and &#x60;expected&#x60;.
   *
   *     assert.notEqual(3, 4, &#x27;these numbers are not equal&#x27;);
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, &#x27;object&#x27;)
      , &#x27;expected #{this} to not equal #{exp}&#x27;
      , &#x27;expected #{this} to equal #{act}&#x27;
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (&#x60;===&#x60;) of &#x60;actual&#x60; and &#x60;expected&#x60;.
   *
   *     assert.strictEqual(true, true, &#x27;these booleans are strictly equal&#x27;);
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (&#x60;!==&#x60;) of &#x60;actual&#x60; and &#x60;expected&#x60;.
   *
   *     assert.notStrictEqual(3, &#x27;3&#x27;, &#x27;no coercion for strict equality&#x27;);
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that &#x60;actual&#x60; is deeply equal to &#x60;expected&#x60;.
   *
   *     assert.deepEqual({ tea: &#x27;green&#x27; }, { tea: &#x27;green&#x27; });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that &#x60;actual&#x60; is not deeply equal to &#x60;expected&#x60;.
   *
   *     assert.notDeepEqual({ tea: &#x27;green&#x27; }, { tea: &#x27;jasmine&#x27; });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that &#x60;value&#x60; is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, &#x27;the tea has been served&#x27;);
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is[&#x27;true&#x27;];
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that &#x60;value&#x60; is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, &#x27;no tea yet? hmm...&#x27;);
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is[&#x27;false&#x27;];
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that &#x60;value&#x60; is null.
   *
   *     assert.isNull(err, &#x27;there was no error&#x27;);
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that &#x60;value&#x60; is not null.
   *
   *     var tea = &#x27;tasty chai&#x27;;
   *     assert.isNotNull(tea, &#x27;great, time for tea!&#x27;);
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that &#x60;value&#x60; is &#x60;undefined&#x60;.
   *
   *     var tea;
   *     assert.isUndefined(tea, &#x27;no tea defined&#x27;);
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that &#x60;value&#x60; is not &#x60;undefined&#x60;.
   *
   *     var tea = &#x27;cup of chai&#x27;;
   *     assert.isDefined(tea, &#x27;tea has been defined&#x27;);
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that &#x60;value&#x60; is a function.
   *
   *     function serveTea() { return &#x27;cup of tea&#x27;; };
   *     assert.isFunction(serveTea, &#x27;great, we can have tea now&#x27;);
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a(&#x27;function&#x27;);
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that &#x60;value&#x60; is _not_ a function.
   *
   *     var serveTea = [ &#x27;heat&#x27;, &#x27;pour&#x27;, &#x27;sip&#x27; ];
   *     assert.isNotFunction(serveTea, &#x27;great, we have listed the steps&#x27;);
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a(&#x27;function&#x27;);
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that &#x60;value&#x60; is an object (as revealed by
   * &#x60;Object.prototype.toString&#x60;).
   *
   *     var selection = { name: &#x27;Chai&#x27;, serve: &#x27;with spices&#x27; };
   *     assert.isObject(selection, &#x27;tea selection is an object&#x27;);
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a(&#x27;object&#x27;);
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that &#x60;value&#x60; is _not_ an object.
   *
   *     var selection = &#x27;chai&#x27;
   *     assert.isNotObject(selection, &#x27;tea selection is not an object&#x27;);
   *     assert.isNotObject(null, &#x27;null is not an object&#x27;);
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a(&#x27;object&#x27;);
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that &#x60;value&#x60; is an array.
   *
   *     var menu = [ &#x27;green&#x27;, &#x27;chai&#x27;, &#x27;oolong&#x27; ];
   *     assert.isArray(menu, &#x27;what kind of tea do we want?&#x27;);
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an(&#x27;array&#x27;);
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that &#x60;value&#x60; is _not_ an array.
   *
   *     var menu = &#x27;green|chai|oolong&#x27;;
   *     assert.isNotArray(menu, &#x27;what kind of tea do we want?&#x27;);
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an(&#x27;array&#x27;);
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that &#x60;value&#x60; is a string.
   *
   *     var teaOrder = &#x27;chai&#x27;;
   *     assert.isString(teaOrder, &#x27;order placed&#x27;);
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a(&#x27;string&#x27;);
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that &#x60;value&#x60; is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, &#x27;order placed&#x27;);
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a(&#x27;string&#x27;);
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that &#x60;value&#x60; is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, &#x27;how many cups&#x27;);
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a(&#x27;number&#x27;);
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that &#x60;value&#x60; is _not_ a number.
   *
   *     var cups = &#x27;2 cups please&#x27;;
   *     assert.isNotNumber(cups, &#x27;how many cups&#x27;);
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a(&#x27;number&#x27;);
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that &#x60;value&#x60; is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, &#x27;is the tea ready&#x27;);
   *     assert.isBoolean(teaServed, &#x27;has tea been served&#x27;);
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a(&#x27;boolean&#x27;);
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that &#x60;value&#x60; is _not_ a boolean.
   *
   *     var teaReady = &#x27;yep&#x27;
   *       , teaServed = &#x27;nope&#x27;;
   *
   *     assert.isNotBoolean(teaReady, &#x27;is the tea ready&#x27;);
   *     assert.isNotBoolean(teaServed, &#x27;has tea been served&#x27;);
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a(&#x27;boolean&#x27;);
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that &#x60;value&#x60;&#x27;s type is &#x60;name&#x60;, as determined by
   * &#x60;Object.prototype.toString&#x60;.
   *
   *     assert.typeOf({ tea: &#x27;chai&#x27; }, &#x27;object&#x27;, &#x27;we have an object&#x27;);
   *     assert.typeOf([&#x27;chai&#x27;, &#x27;jasmine&#x27;], &#x27;array&#x27;, &#x27;we have an array&#x27;);
   *     assert.typeOf(&#x27;tea&#x27;, &#x27;string&#x27;, &#x27;we have a string&#x27;);
   *     assert.typeOf(/tea/, &#x27;regexp&#x27;, &#x27;we have a regular expression&#x27;);
   *     assert.typeOf(null, &#x27;null&#x27;, &#x27;we have a null&#x27;);
   *     assert.typeOf(undefined, &#x27;undefined&#x27;, &#x27;we have an undefined&#x27;);
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that &#x60;value&#x60;&#x27;s type is _not_ &#x60;name&#x60;, as determined by
   * &#x60;Object.prototype.toString&#x60;.
   *
   *     assert.notTypeOf(&#x27;tea&#x27;, &#x27;number&#x27;, &#x27;strings are not numbers&#x27;);
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that &#x60;value&#x60; is an instance of &#x60;constructor&#x60;.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea(&#x27;chai&#x27;);
   *
   *     assert.instanceOf(chai, Tea, &#x27;chai is an instance of tea&#x27;);
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts &#x60;value&#x60; is not an instance of &#x60;constructor&#x60;.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String(&#x27;chai&#x27;);
   *
   *     assert.notInstanceOf(chai, Tea, &#x27;chai is not an instance of tea&#x27;);
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that &#x60;haystack&#x60; includes &#x60;needle&#x60;. Works
   * for strings and arrays.
   *
   *     assert.include(&#x27;foobar&#x27;, &#x27;bar&#x27;, &#x27;foobar contains string &quot;bar&quot;&#x27;);
   *     assert.include([ 1, 2, 3 ], 3, &#x27;array contains value&#x27;);
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that &#x60;haystack&#x60; does not include &#x60;needle&#x60;. Works
   * for strings and arrays.
   *i
   *     assert.notInclude(&#x27;foobar&#x27;, &#x27;baz&#x27;, &#x27;string not include substring&#x27;);
   *     assert.notInclude([ 1, 2, 3 ], 4, &#x27;array not include contain value&#x27;);
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that &#x60;value&#x60; matches the regular expression &#x60;regexp&#x60;.
   *
   *     assert.match(&#x27;foobar&#x27;, /^foo/, &#x27;regexp matches&#x27;);
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that &#x60;value&#x60; does not match the regular expression &#x60;regexp&#x60;.
   *
   *     assert.notMatch(&#x27;foobar&#x27;, /^foo/, &#x27;regexp does not match&#x27;);
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that &#x60;object&#x60; has a property named by &#x60;property&#x60;.
   *
   *     assert.property({ tea: { green: &#x27;matcha&#x27; }}, &#x27;tea&#x27;);
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that &#x60;object&#x60; does _not_ have a property named by &#x60;property&#x60;.
   *
   *     assert.notProperty({ tea: { green: &#x27;matcha&#x27; }}, &#x27;coffee&#x27;);
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that &#x60;object&#x60; has a property named by &#x60;property&#x60;, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: &#x27;matcha&#x27; }}, &#x27;tea.green&#x27;);
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that &#x60;object&#x60; does _not_ have a property named by &#x60;property&#x60;, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: &#x27;matcha&#x27; }}, &#x27;tea.oolong&#x27;);
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that &#x60;object&#x60; has a property named by &#x60;property&#x60; with value given
   * by &#x60;value&#x60;.
   *
   *     assert.propertyVal({ tea: &#x27;is good&#x27; }, &#x27;tea&#x27;, &#x27;is good&#x27;);
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that &#x60;object&#x60; has a property named by &#x60;property&#x60;, but with a value
   * different from that given by &#x60;value&#x60;.
   *
   *     assert.propertyNotVal({ tea: &#x27;is good&#x27; }, &#x27;tea&#x27;, &#x27;is bad&#x27;);
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that &#x60;object&#x60; has a property named by &#x60;property&#x60; with value given
   * by &#x60;value&#x60;. &#x60;property&#x60; can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: &#x27;matcha&#x27; }}, &#x27;tea.green&#x27;, &#x27;matcha&#x27;);
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that &#x60;object&#x60; has a property named by &#x60;property&#x60;, but with a value
   * different from that given by &#x60;value&#x60;. &#x60;property&#x60; can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: &#x27;matcha&#x27; }}, &#x27;tea.green&#x27;, &#x27;konacha&#x27;);
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that &#x60;object&#x60; has a &#x60;length&#x60; property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, &#x27;array has length of 3&#x27;);
   *     assert.lengthOf(&#x27;foobar&#x27;, 5, &#x27;string has length of 6&#x27;);
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that &#x60;function&#x60; will throw an error that is an instance of
   * &#x60;constructor&#x60;, or alternately that it will throw an error with message
   * matching &#x60;regexp&#x60;.
   *
   *     assert.throw(fn, &#x27;function throws a reference error&#x27;);
   *     assert.throw(fn, /function throws a reference error/);
   *     assert.throw(fn, ReferenceError);
   *     assert.throw(fn, ReferenceError, &#x27;function throws a reference error&#x27;);
   *     assert.throw(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.Throw = function (fn, errt, errs, msg) {
    if (&#x27;string&#x27; === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);
    return flag(assertErr, &#x27;object&#x27;);
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that &#x60;function&#x60; will _not_ throw an error that is an instance of
   * &#x60;constructor&#x60;, or alternately that it will not throw an error with message
   * matching &#x60;regexp&#x60;.
   *
   *     assert.doesNotThrow(fn, Error, &#x27;function does not throw&#x27;);
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if (&#x27;string&#x27; === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using &#x60;operator&#x60;.
   *
   *     assert.operator(1, &#x27;&lt;&#x27;, 2, &#x27;everything is ok&#x27;);
   *     assert.operator(1, &#x27;&gt;&#x27;, 2, &#x27;this will fail&#x27;);
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    if (!~[&#x27;==&#x27;, &#x27;===&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;=&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;=&#x27;, &#x27;!=&#x27;, &#x27;!==&#x27;].indexOf(operator)) {
      throw new Error(&#x27;Invalid operator &quot;&#x27; + operator + &#x27;&quot;&#x27;);
    }
    var test = new Assertion(eval(val + operator + val2), msg);
    test.assert(
        true === flag(test, &#x27;object&#x27;)
      , &#x27;expected &#x27; + util.inspect(val) + &#x27; to be &#x27; + operator + &#x27; &#x27; + util.inspect(val2)
      , &#x27;expected &#x27; + util.inspect(val) + &#x27; to not be &#x27; + operator + &#x27; &#x27; + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal &#x60;expected&#x60;, to within a +/- &#x60;delta&#x60; range.
   *
   *     assert.closeTo(1.5, 1, 0.5, &#x27;numbers are close&#x27;);
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that &#x60;set1&#x60; and &#x60;set2&#x60; have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], &#x27;same members&#x27;);
   *
   * @name sameMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that &#x60;subset&#x60; is included in &#x60;superset&#x60;.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], &#x27;include members&#x27;);
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

  /*!
   * Undocumented / untested
   */

  assert.ifError = function (val, msg) {
    new Assertion(val, msg).to.not.be.ok;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  (&#x27;Throw&#x27;, &#x27;throw&#x27;)
  (&#x27;Throw&#x27;, &#x27;throws&#x27;);
};

});
require.register(&quot;chai/lib/chai/interface/expect.js&quot;, function(exports, require, module){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
};


});
require.register(&quot;chai/lib/chai/interface/should.js&quot;, function(exports, require, module){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it&#x27;s name to include as &#x60;ssfi&#x60;
    function shouldGetter() {
      if (this instanceof String || this instanceof Number) {
        return new Assertion(this.constructor(this), null, shouldGetter);
      } else if (this instanceof Boolean) {
        return new Assertion(this == true, null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // &#x60;whatever.should = someValue&#x60; actually set &#x60;someValue&#x60;, which is
      // especially useful for &#x60;global.should = require(&#x27;chai&#x27;).should()&#x60;.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, &#x27;should&#x27;, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have &#x60;should&#x60;
    Object.defineProperty(Object.prototype, &#x27;should&#x27;, {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should[&#x27;throw&#x27;] = should[&#x27;Throw&#x27;];
    should.not[&#x27;throw&#x27;] = should.not[&#x27;Throw&#x27;];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

});
require.register(&quot;chai/lib/chai/utils/addChainableMethod.js&quot;, function(exports, require, module){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require(&#x27;./transferFlags&#x27;);
var flag = require(&#x27;./flag&#x27;);
var config = require(&#x27;../config&#x27;);

/*!
 * Module variables
 */

// Check whether &#x60;__proto__&#x60; is supported
var hasProtoSupport = &#x27;__proto__&#x27; in Object;

// Without &#x60;__proto__&#x60; support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache &#x60;Function&#x60; properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, &#x27;foo&#x27;, function (str) {
 *       var obj = utils.flag(this, &#x27;object&#x27;);
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from &#x60;chai.Assertion&#x60;.
 *
 *     chai.Assertion.addChainableMethod(&#x27;foo&#x27;, fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both &#x60;method&#x60; and
 * &#x60;chainingBehavior&#x60;, or as a language chain, which only executes &#x60;chainingBehavior&#x60;.
 *
 *     expect(fooStr).to.be.foo(&#x27;bar&#x27;);
 *     expect(fooStr).to.be.foo.equal(&#x27;foo&#x27;);
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for &#x60;name&#x60;, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== &#x27;function&#x27;) {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, &#x27;ssfi&#x27;);
          if (old_ssfi &amp;&amp; config.includeStack === false)
            flag(this, &#x27;ssfi&#x27;, assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use &#x60;__proto__&#x60; if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the &#x60;Function&#x60; prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the &#x60;call&#x60; and &#x60;apply&#x60; methods from &#x60;Function&#x60;
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

});
require.register(&quot;chai/lib/chai/utils/addMethod.js&quot;, function(exports, require, module){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

var config = require(&#x27;../config&#x27;);

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, &#x27;foo&#x27;, function (str) {
 *       var obj = utils.flag(this, &#x27;object&#x27;);
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from &#x60;chai.Assertion&#x60;.
 *
 *     chai.Assertion.addMethod(&#x27;foo&#x27;, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo(&#x27;bar&#x27;);
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @name addMethod
 * @api public
 */
var flag = require(&#x27;./flag&#x27;);

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, &#x27;ssfi&#x27;);
    if (old_ssfi &amp;&amp; config.includeStack === false)
      flag(this, &#x27;ssfi&#x27;, ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

});
require.register(&quot;chai/lib/chai/utils/addProperty.js&quot;, function(exports, require, module){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, &#x27;foo&#x27;, function () {
 *       var obj = utils.flag(this, &#x27;object&#x27;);
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from &#x60;chai.Assertion&#x60;.
 *
 *     chai.Assertion.addProperty(&#x27;foo&#x27;, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

});
require.register(&quot;chai/lib/chai/utils/flag.js&quot;, function(exports, require, module){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### flag(object ,key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or &#x60;undefined&#x60; if
 * the value is not set.
 *
 *     utils.flag(this, &#x27;foo&#x27;, &#x27;bar&#x27;); // setter
 *     utils.flag(this, &#x27;foo&#x27;); // getter, returns &#x60;bar&#x60;
 *
 * @param {Object} object (constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

});
require.register(&quot;chai/lib/chai/utils/getActual.js&quot;, function(exports, require, module){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the &#x60;actual&#x60; value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  return args.length &gt; 4 ? args[4] : obj._obj;
};

});
require.register(&quot;chai/lib/chai/utils/getEnumerableProperties.js&quot;, function(exports, require, module){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

});
require.register(&quot;chai/lib/chai/utils/getMessage.js&quot;, function(exports, require, module){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require(&#x27;./flag&#x27;)
  , getActual = require(&#x27;./getActual&#x27;)
  , inspect = require(&#x27;./inspect&#x27;)
  , objDisplay = require(&#x27;./objDisplay&#x27;);

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - &#x60;#{this}&#x60; current asserted object
 * - &#x60;#{act}&#x60; actual value
 * - &#x60;#{exp}&#x60; expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, &#x27;negate&#x27;)
    , val = flag(obj, &#x27;object&#x27;)
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, &#x27;message&#x27;);

  msg = msg || &#x27;&#x27;;
  msg = msg
    .replace(/#{this}/g, objDisplay(val))
    .replace(/#{act}/g, objDisplay(actual))
    .replace(/#{exp}/g, objDisplay(expected));

  return flagMsg ? flagMsg + &#x27;: &#x27; + msg : msg;
};

});
require.register(&quot;chai/lib/chai/utils/getName.js&quot;, function(exports, require, module){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match &amp;&amp; match[1] ? match[1] : &quot;&quot;;
};

});
require.register(&quot;chai/lib/chai/utils/getPathValue.js&quot;, function(exports, require, module){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]
 *           , str: &#x27;Hello&#x27;
 *         }
 *       , prop2: {
 *             arr: [ { nested: &#x27;Universe&#x27; } ]
 *           , str: &#x27;Hello again!&#x27;
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue(&#x27;prop1.str&#x27;, obj); // Hello
 *     getPathValue(&#x27;prop1.att[2]&#x27;, obj); // b
 *     getPathValue(&#x27;prop2.arr[0].nested&#x27;, obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or &#x60;undefined&#x60;
 * @name getPathValue
 * @api public
 */

var getPathValue = module.exports = function (path, obj) {
  var parsed = parsePath(path);
  return _getPathValue(parsed, obj);
};

/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with &#x60;_getPathValue&#x60;.
 *
 *      var parsed = parsePath(&#x27;myobject.property.subprop&#x27;);
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal &#x60;myobject.document[3].property&#x60;.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/\[/g, &#x27;.[&#x27;)
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /\[(\d+)\]$/
      , mArr = re.exec(value)
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value };
  });
};

/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for &#x60;.parsePath&#x60; that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from &#x60;parsePath&#x60;.
 * @param {Object} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj) {
  var tmp = obj
    , res;
  for (var i = 0, l = parsed.length; i &lt; l; i++) {
    var part = parsed[i];
    if (tmp) {
      if (&#x27;undefined&#x27; !== typeof part.p)
        tmp = tmp[part.p];
      else if (&#x27;undefined&#x27; !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
};

});
require.register(&quot;chai/lib/chai/utils/getProperties.js&quot;, function(exports, require, module){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(subject);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(subject);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

});
require.register(&quot;chai/lib/chai/utils/index.js&quot;, function(exports, require, module){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require(&#x27;./test&#x27;);

/*!
 * type utility
 */

exports.type = require(&#x27;./type&#x27;);

/*!
 * message utility
 */

exports.getMessage = require(&#x27;./getMessage&#x27;);

/*!
 * actual utility
 */

exports.getActual = require(&#x27;./getActual&#x27;);

/*!
 * Inspect util
 */

exports.inspect = require(&#x27;./inspect&#x27;);

/*!
 * Object Display util
 */

exports.objDisplay = require(&#x27;./objDisplay&#x27;);

/*!
 * Flag utility
 */

exports.flag = require(&#x27;./flag&#x27;);

/*!
 * Flag transferring utility
 */

exports.transferFlags = require(&#x27;./transferFlags&#x27;);

/*!
 * Deep equal utility
 */

exports.eql = require(&#x27;deep-eql&#x27;);

/*!
 * Deep path value
 */

exports.getPathValue = require(&#x27;./getPathValue&#x27;);

/*!
 * Function name
 */

exports.getName = require(&#x27;./getName&#x27;);

/*!
 * add Property
 */

exports.addProperty = require(&#x27;./addProperty&#x27;);

/*!
 * add Method
 */

exports.addMethod = require(&#x27;./addMethod&#x27;);

/*!
 * overwrite Property
 */

exports.overwriteProperty = require(&#x27;./overwriteProperty&#x27;);

/*!
 * overwrite Method
 */

exports.overwriteMethod = require(&#x27;./overwriteMethod&#x27;);

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require(&#x27;./addChainableMethod&#x27;);

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require(&#x27;./overwriteChainableMethod&#x27;);


});
require.register(&quot;chai/lib/chai/utils/inspect.js&quot;, function(exports, require, module){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require(&#x27;./getName&#x27;);
var getProperties = require(&#x27;./getProperties&#x27;);
var getEnumerableProperties = require(&#x27;./getEnumerableProperties&#x27;);

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === &#x27;undefined&#x27; ? 2 : depth));
}

// https://gist.github.com/1044128/
var getOuterHTML = function(element) {
  if (&#x27;outerHTML&#x27; in element) return element.outerHTML;
  var ns = &quot;http://www.w3.org/1999/xhtml&quot;;
  var container = document.createElementNS(ns, &#x27;_&#x27;);
  var elemProto = (window.HTMLElement || window.Element).prototype;
  var xmlSerializer = new XMLSerializer();
  var html;
  if (document.xmlVersion) {
    return xmlSerializer.serializeToString(element);
  } else {
    container.appendChild(element.cloneNode(false));
    html = container.innerHTML.replace(&#x27;&gt;&lt;&#x27;, &#x27;&gt;&#x27; + element.innerHTML + &#x27;&lt;&#x27;);
    container.innerHTML = &#x27;&#x27;;
    return html;
  }
};

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === &#x27;object&#x27;) {
    return object instanceof HTMLElement;
  } else {
    return object &amp;&amp;
      typeof object === &#x27;object&#x27; &amp;&amp;
      object.nodeType === 1 &amp;&amp;
      typeof object.nodeName === &#x27;string&#x27;;
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value &amp;&amp; typeof value.inspect === &#x27;function&#x27; &amp;&amp;
      // Filter out the util module, it&#x27;s inspect function is special
      value.inspect !== exports.inspect &amp;&amp;
      // Also filter out any prototype objects using the circular check.
      !(value.constructor &amp;&amp; value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== &#x27;string&#x27;) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If it&#x27;s DOM elem, get outer HTML.
  if (isDOMElement(value)) {
    return getOuterHTML(value);
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single &#x60;stack&#x60; property, or if they are vanilla &#x60;Error&#x60;,
  // a &#x60;stack&#x60; plus &#x60;description&#x60; property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) &amp;&amp; (
      (keys.length === 1 &amp;&amp; keys[0] === &#x27;stack&#x27;) ||
      (keys.length === 2 &amp;&amp; keys[0] === &#x27;description&#x27; &amp;&amp; keys[1] === &#x27;stack&#x27;)
     ))) {
    if (typeof value === &#x27;function&#x27;) {
      var name = getName(value);
      var nameSuffix = name ? &#x27;: &#x27; + name : &#x27;&#x27;;
      return ctx.stylize(&#x27;[Function&#x27; + nameSuffix + &#x27;]&#x27;, &#x27;special&#x27;);
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), &#x27;regexp&#x27;);
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), &#x27;date&#x27;);
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = &#x27;&#x27;, array = false, braces = [&#x27;{&#x27;, &#x27;}&#x27;];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = [&#x27;[&#x27;, &#x27;]&#x27;];
  }

  // Make functions say that they are functions
  if (typeof value === &#x27;function&#x27;) {
    var name = getName(value);
    var nameSuffix = name ? &#x27;: &#x27; + name : &#x27;&#x27;;
    base = &#x27; [Function&#x27; + nameSuffix + &#x27;]&#x27;;
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = &#x27; &#x27; + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = &#x27; &#x27; + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 &amp;&amp; (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes &lt; 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), &#x27;regexp&#x27;);
    } else {
      return ctx.stylize(&#x27;[Object]&#x27;, &#x27;special&#x27;);
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case &#x27;undefined&#x27;:
      return ctx.stylize(&#x27;undefined&#x27;, &#x27;undefined&#x27;);

    case &#x27;string&#x27;:
      var simple = &#x27;\&#x27;&#x27; + JSON.stringify(value).replace(/^&quot;|&quot;$/g, &#x27;&#x27;)
                                               .replace(/&#x27;/g, &quot;\\&#x27;&quot;)
                                               .replace(/\\&quot;/g, &#x27;&quot;&#x27;) + &#x27;\&#x27;&#x27;;
      return ctx.stylize(simple, &#x27;string&#x27;);

    case &#x27;number&#x27;:
      return ctx.stylize(&#x27;&#x27; + value, &#x27;number&#x27;);

    case &#x27;boolean&#x27;:
      return ctx.stylize(&#x27;&#x27; + value, &#x27;boolean&#x27;);
  }
  // For some reason typeof null is &quot;object&quot;, so special case here.
  if (value === null) {
    return ctx.stylize(&#x27;null&#x27;, &#x27;null&#x27;);
  }
}


function formatError(value) {
  return &#x27;[&#x27; + Error.prototype.toString.call(value) + &#x27;]&#x27;;
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i &lt; l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push(&#x27;&#x27;);
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize(&#x27;[Getter/Setter]&#x27;, &#x27;special&#x27;);
      } else {
        str = ctx.stylize(&#x27;[Getter]&#x27;, &#x27;special&#x27;);
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize(&#x27;[Setter]&#x27;, &#x27;special&#x27;);
      }
    }
  }
  if (visibleKeys.indexOf(key) &lt; 0) {
    name = &#x27;[&#x27; + key + &#x27;]&#x27;;
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) &lt; 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf(&#x27;\n&#x27;) &gt; -1) {
        if (array) {
          str = str.split(&#x27;\n&#x27;).map(function(line) {
            return &#x27;  &#x27; + line;
          }).join(&#x27;\n&#x27;).substr(2);
        } else {
          str = &#x27;\n&#x27; + str.split(&#x27;\n&#x27;).map(function(line) {
            return &#x27;   &#x27; + line;
          }).join(&#x27;\n&#x27;);
        }
      }
    } else {
      str = ctx.stylize(&#x27;[Circular]&#x27;, &#x27;special&#x27;);
    }
  }
  if (typeof name === &#x27;undefined&#x27;) {
    if (array &amp;&amp; key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify(&#x27;&#x27; + key);
    if (name.match(/^&quot;([a-zA-Z_][a-zA-Z_0-9]*)&quot;$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, &#x27;name&#x27;);
    } else {
      name = name.replace(/&#x27;/g, &quot;\\&#x27;&quot;)
                 .replace(/\\&quot;/g, &#x27;&quot;&#x27;)
                 .replace(/(^&quot;|&quot;$)/g, &quot;&#x27;&quot;);
      name = ctx.stylize(name, &#x27;string&#x27;);
    }
  }

  return name + &#x27;: &#x27; + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf(&#x27;\n&#x27;) &gt;= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length &gt; 60) {
    return braces[0] +
           (base === &#x27;&#x27; ? &#x27;&#x27; : base + &#x27;\n &#x27;) +
           &#x27; &#x27; +
           output.join(&#x27;,\n  &#x27;) +
           &#x27; &#x27; +
           braces[1];
  }

  return braces[0] + base + &#x27; &#x27; + output.join(&#x27;, &#x27;) + &#x27; &#x27; + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === &#x27;object&#x27; &amp;&amp; objectToString(ar) === &#x27;[object Array]&#x27;);
}

function isRegExp(re) {
  return typeof re === &#x27;object&#x27; &amp;&amp; objectToString(re) === &#x27;[object RegExp]&#x27;;
}

function isDate(d) {
  return typeof d === &#x27;object&#x27; &amp;&amp; objectToString(d) === &#x27;[object Date]&#x27;;
}

function isError(e) {
  return typeof e === &#x27;object&#x27; &amp;&amp; objectToString(e) === &#x27;[object Error]&#x27;;
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

});
require.register(&quot;chai/lib/chai/utils/objDisplay.js&quot;, function(exports, require, module){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require(&#x27;./inspect&#x27;);
var config = require(&#x27;../config&#x27;);

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold &amp;&amp; str.length &gt;= config.truncateThreshold) {
    if (type === &#x27;[object Function]&#x27;) {
      return !obj.name || obj.name === &#x27;&#x27;
        ? &#x27;[Function]&#x27;
        : &#x27;[Function: &#x27; + obj.name + &#x27;]&#x27;;
    } else if (type === &#x27;[object Array]&#x27;) {
      return &#x27;[ Array(&#x27; + obj.length + &#x27;) ]&#x27;;
    } else if (type === &#x27;[object Object]&#x27;) {
      var keys = Object.keys(obj)
        , kstr = keys.length &gt; 2
          ? keys.splice(0, 2).join(&#x27;, &#x27;) + &#x27;, ...&#x27;
          : keys.join(&#x27;, &#x27;);
      return &#x27;{ Object (&#x27; + kstr + &#x27;) }&#x27;;
    } else {
      return str;
    }
  } else {
    return str;
  }
};

});
require.register(&quot;chai/lib/chai/utils/overwriteMethod.js&quot;, function(exports, require, module){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, &#x27;equal&#x27;, function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, &#x27;object&#x27;);
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from &#x60;chai.Assertion&#x60;.
 *
 *     chai.Assertion.overwriteMethod(&#x27;foo&#x27;, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal(&#x27;bar&#x27;);
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method &amp;&amp; &#x27;function&#x27; === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

});
require.register(&quot;chai/lib/chai/utils/overwriteProperty.js&quot;, function(exports, require, module){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, &#x27;ok&#x27;, function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, &#x27;object&#x27;);
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal(&#x27;bar&#x27;);
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from &#x60;chai.Assertion&#x60;.
 *
 *     chai.Assertion.overwriteProperty(&#x27;foo&#x27;, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get &amp;&amp; &#x27;function&#x27; === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

});
require.register(&quot;chai/lib/chai/utils/overwriteChainableMethod.js&quot;, function(exports, require, module){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, fn)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, &#x27;length&#x27;,
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from &#x60;chai.Assertion&#x60;.
 *
 *     chai.Assertion.overwriteChainableMethod(&#x27;foo&#x27;, fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

});
require.register(&quot;chai/lib/chai/utils/test.js&quot;, function(exports, require, module){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require(&#x27;./flag&#x27;);

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  var negate = flag(obj, &#x27;negate&#x27;)
    , expr = args[0];
  return negate ? !expr : expr;
};

});
require.register(&quot;chai/lib/chai/utils/transferFlags.js&quot;, function(exports, require, module){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for &#x60;assertion&#x60; to &#x60;object&#x60;. If
 * &#x60;includeAll&#x60; is set to &#x60;false&#x60;, then the base Chai
 * assertion flags (namely &#x60;object&#x60;, &#x60;ssfi&#x60;, and &#x60;message&#x60;)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags too; usually a new assertion
 * @param {Boolean} includeAll
 * @name getAllFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== &#x27;object&#x27; &amp;&amp; flag !== &#x27;ssfi&#x27; &amp;&amp; flag != &#x27;message&#x27;)) {
      object.__flags[flag] = flags[flag];
    }
  }
};

});
require.register(&quot;chai/lib/chai/utils/type.js&quot;, function(exports, require, module){
/*!
 * Chai - type utility
 * Copyright(c) 2012-2014 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */

/*!
 * Detectable javascript natives
 */

var natives = {
    &#x27;[object Arguments]&#x27;: &#x27;arguments&#x27;
  , &#x27;[object Array]&#x27;: &#x27;array&#x27;
  , &#x27;[object Date]&#x27;: &#x27;date&#x27;
  , &#x27;[object Function]&#x27;: &#x27;function&#x27;
  , &#x27;[object Number]&#x27;: &#x27;number&#x27;
  , &#x27;[object RegExp]&#x27;: &#x27;regexp&#x27;
  , &#x27;[object String]&#x27;: &#x27;string&#x27;
};

/**
 * ### type(object)
 *
 * Better implementation of &#x60;typeof&#x60; detection that can
 * be used cross-browser. Handles the inconsistencies of
 * Array, &#x60;null&#x60;, and &#x60;undefined&#x60; detection.
 *
 *     utils.type({}) // &#x27;object&#x27;
 *     utils.type(null) // &#x60;null&#x27;
 *     utils.type(undefined) // &#x60;undefined&#x60;
 *     utils.type([]) // &#x60;array&#x60;
 *
 * @param {Mixed} object to detect type of
 * @name type
 * @api private
 */

module.exports = function (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return &#x27;null&#x27;;
  if (obj === undefined) return &#x27;undefined&#x27;;
  if (obj === Object(obj)) return &#x27;object&#x27;;
  return typeof obj;
};

});




require.alias(&quot;chaijs-assertion-error/index.js&quot;, &quot;chai/deps/assertion-error/index.js&quot;);
require.alias(&quot;chaijs-assertion-error/index.js&quot;, &quot;chai/deps/assertion-error/index.js&quot;);
require.alias(&quot;chaijs-assertion-error/index.js&quot;, &quot;assertion-error/index.js&quot;);
require.alias(&quot;chaijs-assertion-error/index.js&quot;, &quot;chaijs-assertion-error/index.js&quot;);
require.alias(&quot;chaijs-deep-eql/lib/eql.js&quot;, &quot;chai/deps/deep-eql/lib/eql.js&quot;);
require.alias(&quot;chaijs-deep-eql/lib/eql.js&quot;, &quot;chai/deps/deep-eql/index.js&quot;);
require.alias(&quot;chaijs-deep-eql/lib/eql.js&quot;, &quot;deep-eql/index.js&quot;);
require.alias(&quot;chaijs-type-detect/lib/type.js&quot;, &quot;chaijs-deep-eql/deps/type-detect/lib/type.js&quot;);
require.alias(&quot;chaijs-type-detect/lib/type.js&quot;, &quot;chaijs-deep-eql/deps/type-detect/index.js&quot;);
require.alias(&quot;chaijs-type-detect/lib/type.js&quot;, &quot;chaijs-type-detect/index.js&quot;);
require.alias(&quot;chaijs-deep-eql/lib/eql.js&quot;, &quot;chaijs-deep-eql/index.js&quot;);
require.alias(&quot;chai/index.js&quot;, &quot;chai/index.js&quot;);if (typeof exports == &quot;object&quot;) {
  module.exports = require(&quot;chai&quot;);
} else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) {
  define([], function(){ return require(&quot;chai&quot;); });
} else {
  this[&quot;chai&quot;] = require(&quot;chai&quot;);
}})();
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
