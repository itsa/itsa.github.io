<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/io/extra/io-transfer.js - Itsa</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Itsa"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/BaseClass.html">BaseClass</a></li>
            
                <li><a href="../classes/Classes.html">Classes</a></li>
            
                <li><a href="../classes/Constrain.html">Constrain</a></li>
            
                <li><a href="../classes/DB.html">DB</a></li>
            
                <li><a href="../classes/DD.html">DD</a></li>
            
                <li><a href="../classes/Dialog.html">Dialog</a></li>
            
                <li><a href="../classes/document.html">document</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/FocusManager.html">FocusManager</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/HTMLButtonElement.html">HTMLButtonElement</a></li>
            
                <li><a href="../classes/HTMLElement.html">HTMLElement</a></li>
            
                <li><a href="../classes/HTMLInputElement.html">HTMLInputElement</a></li>
            
                <li><a href="../classes/Icons.html">Icons</a></li>
            
                <li><a href="../classes/IndexedDB.html">IndexedDB</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/JSON.html">JSON</a></li>
            
                <li><a href="../classes/LocalStorage.html">LocalStorage</a></li>
            
                <li><a href="../classes/Math.html">Math</a></li>
            
                <li><a href="../classes/Messages.html">Messages</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/NodePlugin.html">NodePlugin</a></li>
            
                <li><a href="../classes/NS-vdom.html">NS-vdom</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Panel.html">Panel</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/Scrollable.html">Scrollable</a></li>
            
                <li><a href="../classes/Storage.html">Storage</a></li>
            
                <li><a href="../classes/String.html">String</a></li>
            
                <li><a href="../classes/SVGElement.html">SVGElement</a></li>
            
                <li><a href="../classes/Uploader.html">Uploader</a></li>
            
                <li><a href="../classes/USERAGENT.html">USERAGENT</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vnode.html">vnode</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/attribute-extractor.html">attribute-extractor</a></li>
            
                <li><a href="../modules/client-db.html">client-db</a></li>
            
                <li><a href="../modules/client-storage.html">client-storage</a></li>
            
                <li><a href="../modules/constrain.html">constrain</a></li>
            
                <li><a href="../modules/dialog.html">dialog</a></li>
            
                <li><a href="../modules/drag.html">drag</a></li>
            
                <li><a href="../modules/drag-drop.html">drag-drop</a></li>
            
                <li><a href="../modules/element-array.html">element-array</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-blurnode.html">event-blurnode</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-focusnode.html">event-focusnode</a></li>
            
                <li><a href="../modules/event-hover.html">event-hover</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/event-mobile.html">event-mobile</a></li>
            
                <li><a href="../modules/extend-document.html">extend-document</a></li>
            
                <li><a href="../modules/extend-element.html">extend-element</a></li>
            
                <li><a href="../modules/extra_classes.js.html">extra/classes.js</a></li>
            
                <li><a href="../modules/focusmanager.html">focusmanager</a></li>
            
                <li><a href="../modules/html-parser.html">html-parser</a></li>
            
                <li><a href="../modules/icons.html">icons</a></li>
            
                <li><a href="../modules/indexeddb.html">indexeddb</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-filetransfer.html">io-filetransfer</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/itsa.build.html">itsa.build</a></li>
            
                <li><a href="../modules/js-ext.html">js-ext</a></li>
            
                <li><a href="../modules/lib_array.js.html">lib/array.js</a></li>
            
                <li><a href="../modules/lib_function.js.html">lib/function.js</a></li>
            
                <li><a href="../modules/lib_json.js.html">lib/json.js</a></li>
            
                <li><a href="../modules/lib_math.js.html">lib/math.js</a></li>
            
                <li><a href="../modules/lib_object.js.html">lib/object.js</a></li>
            
                <li><a href="../modules/lib_promise.s.html">lib/promise.s</a></li>
            
                <li><a href="../modules/lib_string.js.html">lib/string.js</a></li>
            
                <li><a href="../modules/localstorage.html">localstorage</a></li>
            
                <li><a href="../modules/messages.html">messages</a></li>
            
                <li><a href="../modules/node-parser.html">node-parser</a></li>
            
                <li><a href="../modules/node-plugin.html">node-plugin</a></li>
            
                <li><a href="../modules/node-win.html">node-win</a></li>
            
                <li><a href="../modules/panel.html">panel</a></li>
            
                <li><a href="../modules/scrollable.html">scrollable</a></li>
            
                <li><a href="../modules/uploader.html">uploader</a></li>
            
                <li><a href="../modules/useragent.html">useragent</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/vdom.html">vdom</a></li>
            
                <li><a href="../modules/vdom-ns.html">vdom-ns</a></li>
            
                <li><a href="../modules/vnode.html">vnode</a></li>
            
                <li><a href="../modules/window-ext.html">window-ext</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/io/extra/io-transfer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;

/**
 * Extends io by adding the methods &#x60;get&#x60;, &#x60;read&#x60;, &#x60;update&#x60;, &#x60;insert&#x60;, &#x60;send&#x60; and &#x60;delete&#x60; to it.
 *
 * @example
 * var IO = require(&quot;io/extra/io-transfer.js&quot;)(window);
 *
 * &lt;i&gt;Copyright (c) 2014 ITSA - https://github.com/itsa&lt;/i&gt;
 * New BSD License - http://choosealicense.com/licenses/bsd-3-clause/
 *
 * @module io
 * @submodule io-transfer
 * @class IO
 * @since 0.0.1
*/

require(&#x27;js-ext/lib/string.js&#x27;);
require(&#x27;js-ext/lib/object.js&#x27;);
require(&#x27;polyfill/polyfill-base.js&#x27;);

/*jshint proto:true */
var NAME = &#x27;[io-transfer]: &#x27;,
    createHashMap = require(&#x27;js-ext/extra/hashmap.js&#x27;).createMap,
    PROTO_SUPPORTED = !!Object.__proto__,
    REVIVER = function(key, value) {
        return ((typeof value===&#x27;string&#x27;) &amp;&amp; value.toDate()) || value;
    },
    REVIVER_PROTOTYPED = function(key, value, proto, parseProtoCheck, reviveDate) {
        if (reviveDate &amp;&amp; (typeof value===&#x27;string&#x27;)) {
            return value.toDate() || value;
        }
        if (!Object.isObject(value)) {
            return value;
        }
        // only first level of objects can be given the specified prototype
        if ((typeof parseProtoCheck === &#x27;function&#x27;) &amp;&amp; !parseProtoCheck(value)) {
            return value;
        }
        if (PROTO_SUPPORTED) {
            value.__proto__ = proto;
            return value;
        }
        return value.deepClone(null, proto);
    },
    MIME_JSON = &#x27;application/json&#x27;,
    CONTENT_TYPE = &#x27;Content-Type&#x27;,
    DELETE = &#x27;delete&#x27;,
    REGEXP_ARRAY = /^( )*\[/,
    REGEXP_OBJECT = /^( )*{/,
    REGEXP_REMOVE_LAST_COMMA = /^(.*),( )*$/,
    SPINNER_ICON = &#x27;spinnercircle-anim&#x27;,
    MIN_SHOWUP = 500;
/*jshint proto:false */

module.exports = function (window) {

    window._ITSAmodules || Object.protectedProp(window, &#x27;_ITSAmodules&#x27;, createHashMap());

    if (window._ITSAmodules.IO_Transfer) {
        return window._ITSAmodules.IO_Transfer; // IO_Transfer was already created
    }

    var IO = require(&#x27;../io.js&#x27;)(window),

    /*
     * Adds properties to the xhr-object: in case of streaming,
     * xhr._parseStream=function is created to parse streamed data.
     *
     * @method _progressHandle
     * @param xhr {Object} containing the xhr-instance
     * @param props {Object} the propertie-object that is added too xhr and can be expanded
     * @param options {Object} options of the request
     * @private
    */
    _entendXHR = function(xhr, props, options /*, promise */) {
        var isarray, isobject, parialdata, regexpcomma, followingstream;
        if ((typeof options.streamback === &#x27;function&#x27;) &amp;&amp; options.headers &amp;&amp; (options.headers.Accept===&#x27;application/json&#x27;)) {
            console.log(NAME, &#x27;entendXHR&#x27;);
            xhr._parseStream = function(streamData) {
                console.log(NAME, &#x27;entendXHR --&gt; _parseStream&#x27;);
                // first step is to determine if the final response would be an array or an object
                // partial responses should be expanded to the same type
                if (!followingstream) {
                    isarray = REGEXP_ARRAY.test(streamData);
                    isarray || (isobject = REGEXP_OBJECT.test(streamData));
                }
                try {
                    if (isarray || isobject) {
                        regexpcomma = streamData.match(REGEXP_REMOVE_LAST_COMMA);
                        parialdata = regexpcomma ? streamData.match(REGEXP_REMOVE_LAST_COMMA)[1] : streamData;
                    }
                    else {
                        parialdata = streamData;
                    }
                    parialdata = (followingstream &amp;&amp; isarray ? &#x27;[&#x27; : &#x27;&#x27;) + (followingstream &amp;&amp; isobject ? &#x27;{&#x27; : &#x27;&#x27;) + parialdata + (regexpcomma &amp;&amp; isarray ? &#x27;]&#x27; : &#x27;&#x27;) + (regexpcomma &amp;&amp; isobject ? &#x27;}&#x27; : &#x27;&#x27;);
                    // note: parsing will fail for the last streamed part, because there will be a double ] or }
                    streamData = JSON.parse(parialdata, (options.parseJSONDate) ? REVIVER : null);
                }
                catch(err) {
                    console.warn(NAME, err);
                }
                followingstream = true;
                return streamData;
            };
        }
        return xhr;
    };

    IO._xhrList.push(_entendXHR);

    /**
     * Performs an AJAX GET request.  Shortcut for a call to [&#x60;xhr&#x60;](#method_xhr) with &#x60;method&#x60; set to  &#x60;&#x27;GET&#x27;&#x60;.
     * Additional parameters can be on the url (with questionmark), through &#x60;params&#x60;, or both.
     *
     * The Promise gets fulfilled if the server responses with &#x60;STATUS-CODE&#x60; in the 200-range (excluded 204).
     * It will be rejected if a timeout occurs (see &#x60;options.timeout&#x60;), or if &#x60;xhr.abort()&#x60; gets invoked.
     *
     * Note: &#x60;params&#x60; should be a plain object with only primitive types which are transformed into key/value pairs.
     *
     * @method get
     * @param url {String} URL of the resource server
     * @param [params] {Object} additional parameters.
     *        should be a plain object with only primitive types which are transformed into key/value pairs.
     * @param [options] {Object}
     *    @param [options.sync=false] {boolean} By default, all requests are sent asynchronously. To send synchronous requests, set to true.
     *    @param [options.headers] {Object} HTTP request headers.
     *    @param [options.responseType] {String} Force the response type.
     *    @param [options.timeout=3000] {Number} to timeout the request, leading into a rejected Promise.
     *    @param [options.withCredentials=false] {boolean} Whether or not to send credentials on the request.
     *    @param [options.preventCache=false] {boolean} whether to prevent caching --&gt; a timestamp is added by parameter _ts
     *    @param [options.stayActive] {Number} minimal time the request should be pending, even if IO has finished
     * @return {Promise}
     * on success:
        * xhr {XMLHttpRequest|XDomainRequest} xhr-response
     * on failure an Error object
        * reason {Error}
    */
    IO.get = function (url, options) {
        console.log(NAME, &#x27;get --&gt; &#x27;+url);
        var ioPromise, returnPromise;
        options || (options={});
        options.url = url;
        options.method = &#x27;GET&#x27;;
        // delete hidden property &#x60;data&#x60;: don&#x27;t want accedentially to be used
        delete options.data;
        if (options.preventCache) {
            url += (url.contains(&#x27;?&#x27;) ? &#x27;&amp;&#x27; : &#x27;?&#x27;) + &#x27;_ts=&#x27; + Date.now();
        }
        ioPromise = this.request(options);
        returnPromise = ioPromise.then(
            function(xhrResponse) {
                return xhrResponse.responseText;
            }
        );
        // set &#x60;abort&#x60; to the thennable-promise:
        returnPromise.abort = ioPromise.abort;
        return returnPromise;
    };

    /**
     * Performs an AJAX request with the GET HTTP method and expects a JSON-object.
     * The resolved Promise-callback returns an object (JSON-parsed serverresponse).
     *
     * Additional request-parameters can be on the url (with questionmark), through &#x60;params&#x60;, or both.
     *
     * The Promise gets fulfilled if the server responses with &#x60;STATUS-CODE&#x60; in the 200-range (excluded 204).
     * It will be rejected if a timeout occurs (see &#x60;options.timeout&#x60;), or if &#x60;xhr.abort()&#x60; gets invoked.
     *
     * Note1: If you expect the server to response with data that consist of Date-properties, you should set &#x60;options.parseJSONDate&#x60; true.
     *        Parsing takes a bit longer, but it will generate trully Date-objects.
     * Note2: CORS is supported, as long as the responseserver is set up to:
     *       a) has a response header which allows the clientdomain:
     *          header(&#x27;Access-Control-Allow-Origin: http://www.some-site.com&#x27;); or header(&#x27;Access-Control-Allow-Origin: *&#x27;);
     *       b) in cae you have set a custom HEADER (through &#x27;options&#x27;), the responseserver MUST listen and respond
     *          to requests with the OPTION-method
     *       More info:  allows to send to your domain: see http://remysharp.com/2011/04/21/getting-cors-working/
     *
     * @method read
     * @param url {String} URL of the resource server
     * @param [params] {Object} additional parameters.
     * @param [options] {Object} See also: [&#x60;I.io&#x60;](#method_xhr)
     *    can be ignored, even if streams are used --&gt; the returned Promise will always hold all data
     *    @param [options.sync=false] {boolean} By default, all requests are sent asynchronously. To send synchronous requests, set to true.
     *    @param [options.headers] {Object} HTTP request headers.
     *    @param [options.timeout=3000] {Number} to timeout the request, leading into a rejected Promise.
     *    @param [options.withCredentials=false] {boolean} Whether or not to send credentials on the request.
     *    @param [options.parseJSONDate=false] {boolean} Whether the server returns JSON-stringified data which has Date-objects.
     *    @param [options.parseProto] {Object} to set the prototype of any object.
     *    @param [options.parseProtoCheck] {Function} to determine in what case the specified &#x60;parseProto&#x60; should be set as the prototype.
     *            The function accepts the &#x60;object&#x60; as argument and should return a trully value in order to set the prototype.
     *            When not specified, &#x60;parseProto&#x60; will always be applied (if &#x60;parseProto&#x60;is defined)
     *    @param [options.stayActive] {Number} minimal time the request should be pending, even if IO has finished
     * @return {Promise}
     * on success:
        * Object received data
     * on failure an Error object
        * reason {Error}
    */
    IO.read = function(url, params, options) {
        console.log(NAME, &#x27;read  --&gt; &#x27;+url+&#x27; params: &#x27;+JSON.stringify(params));
        var ioPromise, returnPromise;
        options || (options={});
        options.headers || (options.headers={});
        options.url = url;
        options.method = &#x27;GET&#x27;;
        options.data = params;
        options.headers.Accept = &#x27;application/json&#x27;;
        // we don&#x27;t want the user to re-specify the server&#x27;s responsetype:
        delete options.responseType;
        ioPromise = this.request(options);
        returnPromise = ioPromise.then(
            function(xhrResponse) {
                // not &#x27;try&#x27; &#x27;catch&#x27;, because, if parsing fails, we actually WANT the promise to be rejected
                // we also need to re-attach the &#x27;abort-handle&#x27;
                console.log(NAME, &#x27;read returns with: &#x27;+JSON.stringify(xhrResponse.responseText));
                // xhrResponse.responseText should be &#x27;application/json&#x27; --&gt; if it is not,
                // JSON.parse throws an error, but that&#x27;s what we want: the Promise would reject
                if (options.parseProto) {
                    return JSON.parse(xhrResponse.responseText, REVIVER_PROTOTYPED.rbind(null, options.parseProto, options.parseProtoCheck, options.parseJSONDate));
                }
                return JSON.parse(xhrResponse.responseText, (options.parseJSONDate) ? REVIVER : null);
            }
        );
        // set &#x60;abort&#x60; to the thennable-promise:
        returnPromise.abort = ioPromise.abort;
        return returnPromise;
    };


    /**
     * Sends data (object) which will be JSON-stringified before sending.
     * Performs an AJAX request with the PUT HTTP method by default.
     * When options.allfields is &#x60;false&#x60;, it will use the POST-method: see Note2.
     *
     * The &#x27;content-type&#x27; of the header is set to &#x27;application/json&#x27;, overruling manually options.
     *
     * &#x27;data&#x27; is send as &#x27;body.data&#x27; and should be JSON-parsed at the server.
     *
     * The Promise gets fulfilled if the server responses with &#x60;STATUS-CODE&#x60; in the 200-range (excluded 204).
     * It will be rejected if a timeout occurs (see &#x60;options.timeout&#x60;), or if &#x60;xhr.abort()&#x60; gets invoked.
     *
     * Note1: The server needs to inspect the bodyparam: &#x27;action&#x27;, which always equals &#x27;update&#x27;.
     *        &#x27;body.action&#x27; is the way to distinquish &#x27;I.IO.updateObject&#x27; from &#x27;I.IO.insertObject&#x27;.
     *        On purpose, we didn&#x27;t make this distinction through a custom CONTENT-HEADER, because
     *        that would lead into a more complicated CORS-setup (see Note3)
     * Note2: By default this method uses the PUT-request: which is preferable is you send the WHOLE object.
     *        if you send part of the fields, set &#x60;options.allfields&#x60;=false.
     *        This will lead into using the POST-method.
     *        More about HTTP-methods: https://stormpath.com/blog/put-or-post/
     * Note3: CORS is supported, as long as the responseserver is set up to:
     *        a) has a response header which allows the clientdomain:
     *           header(&#x27;Access-Control-Allow-Origin: http://www.some-site.com&#x27;); or header(&#x27;Access-Control-Allow-Origin: *&#x27;);
     *        b) in cae you have set a custom HEADER (through &#x27;options&#x27;), the responseserver MUST listen and respond
     *           to requests with the OPTION-method
     *        More info:  allows to send to your domain: see http://remysharp.com/2011/04/21/getting-cors-working/
     * Note4: If the server response JSON-stringified data, the Promise resolves with a JS-Object. If you expect this object
     *        to consist of Date-properties, you should set &#x60;options.parseJSONDate&#x60; true. Parsing takes a bit longer, but it will
     *        generate trully Date-objects.
     *
     *
     * @method update
     * @param url {String} URL of the resource server
     * @param data {Object|Promise} Data to be sent, might be a Promise which resolves with the data-object.
     * @param [options] {Object} See also: [&#x60;I.io&#x60;](#method_xhr)
     *    @param [options.allfields=true] {boolean} to specify that all the object-fields are sent.
     *    @param [options.sync=false] {boolean} By default, all requests are sent asynchronously. To send synchronous requests, set to true.
     *    @param [options.headers] {Object} HTTP request headers.
     *    @param [options.timeout=3000] {Number} to timeout the request, leading into a rejected Promise.
     *    @param [options.withCredentials=false] {boolean} Whether or not to send credentials on the request.
     *    @param [options.parseJSONDate=false] {boolean} Whether the server returns JSON-stringified data which has Date-objects.
     *    @param [options.stayActive] {Number} minimal time the request should be pending, even if IO has finished
     * @return {Promise}
     * on success:
        * response {Object} usually, the final object-data, possibly modified
     * on failure an Error object
        * reason {Error}
    */

    /**
     * Performs an AJAX request with the POST HTTP method by default.
     * When options.allfields is &#x60;true&#x60;, it will use the PUT-method: see Note2.
     * The send data is an object which will be JSON-stringified before sending.
     *
     * The &#x27;content-type&#x27; of the header is set to &#x27;application/json&#x27;, overruling manually options.
     *
     * &#x27;data&#x27; is send as &#x27;body.data&#x27; and should be JSON-parsed at the server.
     * &#x27;body.action&#x27; has the value &#x27;insert&#x27;
     *
     * The Promise gets fulfilled if the server responses with &#x60;STATUS-CODE&#x60; in the 200-range (excluded 204).
     * It will be rejected if a timeout occurs (see &#x60;options.timeout&#x60;), or if &#x60;xhr.abort()&#x60; gets invoked.
     *
     * Note1: The server needs to inspect the bodyparam: &#x27;action&#x27;, which always equals &#x27;insert&#x27;.
     *        &#x27;body.action&#x27; is the way to distinquish &#x27;I.IO.insertObject&#x27; from &#x27;I.IO.updateObject&#x27;.
     *        On purpose, we didn&#x27;t make this distinction through a custom CONTENT-HEADER, because
     *        that would lead into a more complicated CORS-setup (see Note3)
     * Note2: By default this method uses the POST-request: which is preferable if you don&#x27;t know all the fields (like its unique id).
     *        if you send ALL the fields, set &#x60;options.allfields&#x60;=true.
     *        This will lead into using the PUT-method.
     *        More about HTTP-methods: https://stormpath.com/blog/put-or-post/
     * Note3: CORS is supported, as long as the responseserver is set up to:
     *        a) has a response header which allows the clientdomain:
     *           header(&#x27;Access-Control-Allow-Origin: http://www.some-site.com&#x27;); or header(&#x27;Access-Control-Allow-Origin: *&#x27;);
     *        b) in cae you have set a custom HEADER (through &#x27;options&#x27;), the responseserver MUST listen and respond
     *           to requests with the OPTION-method
     *        More info:  allows to send to your domain: see http://remysharp.com/2011/04/21/getting-cors-working/
     * Note4: If the server response JSON-stringified data, the Promise resolves with a JS-Object. If you expect this object
     *        to consist of Date-properties, you should set &#x60;options.parseJSONDate&#x60; true. Parsing takes a bit longer, but it will
     *        generate trully Date-objects.
     *
     * @method insert
     * @param url {String} URL of the resource server
     * @param data {Object|Promise} Data to be sent, might be a Promise which resolves with the data-object.
     * @param [options] {Object} See also: [&#x60;I.io&#x60;](#method_xhr)
     *    @param [options.allfields=false] {boolean} to specify that all the object-fields are sent.
     *    @param [options.sync=false] {boolean} By default, all requests are sent asynchronously. To send synchronous requests, set to true.
     *    @param [options.headers] {Object} HTTP request headers.
     *    @param [options.timeout=3000] {Number} to timeout the request, leading into a rejected Promise.
     *    @param [options.withCredentials=false] {boolean} Whether or not to send credentials on the request.
     *    @param [options.parseJSONDate=false] {boolean} Whether the server returns JSON-stringified data which has Date-objects.
     *    @param [options.stayActive] {Number} minimal time the request should be pending, even if IO has finished
     * @return {Promise}
     * on success:
        * response {Object} usually, the final object-data, possibly modified, holding the key
     * on failure an Error object
        * reason {Error}
    */

    /**
     * Performs an AJAX request with the PUT HTTP method by default.
     * When options.allfields is &#x60;false&#x60;, it will use the POST-method: see Note2.
     * The send data is an object which will be JSON-stringified before sending.
     *
     * The &#x27;content-type&#x27; of the header is set to &#x27;application/json&#x27;, overruling manually options.
     *
     * &#x27;data&#x27; is send as &#x27;body.data&#x27; and should be JSON-parsed at the server.
     *
     * The Promise gets fulfilled if the server responses with &#x60;STATUS-CODE&#x60; in the 200-range (excluded 204).
     * It will be rejected if a timeout occurs (see &#x60;options.timeout&#x60;), or if &#x60;xhr.abort()&#x60; gets invoked.
     *
     * Note1: By default this method uses the PUT-request: which is preferable is you send the WHOLE object.
     *        if you send part of the fields, set &#x60;options.allfields&#x60;=false.
     *        This will lead into using the POST-method.
     *        More about HTTP-methods: https://stormpath.com/blog/put-or-post/
     * Note2: CORS is supported, as long as the responseserver is set up to:
     *        a) has a response header which allows the clientdomain:
     *           header(&#x27;Access-Control-Allow-Origin: http://www.some-site.com&#x27;); or header(&#x27;Access-Control-Allow-Origin: *&#x27;);
     *        b) in cae you have set a custom HEADER (through &#x27;options&#x27;), the responseserver MUST listen and respond
     *           to requests with the OPTION-method
     *        More info:  allows to send to your domain: see http://remysharp.com/2011/04/21/getting-cors-working/
     * Note3: If the server response JSON-stringified data, the Promise resolves with a JS-Object. If you expect this object
     *        to consist of Date-properties, you should set &#x60;options.parseJSONDate&#x60; true. Parsing takes a bit longer, but it will
     *        generate trully Date-objects.
     *
     * @method send
     * @param url {String} URL of the resource server
     * @param data {Object} Data to be sent.
     * @param [options] {Object} See also: [&#x60;I.io&#x60;](#method_xhr)
     *    @param [options.allfields=true] {boolean} to specify that all the object-fields are sent.
     *    @param [options.sync=false] {boolean} By default, all requests are sent asynchronously. To send synchronous requests, set to true.
     *    @param [options.headers] {Object} HTTP request headers.
     *    @param [options.timeout=3000] {Number} to timeout the request, leading into a rejected Promise.
     *    @param [options.withCredentials=false] {boolean} Whether or not to send credentials on the request.
     *    @param [options.parseJSONDate=false] {boolean} Whether the server returns JSON-stringified data which has Date-objects.
     *    @param [options.stayActive] {Number} minimal time the request should be pending, even if IO has finished
     * @return {Promise}
     * on success:
        * response {Object|String} any response you want the server to return.
                   If the server send back a JSON-stringified object,
                   it will be parsed to return as a full object
                   You could set &#x60;options.parseJSONDate&#x60; true, it you want ISO8601-dates to be parsed as trully Date-objects
     * on failure an Error object
        * reason {Error}
    */

    [&#x27;update&#x27;, &#x27;insert&#x27;, &#x27;send&#x27;].forEach(
        function (verb) {
            IO[verb] = function (url, data, options) {
                console.log(NAME, verb+&#x27; --&gt; &#x27;+url+&#x27; data: &#x27;+JSON.stringify(data));
                var instance = this,
                    allfields, useallfields, parseJSONDate, ioPromise, returnPromise;
                options || (options={});
                allfields = options.allfields,
                useallfields = (typeof allfields===&#x27;boolean&#x27;) ? allfields : (verb!==&#x27;insert&#x27;);
                parseJSONDate = options.parseJSONDate;
                options.url = url;
                options.method = useallfields ? &#x27;PUT&#x27; : &#x27;POST&#x27;;
                options.data = data;
                options.headers || (options.headers={});
                options.headers[CONTENT_TYPE] = MIME_JSON;
                parseJSONDate &amp;&amp; (options.headers[&#x27;X-JSONDate&#x27;]=&quot;true&quot;);
                if (verb!==&#x27;send&#x27;) {
                    options.headers.Accept = &#x27;application/json&#x27;;
                    // set options.action
                    options.headers[&#x27;X-Action&#x27;] = verb;
                    // we don&#x27;t want the user to re-specify the server&#x27;s responsetype:
                    delete options.responseType;
                }
                ioPromise = instance.request(options);
                returnPromise = ioPromise.then(
                    function(xhrResponse) {
                        if (verb===&#x27;send&#x27;) {
                            return xhrResponse.responseText;
                        }
                        // In case of &#x60;insert&#x60; or &#x60;update&#x60;
                        // xhrResponse.responseText should be &#x27;application/json&#x27; --&gt; if it is not,
                        // JSON.parse throws an error, but that&#x27;s what we want: the Promise would reject
                        return JSON.parse(xhrResponse.responseText, parseJSONDate ? REVIVER : null);
                    }
                );
                // set &#x60;abort&#x60; to the thennable-promise:
                returnPromise.abort = ioPromise.abort;
                return returnPromise;
            };
        }
    );

    /**
     * Performs an AJAX DELETE request.  Shortcut for a call to [&#x60;xhr&#x60;](#method_xhr) with &#x60;method&#x60; set to  &#x60;&#x27;DELETE&#x27;&#x60;.
     *
     * The Promise gets fulfilled if the server responses with &#x60;STATUS-CODE&#x60; in the 200-range (excluded 204).
     * It will be rejected if a timeout occurs (see &#x60;options.timeout&#x60;), or if &#x60;xhr.abort()&#x60; gets invoked.
     *
     * Note: &#x60;data&#x60; should be a plain object with only primitive types which are transformed into key/value pairs.
     *
     * @method delete
     * @param url {String} URL of the resource server
     * @param deleteKey {Object} Indentification of the id that has to be deleted. Typically an object like: {id: 12}
     *                  This object will be passed as the request params.
     * @param [options] {Object}
     *    @param [options.url] {String} The url to which the request is sent.
     *    @param [options.sync=false] {boolean} By default, all requests are sent asynchronously. To send synchronous requests, set to true.
     *    @param [options.params] {Object} Data to be sent to the server.
     *    @param [options.body] {Object} The content for the request body for POST method.
     *    @param [options.headers] {Object} HTTP request headers.
     *    @param [options.timeout=3000] {Number} to timeout the request, leading into a rejected Promise.
     *    @param [options.withCredentials=false] {boolean} Whether or not to send credentials on the request.
     *    @param [options.parseJSONDate=false] {boolean} Whether the server returns JSON-stringified data which has Date-objects.
     *    @param [options.stayActive] {Number} minimal time the request should be pending, even if IO has finished
     * @return {Promise}
     * on success:
        * response {Object|String} any response you want the server to return.
                   If the server send back a JSON-stringified object,
                   it will be parsed to return as a full object
                   You could set &#x60;options.parseJSONDate&#x60; true, it you want ISO8601-dates to be parsed as trully Date-objects
     * on failure an Error object
        * reason {Error}
    */

    IO[DELETE] = function (url, deleteKey, options) {
        console.log(NAME, &#x27;delete --&gt; &#x27;+url+&#x27; deleteKey: &#x27;+JSON.stringify(deleteKey));
        var ioPromise, returnPromise;
        options || (options={});
        options.url = url;
        // method will be uppercased by IO.xhr
        options.method = DELETE;
        options.data = deleteKey;
        delete options.responseType;
        ioPromise = this.request(options);
        returnPromise = ioPromise.then(
            function(xhrResponse) {
                var response = xhrResponse.responseText;
                try {
                    response = JSON.parse(response, (options.parseJSONDate) ? REVIVER : null);
                }
                catch(err) {}
                return response;
            }
        );
        // set &#x60;abort&#x60; to the thennable-promise:
        returnPromise.abort = ioPromise.abort;
        return returnPromise;
    };

    window._ITSAmodules.IO_Transfer = IO;

    return IO;
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
