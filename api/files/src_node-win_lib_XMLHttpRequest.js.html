<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/node-win/lib/XMLHttpRequest.js - Itsa</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Itsa"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/DD.html">DD</a></li>
            
                <li><a href="../classes/document.html">document</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/FocusManager.html">FocusManager</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/NS-vdom.html">NS-vdom</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Plugins.html">Plugins</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/String.html">String</a></li>
            
                <li><a href="../classes/USERAGENT.html">USERAGENT</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vnode.html">vnode</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/attribute-extractor.html">attribute-extractor</a></li>
            
                <li><a href="../modules/drag.html">drag</a></li>
            
                <li><a href="../modules/drag-drop.html">drag-drop</a></li>
            
                <li><a href="../modules/element-array.html">element-array</a></li>
            
                <li><a href="../modules/element-plugin.html">element-plugin</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-hover.html">event-hover</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/event-mobile.html">event-mobile</a></li>
            
                <li><a href="../modules/extend-document.html">extend-document</a></li>
            
                <li><a href="../modules/extend-element.html">extend-element</a></li>
            
                <li><a href="../modules/focusmanager.html">focusmanager</a></li>
            
                <li><a href="../modules/html-parser.html">html-parser</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/itsa.build.html">itsa.build</a></li>
            
                <li><a href="../modules/js-ext.html">js-ext</a></li>
            
                <li><a href="../modules/lib_array.js.html">lib/array.js</a></li>
            
                <li><a href="../modules/lib_function.js.html">lib/function.js</a></li>
            
                <li><a href="../modules/lib_object.js.html">lib/object.js</a></li>
            
                <li><a href="../modules/lib_promise.s.html">lib/promise.s</a></li>
            
                <li><a href="../modules/lib_string.js.html">lib/string.js</a></li>
            
                <li><a href="../modules/node-parser.html">node-parser</a></li>
            
                <li><a href="../modules/node-win.html">node-win</a></li>
            
                <li><a href="../modules/useragent.html">useragent</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/vdom.html">vdom</a></li>
            
                <li><a href="../modules/vdom-ns.html">vdom-ns</a></li>
            
                <li><a href="../modules/vnode.html">vnode</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/node-win/lib/XMLHttpRequest.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;

/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include(&quot;XMLHttpRequest.js&quot;) and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi &lt;dan@driverdan.com&gt;
 * @contributor David Ellis &lt;d.f.ellis@ieee.org&gt;
 * @license MIT
 */

var Url = require(&quot;url&quot;),
    spawn = require(&quot;child_process&quot;).spawn,
    fs = require(&#x27;fs&#x27;),
    XmlDOMParser = require(&#x27;xmldom&#x27;).DOMParser;

exports.XMLHttpRequest = function() {
  /**
   * Private variables
   */
  var self = this;
  var http = require(&#x27;http&#x27;);
  var https = require(&#x27;https&#x27;);

  // Holds http.js objects
  var request;
  var response;

  // Request settings
  var settings = {};

  // Disable header blacklist.
  // Not part of XHR specs.
  var disableHeaderCheck = false;

  // Set some default headers
  var defaultHeaders = {
    &quot;User-Agent&quot;: &quot;node-XMLHttpRequest&quot;,
    &quot;Accept&quot;: &quot;*/*&quot;
  };

  var headers = defaultHeaders;

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  var forbiddenRequestHeaders = [
    &quot;accept-charset&quot;,
    &quot;accept-encoding&quot;,
    &quot;access-control-request-headers&quot;,
    &quot;access-control-request-method&quot;,
    &quot;connection&quot;,
    &quot;content-length&quot;,
    &quot;content-transfer-encoding&quot;,
    &quot;cookie&quot;,
    &quot;cookie2&quot;,
    &quot;date&quot;,
    &quot;expect&quot;,
    &quot;host&quot;,
    &quot;keep-alive&quot;,
    &quot;origin&quot;,
    &quot;referer&quot;,
    &quot;te&quot;,
    &quot;trailer&quot;,
    &quot;transfer-encoding&quot;,
    &quot;upgrade&quot;,
    &quot;via&quot;
  ];

  // These request methods are not allowed
  var forbiddenRequestMethods = [
    &quot;TRACE&quot;,
    &quot;TRACK&quot;,
    &quot;CONNECT&quot;
  ];

  // Send flag
  var sendFlag = false;
  // Error flag, used when errors occur or abort is called
  var errorFlag = false;

  // Event listeners
  var listeners = {};

  /**
   * Constants
   */

  this.UNSENT = 0;
  this.OPENED = 1;
  this.HEADERS_RECEIVED = 2;
  this.LOADING = 3;
  this.DONE = 4;

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT;

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null;

  // Result &amp; response
  this.responseText = &quot;&quot;;
  this.responseXML = null;
  this.status = null;
  this.statusText = null;

  /**
   * Private methods
   */

  var isXMLRequest = function() {
      return /^text\/xml/.test(response.headers[&#x27;content-type&#x27;]);
  };

  /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpHeader = function(header) {
    return disableHeaderCheck || (header &amp;&amp; forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
  };

  /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpMethod = function(method) {
    return (method &amp;&amp; forbiddenRequestMethods.indexOf(method) === -1);
  };

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */
  this.open = function(method, url, async, user, password) {
    this.abort();
    errorFlag = false;

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) {
      throw &quot;SecurityError: Request method not allowed&quot;;
    }

    settings = {
      &quot;method&quot;: method,
      &quot;url&quot;: url.toString(),
      &quot;async&quot;: (typeof async !== &quot;boolean&quot; ? true : async),
      &quot;user&quot;: user || null,
      &quot;password&quot;: password || null
    };

    setState(this.OPENED);
  };

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function(state) {
    disableHeaderCheck = state;
  };

  /**
   * Sets a header for the request.
   *
   * @param string header Header name
   * @param string value Header value
   */
  this.setRequestHeader = function(header, value) {
    if (this.readyState != this.OPENED) {
      throw &quot;INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN&quot;;
    }
    if (!isAllowedHttpHeader(header)) {
      console.warn(&#x27;Refused to set unsafe header &quot;&#x27; + header + &#x27;&quot;&#x27;);
      return;
    }
    if (sendFlag) {
      throw &quot;INVALID_STATE_ERR: send flag is true&quot;;
    }
    headers[header] = value;
  };

  /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn&#x27;t exist.
   */
  this.getResponseHeader = function(header) {
    if (typeof header === &quot;string&quot; &amp;&amp; this.readyState &gt; this.OPENED &amp;&amp; response.headers[header.toLowerCase()] &amp;&amp; !errorFlag) {
      return response.headers[header.toLowerCase()];
    }

    return null;
  };

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function() {
    if (this.readyState &lt; this.HEADERS_RECEIVED || errorFlag) {
      return &quot;&quot;;
    }
    var result = &quot;&quot;;

    for (var i in response.headers) {
      // Cookie headers are excluded
      if (i !== &quot;set-cookie&quot; &amp;&amp; i !== &quot;set-cookie2&quot;) {
        result += i + &quot;: &quot; + response.headers[i] + &quot;\r\n&quot;;
      }
    }
    return result.substr(0, result.length - 2);
  };

  /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */
  this.getRequestHeader = function(name) {
    // @TODO Make this case insensitive
    if (typeof name === &quot;string&quot; &amp;&amp; headers[name]) {
      return headers[name];
    }

    return &quot;&quot;;
  };

  /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */
  this.send = function(data) {
    if (this.readyState != this.OPENED) {
      throw &quot;INVALID_STATE_ERR: connection must be opened before send() is called&quot;;
    }

    if (sendFlag) {
      throw &quot;INVALID_STATE_ERR: send has already been called&quot;;
    }

    var ssl = false, local = false;
    var url = Url.parse(settings.url);
    var host, responseHandler, errorHandler;
    // Determine the server
    switch (url.protocol) {
      case &#x27;https:&#x27;:
        ssl = true;
        host = url.hostname;
        break;

      case &#x27;http:&#x27;:
        host = url.hostname;
        break;

      case &#x27;file:&#x27;:
        local = true;
        break;

      case undefined:
      case &#x27;&#x27;:
        host = &quot;localhost&quot;;
        break;

      default:
        throw &quot;Protocol not supported.&quot;;
    }

    // Load files off the local filesystem (file://)
    if (local) {
      if (settings.method !== &quot;GET&quot;) {
        throw &quot;XMLHttpRequest: Only GET method is supported&quot;;
      }

      if (settings.async) {
        fs.readFile(url.pathname, &#x27;utf8&#x27;, function(error, data) {
          if (error) {
            self.handleError(error);
          } else {
            self.status = 200;
            self.responseText = data;
            self.responseXML = isXMLRequest() ? new XmlDOMParser().parseFromString(data) : null;
            setState(self.DONE);
          }
        });
      } else {
        try {
          this.responseText = fs.readFileSync(url.pathname, &#x27;utf8&#x27;);
          self.responseXML = isXMLRequest() ? new XmlDOMParser().parseFromString(this.responseText) : null;
          this.status = 200;
          setState(self.DONE);
        } catch(e) {
          this.handleError(e);
        }
      }

      return;
    }

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    var port = url.port || (ssl ? 443 : 80);
    // Add query string if one is used
    var uri = url.pathname + (url.search ? url.search : &#x27;&#x27;);

    // Set the Host header or the server may reject the request
    headers.Host = host;
    if (!((ssl &amp;&amp; port === 443) || port === 80)) {
      headers.Host += &#x27;:&#x27; + url.port;
    }

    // Set Basic Auth if necessary
    if (settings.user) {
      if (typeof settings.password == &quot;undefined&quot;) {
        settings.password = &quot;&quot;;
      }
      var authBuf = new Buffer(settings.user + &quot;:&quot; + settings.password);
      headers.Authorization = &quot;Basic &quot; + authBuf.toString(&quot;base64&quot;);
    }

    // Set content length header
    if (settings.method === &quot;GET&quot; || settings.method === &quot;HEAD&quot;) {
      data = null;
    } else if (data) {
      headers[&quot;Content-Length&quot;] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);

      if (!headers[&quot;Content-Type&quot;]) {
        headers[&quot;Content-Type&quot;] = &quot;text/plain;charset=UTF-8&quot;;
      }
    } else if (settings.method === &quot;POST&quot;) {
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don&#x27;t meet the specs.
      headers[&quot;Content-Length&quot;] = 0;
    }

    var options = {
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: false
    };

    // Reset error flag
    errorFlag = false;

    // Handle async requests
    if (settings.async) {
      // Use the proper protocol
      var doRequest = ssl ? https.request : http.request;

      // Request is being sent, set send flag
      sendFlag = true;

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent(&quot;readystatechange&quot;);

      // Handler for the response
      responseHandler = function(resp) {
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp;
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
          // Change URL to the redirect location
          settings.url = response.headers.location;
          var url = Url.parse(settings.url);
          // Set host var in case it&#x27;s used later
          host = url.hostname;
          // Options for the new request
          var newOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? &#x27;GET&#x27; : settings.method,
            headers: headers
          };

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on(&#x27;error&#x27;, errorHandler);
          request.end();
          // @TODO Check if an XHR event needs to be fired here
          return;
        }

        response.setEncoding(&quot;utf8&quot;);

        setState(self.HEADERS_RECEIVED);
        self.status = response.statusCode;

        response.on(&#x27;data&#x27;, function(chunk) {
          // Make sure there&#x27;s some data
          if (chunk) {
            self.responseText += chunk;
          }
          // Don&#x27;t emit state changes if the connection has been aborted.
          if (sendFlag) {
            setState(self.LOADING);
          }
        });

        response.on(&#x27;end&#x27;, function() {
          if (sendFlag) {
            self.responseXML = isXMLRequest() ? new XmlDOMParser().parseFromString(self.responseText) : null;
            // Discard the &#x27;end&#x27; event if the connection has been aborted
            setState(self.DONE);
            sendFlag = false;
          }
        });

        response.on(&#x27;error&#x27;, function(error) {
          self.handleError(error);
        });
      };

      // Error handler for the request
      errorHandler = function(error) {
        self.handleError(error);
      };

      // Create the request
      request = doRequest(options, responseHandler).on(&#x27;error&#x27;, errorHandler);

      // Node 0.4 and later won&#x27;t accept empty data. Make sure it&#x27;s needed.
      if (data) {
        request.write(data);
      }

      request.end();

      self.dispatchEvent(&quot;loadstart&quot;);
    } else { // Synchronous
      // Create a temporary file for communication with the other Node process
      var contentFile = &quot;.node-xmlhttprequest-content-&quot; + process.pid;
      var syncFile = &quot;.node-xmlhttprequest-sync-&quot; + process.pid;
      fs.writeFileSync(syncFile, &quot;&quot;, &quot;utf8&quot;);
      // The async request the other Node process executes
      var execString = &quot;var http = require(&#x27;http&#x27;), https = require(&#x27;https&#x27;), fs = require(&#x27;fs&#x27;);&quot; +
        &quot;var doRequest = http&quot; + (ssl ? &quot;s&quot; : &quot;&quot;) + &quot;.request;&quot; +
        &quot;var options = &quot; + JSON.stringify(options) + &quot;;&quot; +
        &quot;var responseText = &#x27;&#x27;;&quot; +
        &quot;var req = doRequest(options, function(response) {&quot; +
        &quot;response.setEncoding(&#x27;utf8&#x27;);&quot; +
        &quot;response.on(&#x27;data&#x27;, function(chunk) {&quot; +
        &quot;  responseText += chunk;&quot; +
        &quot;});&quot; +
        &quot;response.on(&#x27;end&#x27;, function() {&quot; +
        &quot;fs.writeFileSync(&#x27;&quot; + contentFile + &quot;&#x27;, &#x27;NODE-XMLHTTPREQUEST-STATUS:&#x27; + response.statusCode + &#x27;,&#x27; + responseText, &#x27;utf8&#x27;);&quot; +
        &quot;fs.unlinkSync(&#x27;&quot; + syncFile + &quot;&#x27;);&quot; +
        &quot;});&quot; +
        &quot;response.on(&#x27;error&#x27;, function(error) {&quot; +
        &quot;fs.writeFileSync(&#x27;&quot; + contentFile + &quot;&#x27;, &#x27;NODE-XMLHTTPREQUEST-ERROR:&#x27; + JSON.stringify(error), &#x27;utf8&#x27;);&quot; +
        &quot;fs.unlinkSync(&#x27;&quot; + syncFile + &quot;&#x27;);&quot; +
        &quot;});&quot; +
        &quot;}).on(&#x27;error&#x27;, function(error) {&quot; +
        &quot;fs.writeFileSync(&#x27;&quot; + contentFile + &quot;&#x27;, &#x27;NODE-XMLHTTPREQUEST-ERROR:&#x27; + JSON.stringify(error), &#x27;utf8&#x27;);&quot; +
        &quot;fs.unlinkSync(&#x27;&quot; + syncFile + &quot;&#x27;);&quot; +
        &quot;});&quot; +
        (data ? &quot;req.write(&#x27;&quot; + data.replace(/&#x27;/g, &quot;\\&#x27;&quot;) + &quot;&#x27;);&quot;:&quot;&quot;) +
        &quot;req.end();&quot;;
      // Start the other Node Process, executing this string
      var syncProc = spawn(process.argv[0], [&quot;-e&quot;, execString]);
/*jshint noempty:true */
      // Wait while the sync file is empty
      while (fs.existsSync(syncFile)) {}
/*jshint noempty:false */
      self.responseText = fs.readFileSync(contentFile, &#x27;utf8&#x27;);
      self.responseXML = isXMLRequest() ? new XmlDOMParser().parseFromString(self.responseText) : null;
      // Kill the child process once the file has data
      syncProc.stdin.end();
      // Remove the temporary file
      fs.unlinkSync(contentFile);
      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {
        // If the file returned an error, handle it
        var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, &quot;&quot;);
        self.handleError(errorObj);
      } else {
        // If the file returned okay, parse its data and move to the DONE state
        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, &quot;$1&quot;);
        self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, &quot;$1&quot;);
        setState(self.DONE);
      }
    }
  };

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function(error) {
    this.status = 503;
    this.statusText = error;
    this.responseText = error.stack;
    errorFlag = true;
    setState(this.DONE);
  };

  /**
   * Aborts a request.
   */
  this.abort = function() {
    if (request) {
      request.abort();
      request = null;
    }

    headers = defaultHeaders;
    this.responseText = &quot;&quot;;
    this.responseXML = &quot;&quot;;

    errorFlag = true;

    if (this.readyState !== this.UNSENT &amp;&amp; (this.readyState !== this.OPENED || sendFlag) &amp;&amp; this.readyState !== this.DONE) {
      sendFlag = false;
      setState(this.DONE);
    }
    this.readyState = this.UNSENT;
  };

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function(event, callback) {
    if (!(event in listeners)) {
      listeners[event] = [];
    }
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback);
  };

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function(event, callback) {
    if (event in listeners) {
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function(ev) {
        return ev !== callback;
      });
    }
  };

  /**
   * Dispatch any events, including both &quot;on&quot; methods and events attached using addEventListener.
   */
  this.dispatchEvent = function(event) {
    if (typeof self[&quot;on&quot; + event] === &quot;function&quot;) {
      self[&quot;on&quot; + event]();
    }
    if (event in listeners) {
      for (var i = 0, len = listeners[event].length; i &lt; len; i++) {
        listeners[event][i].call(self);
      }
    }
  };

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */
  var setState = function(state) {
    if ((self.readyState !== state) || (settings.async &amp;&amp; (self.readyState===self.LOADING))) {
      self.readyState = state;

      if (settings.async || self.readyState &lt; self.OPENED || self.readyState === self.DONE) {
          self.dispatchEvent(&quot;readystatechange&quot;);
      }

      if (settings.async &amp;&amp; (self.readyState===self.LOADING)) {
          self.dispatchEvent(&quot;progress&quot;);
      }

      if (self.readyState === self.DONE &amp;&amp; !errorFlag) {
          self.dispatchEvent(&quot;load&quot;);
          // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
          self.dispatchEvent(&quot;loadend&quot;);
      }
    }

  };
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
