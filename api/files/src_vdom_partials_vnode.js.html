<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/vdom/partials/vnode.js - Itsa</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Itsa"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/DD.html">DD</a></li>
            
                <li><a href="../classes/document.html">document</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/FocusManager.html">FocusManager</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/NS-vdom.html">NS-vdom</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Plugins.html">Plugins</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/String.html">String</a></li>
            
                <li><a href="../classes/USERAGENT.html">USERAGENT</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vnode.html">vnode</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/attribute-extractor.html">attribute-extractor</a></li>
            
                <li><a href="../modules/drag.html">drag</a></li>
            
                <li><a href="../modules/drag-drop.html">drag-drop</a></li>
            
                <li><a href="../modules/element-array.html">element-array</a></li>
            
                <li><a href="../modules/element-plugin.html">element-plugin</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-hover.html">event-hover</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/event-mobile.html">event-mobile</a></li>
            
                <li><a href="../modules/extend-document.html">extend-document</a></li>
            
                <li><a href="../modules/extend-element.html">extend-element</a></li>
            
                <li><a href="../modules/focusmanager.html">focusmanager</a></li>
            
                <li><a href="../modules/html-parser.html">html-parser</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/itsa.build.html">itsa.build</a></li>
            
                <li><a href="../modules/js-ext.html">js-ext</a></li>
            
                <li><a href="../modules/lib_array.js.html">lib/array.js</a></li>
            
                <li><a href="../modules/lib_function.js.html">lib/function.js</a></li>
            
                <li><a href="../modules/lib_object.js.html">lib/object.js</a></li>
            
                <li><a href="../modules/lib_promise.s.html">lib/promise.s</a></li>
            
                <li><a href="../modules/lib_string.js.html">lib/string.js</a></li>
            
                <li><a href="../modules/node-parser.html">node-parser</a></li>
            
                <li><a href="../modules/node-win.html">node-win</a></li>
            
                <li><a href="../modules/useragent.html">useragent</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/vdom.html">vdom</a></li>
            
                <li><a href="../modules/vdom-ns.html">vdom-ns</a></li>
            
                <li><a href="../modules/vnode.html">vnode</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/vdom/partials/vnode.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;

/**
 * Delivers the &#x60;vnode&#x60; prototype object, which is a virtualisation of an &#x60;Element&#x60; inside the Dom.
 * These Elements work smoothless with the vdom (see ...).
 *
 * vnodes are much quicker to access and walk through than native dom-nodes. However, this is a module you don&#x27;t need
 * by itself: &#x60;Element&#x60;-types use these features under the hood.
 *
 *
 * &lt;i&gt;Copyright (c) 2014 ITSA - https://github.com/itsa&lt;/i&gt;
 * &lt;br&gt;
 * New BSD License - http://choosealicense.com/licenses/bsd-3-clause/
 *
 *
 * @module vdom
 * @submodule vnode
 * @class vnode
 * @since 0.0.1
*/

require(&#x27;js-ext/lib/array.js&#x27;);
require(&#x27;js-ext/lib/object.js&#x27;);
require(&#x27;js-ext/lib/string.js&#x27;);
require(&#x27;js-ext/extra/lightmap.js&#x27;);
require(&#x27;polyfill&#x27;);

module.exports = function (window) {

    window._ITSAmodules || Object.protectedProp(window, &#x27;_ITSAmodules&#x27;, {});

    if (window._ITSAmodules.VNode) {
        return window._ITSAmodules.VNode; // VNODE was already created
    }

    var NS = require(&#x27;./vdom-ns.js&#x27;)(window),
        extractor = require(&#x27;./attribute-extractor.js&#x27;)(window),
        DOCUMENT = window.document,
        MUTATION_EVENTS = new window.LightMap(),
        BATCH_WILL_RUN = false,
        nodeids = NS.nodeids,
        htmlToVNodes = require(&#x27;./html-parser.js&#x27;)(window),
        timers = require(&#x27;utils/lib/timers.js&#x27;),
        async = timers.async,
        later = timers.later,

        // cleanup memory after 1 minute: removed nodes SHOULD NOT be accessed afterwards
        // because vnode would be recalculated and might be different from before
        DESTROY_DELAY = 60000,

        NTH_CHILD_REGEXP = /^(?:(\d*)[n|N])([\+|\-](\d+))?$/, // an+b
        STRING = &#x27;string&#x27;,
        CLASS = &#x27;class&#x27;,
        STYLE = &#x27;style&#x27;,
        ID = &#x27;id&#x27;,
        NODE= &#x27;node&#x27;,
        REMOVE = &#x27;remove&#x27;,
        INSERT = &#x27;insert&#x27;,
        CHANGE = &#x27;change&#x27;,
        ATTRIBUTE = &#x27;attribute&#x27;,
        EV_REMOVED = NODE+REMOVE,
        EV_INSERTED = NODE+INSERT,
        EV_CONTENT_CHANGE = NODE+&#x27;content&#x27;+CHANGE,
        EV_ATTRIBUTE_REMOVED = ATTRIBUTE+REMOVE,
        EV_ATTRIBUTE_CHANGED = ATTRIBUTE+CHANGE,
        EV_ATTRIBUTE_INSERTED = ATTRIBUTE+INSERT,
        SPLIT_CHARACTER = {
            &#x27; &#x27;: true,
            &#x27;&gt;&#x27;: true,
            &#x27;+&#x27;: true, // only select the element when it is immediately preceded by the former element
            &#x27;~&#x27;: true  // only the element when it has the former element as a sibling. (just like &#x60;+&#x60;, but less strict)
        },
        STORABLE_SPLIT_CHARACTER = {
            &#x27;&gt;&#x27;: true,
            &#x27;+&#x27;: true,
            &#x27;~&#x27;: true
        },
        SIBLING_MATCH_CHARACTER = {
            &#x27;+&#x27;: true,
            &#x27;~&#x27;: true
        },
        ATTR_DETAIL_SPECIFIERS = {
            &#x27;^&#x27;: true, // “begins with” selector
            &#x27;$&#x27;: true, // “ends with” selector
            &#x27;*&#x27;: true, // “contains” selector (might be a substring)
            &#x27;~&#x27;: true, // “contains” selector as a separate word, separated by spaces
            &#x27;|&#x27;: true // “contains” selector as a separate word, separated by &#x60;|&#x60;
        },
        /**
         * Object to gain quick access to attribute-name end-tokens.
         *
         * @property END_ATTRIBUTENAME
         * @default {
         *      &#x27;=&#x27;: true,
         *      &#x27;]&#x27;: true
         *  }
         * @type Object
         * @protected
         * @since 0.0.1
         */
        END_ATTRIBUTENAME = {
            &#x27;=&#x27;: true,
            &#x27;]&#x27;: true,
            &#x27;^&#x27;: true, // “begins with” selector
            &#x27;$&#x27;: true, // “ends with” selector
            &#x27;*&#x27;: true, // “contains” selector (might be a substring)
            &#x27;~&#x27;: true, // “contains” selector as a separate word, separated by spaces
            &#x27;|&#x27;: true // “contains” selector as a separate word, separated by &#x60;|&#x60;
        },
        /**
         * Object to gain quick access to different changes of Element nodeType changes.
         *
         * @property NODESWITCH
         * @default {
         *      1: {
         *          1: 1,
         *          3: 2,
         *          8: 3
         *      },
         *      3: {
         *          1: 4,
         *          3: 5,
         *          8: 6
         *      },
         *      8: {
         *          1: 7,
         *          3: 8,
         *          8: 9
         *      }
         *  }
         * @type Object
         * @protected
         * @since 0.0.1
         */
        NODESWITCH = {
            1: {
                1: 1, // oldNodeType==Element, newNodeType==Element
                3: 2, // oldNodeType==Element, newNodeType==TextNode
                8: 3  // oldNodeType==Element, newNodeType==Comment
            },
            3: {
                1: 4, // oldNodeType==TextNode, newNodeType==Element
                3: 5, // oldNodeType==TextNode, newNodeType==TextNode
                8: 6  // oldNodeType==TextNode, newNodeType==Comment
            },
            8: {
                1: 7, // oldNodeType==Comment, newNodeType==Element
                3: 8, // oldNodeType==Comment, newNodeType==TextNode
                8: 9  // oldNodeType==Comment, newNodeType==Comment
            }
        },
        /**
         * Object to gain quick access to selector start-tokens.
         *
         * @property SELECTOR_IDENTIFIERS
         * @default {
         *      &#x27;#&#x27;: 1,
         *      &#x27;.&#x27;: 2,
         *      &#x27;[&#x27;: 3
         *  }
         * @type Object
         * @protected
         * @since 0.0.1
         */
        SELECTOR_IDENTIFIERS = {
            &#x27;#&#x27;: 1,
            &#x27;.&#x27;: 2,
            &#x27;[&#x27;: 3,
            &#x27;:&#x27;: 4
        },
        PSEUDO_FIRST_CHILD = &#x27;:first-child&#x27;,
        PSEUDO_FIRST_OF_TYPE = &#x27;:first-of-type&#x27;,
        PSEUDO_LAST_CHILD = &#x27;:last-child&#x27;,
        PSEUDO_LAST_OF_TYPE = &#x27;:last-of-type&#x27;,
        PSEUDO_NTH_CHILD = &#x27;:nth-child&#x27;,
        PSEUDO_NTH_LAST_CHILD = &#x27;:nth-last-child&#x27;,
        PSEUDO_NTH_LAST_OF_TYPE = &#x27;:nth-last-of-type&#x27;,
        PSEUDO_NTH_OF_TYPE = &#x27;:nth-of-type&#x27;,
        PSEUDO_ONLY_OF_TYPE = &#x27;:only-of-type&#x27;,
        PSEUDO_ONLY_CHILD = &#x27;:only-child&#x27;,
        /**
         * Object to gain quick access to the selectors that required children
         *
         * @property PSEUDO_REQUIRED_CHILDREN
         * @default {
         *     &#x27;:first-child&#x27;: true,
         *     &#x27;:first-of-type&#x27;: true,
         *     &#x27;:last-child&#x27;: true,
         *     &#x27;:last-of-type&#x27;: true,
         *     &#x27;:nth-child&#x27;: true,
         *     &#x27;:nth-last-child&#x27;: true,
         *     &#x27;:nth-last-of-type&#x27;: true,
         *     &#x27;:nth-of-type&#x27;: true,
         *     &#x27;:only-of-type&#x27;: true,
         *     &#x27;:only-child&#x27;: true
         *  }
         * @type Object
         * @protected
         * @since 0.0.1
         */
        PSEUDO_REQUIRED_CHILDREN = {},
        _matchesSelectorItem, _matchesOneSelector, _findElementSibling, vNodeProto, _markRemoved,
        _splitSelector, _findNodeSibling, _matchNthChild, _batchEmit, _emitDestroyChildren;
        PSEUDO_REQUIRED_CHILDREN[PSEUDO_FIRST_CHILD] = true;
        PSEUDO_REQUIRED_CHILDREN[PSEUDO_FIRST_OF_TYPE] = true;
        PSEUDO_REQUIRED_CHILDREN[PSEUDO_LAST_CHILD] = true;
        PSEUDO_REQUIRED_CHILDREN[PSEUDO_LAST_OF_TYPE] = true;
        PSEUDO_REQUIRED_CHILDREN[PSEUDO_NTH_CHILD] = true;
        PSEUDO_REQUIRED_CHILDREN[PSEUDO_NTH_LAST_CHILD] = true;
        PSEUDO_REQUIRED_CHILDREN[PSEUDO_NTH_LAST_OF_TYPE] = true;
        PSEUDO_REQUIRED_CHILDREN[PSEUDO_NTH_OF_TYPE] = true;
        PSEUDO_REQUIRED_CHILDREN[PSEUDO_ONLY_OF_TYPE] = true;
        PSEUDO_REQUIRED_CHILDREN[PSEUDO_ONLY_CHILD] = true;

   /**
    * Searches for the next -or previous- node-sibling (nodeType of 1, 3 or 8).
    *
    * @method _findNodeSibling
    * @param vnode {Object} the vnode to inspect
    * @param [next] {Boolean} whether to search for the next, or previous match.
    * @return {Object|undefined} the vnode that matches the search
    * @protected
    * @private
    * @since 0.0.1
    */
    _findNodeSibling = function(vnode, next) {
        var vParent = vnode.vParent,
            index;
        if (!vParent || !vParent.vChildNodes) {
            return;
        }
        index = vParent.vChildNodes.indexOf(vnode) + (next ? 1 : -1);
        return vParent.vChildNodes[index];
    };

   /**
    * Searches for the next -or previous- Element-sibling (nodeType of 1).
    *
    * @method _findElementSibling
    * @param vnode {Object} the vnode to inspect
    * @param [next] {Boolean} whether to search for the next, or previous match.
    * @return {Object|undefined} the vnode that matches the search
    * @protected
    * @private
    * @since 0.0.1
    */
    _findElementSibling = function(vnode, next) {
        var vParent = vnode.vParent,
            index;
        if (!vParent || !vParent.vChildNodes) {
            return;
        }
        if (vnode.nodeType===1) {
            index = vParent.vChildren.indexOf(vnode) + (next ? 1 : -1);
            return vParent.vChildren[index];
        }
        else {
/*jshint noempty:true */
            while ((vnode=_findNodeSibling(vnode, next)) &amp;&amp; (vnode.nodeType!==1)) {}
/*jshint noempty:false */
            return vnode;
        }
    };

   /**
    * Check whether the vnode matches a &quot;nth-child&quot; test, which is used for css pseudoselectors like &#x60;nth-child&#x60;, &#x60;nth-of-type&#x60; etc.
    *
    * @method _matchNthChild
    * @param pseudoArg {String} the argument for nth-child
    * @param index {Number} the index of the inspected vnode
    * @return {Boolean} whether the vnode matches the nthChild test
    * @protected
    * @private
    * @since 0.0.1
    */
    _matchNthChild = function(pseudoArg, index) {
        var match, k, a, b, nodeOk, nthIndex, sign, isNumber;
        (pseudoArg===&#x27;even&#x27;) &amp;&amp; (pseudoArg=&#x27;2n&#x27;);
        (pseudoArg===&#x27;odd&#x27;) &amp;&amp; (pseudoArg=&#x27;2n+1&#x27;);

        match = pseudoArg.match(NTH_CHILD_REGEXP) || (isNumber=pseudoArg.validateNumber());
        if (!match) {
            return false;
        }
        // pseudoArg follows the pattern: &#x60;an+b&#x60;
        if (!isNumber) {
            a = match[1];
            sign = match[2];
            b = match[3] || 0;
            (b===&#x27;&#x27;) &amp;&amp; (b=0);
        }
        else {
            b = pseudoArg;
        }
        sign &amp;&amp; (sign=sign[0]);
        if (!a) {
            // only fixed index to match
            return (sign===&#x27;-&#x27;) ? false : (parseInt(b, 10)===index);
        }
        else {
            // we need to iterate
            nodeOk = false;
            b = window.Number(b);
            for (k=0; !nodeOk; k++) {
                nthIndex = (sign===&#x27;-&#x27;) ? (a*k) - b : (a*k) + b;
                if (nthIndex===index) {
                    nodeOk = true;
                }
                else if (nthIndex&gt;index) {
                    // beyond index --&gt; will never become a fix anymore
                    return false;
                }
            }
            return nodeOk;
        }
    };

   /**
    * Check whether the vnode matches the css-selector. the css-selector should be a single selector,
    * not multiple, so it shouldn&#x27;t contain a &#x60;comma&#x60;.
    *
    * @method _matchesOneSelector
    * @param vnode {vnode} the vnode to inspect
    * @param selector {String} the selector-item to check the match for
    * @param [relatedVNode] {vnode} a related vnode where to selectors starting with &#x60;&gt;&#x60;, &#x60;~&#x60; or &#x60;+&#x60; should be compared.
    *        If not specified, any of these three starting selector-characters will be ignored (leading to matching this first character).
    * @return {Boolean} whether the vnode matches the css-selector
    * @protected
    * @private
    * @since 0.0.1
    */
    _matchesOneSelector = function(vnode, selector, relatedVNode) {
        var selList = _splitSelector(selector),
            size = selList.length,
            originalVNode = vnode,
            firstSelectorChar = selector[0],
            i, selectorItem, selMatch, directMatch, vParentvChildren, indexRelated;

        if (size===0) {
            return false;
        }

        selectorItem = selList[size-1];
        selMatch = _matchesSelectorItem(vnode, selectorItem);
        for (i=size-2; (selMatch &amp;&amp; (i&gt;=0)); i--) {
            selectorItem = selList[i];
            if (SIBLING_MATCH_CHARACTER[selectorItem]) {
                // need to search through the same level
                if (--i&gt;=0) {
                    directMatch = (selectorItem===&#x27;+&#x27;);
                    selectorItem = selList[i];
                    // need to search the previous siblings
                    vnode = vnode.vPreviousElement;
                    if (!vnode) {
                        return false;
                    }
                    if (directMatch) {
                        // should be immediate match
                        selMatch = _matchesSelectorItem(vnode, selectorItem);
                    }
                    else {
                        while (vnode &amp;&amp; !(selMatch=_matchesSelectorItem(vnode, selectorItem))) {
                            vnode = vnode.vPreviousElement;
                        }
                    }
                }
            }
            else {
                // need to search up the tree
                vnode = vnode.vParent;
                if (!vnode || ((vnode===relatedVNode) &amp;&amp; (selectorItem!==&#x27;&gt;&#x27;))) {
                    return false;
                }
                if (selectorItem===&#x27;&gt;&#x27;) {
                    if (--i&gt;=0) {
                        selectorItem = selList[i];
                       // should be immediate match
                        selMatch = _matchesSelectorItem(vnode, selectorItem);
                    }
                }
                else {
                    while (!(selMatch=_matchesSelectorItem(vnode, selectorItem))) {
                        vnode = vnode.vParent;
                        if (!vnode || (vnode===relatedVNode)) {
                            return false;
                        }
                    }
                }
            }
        }
        if (selMatch &amp;&amp; relatedVNode &amp;&amp; STORABLE_SPLIT_CHARACTER[firstSelectorChar]) {
            // when &#x60;selector&#x60; starts with &#x60;&gt;&#x60;, &#x60;~&#x60; or &#x60;+&#x60;, then
            // there should also be a match comparing a related node!
            switch (firstSelectorChar) {
                case &#x27;&gt;&#x27;:
                    selMatch = (relatedVNode.vChildren.indexOf(originalVNode)!==-1);
                break;
                case &#x27;~&#x27;:
                    vParentvChildren = originalVNode.vParent.vChildren;
                    indexRelated = vParentvChildren.indexOf(relatedVNode);
                    selMatch = (indexRelated!==-1) &amp;&amp; (indexRelated&lt;vParentvChildren.indexOf(originalVNode));
                break;
                case &#x27;+&#x27;:
                    selMatch = (originalVNode.vPreviousElement === relatedVNode);
            }
        }
        return selMatch;
    };

   /**
    * Check whether the vnode matches one specific selector-item. Suppose the css-selector: &quot;#mynode li.red .blue&quot;
    * then there are 3 selector-items: &quot;#mynode&quot;,  &quot;li.red&quot; and &quot;.blue&quot;
    *
    * This method also can handle the new selectors:
    * &lt;ul&gt;
    *     &lt;li&gt;[att^=val] –-&gt; the “begins with” selector&lt;/li&gt;
    *     &lt;li&gt;[att$=val] –-&gt; the “ends with” selector&lt;/li&gt;
    *     &lt;li&gt;[att*=val] –-&gt; the “contains” selector (might be a substring)&lt;/li&gt;
    *     &lt;li&gt;[att~=val] –-&gt; the “contains” selector as a separate word, separated by spaces&lt;/li&gt;
    *     &lt;li&gt;[att|=val] –-&gt; the “contains” selector as a separate word, separated by &#x60;|&#x60;&lt;/li&gt;
    *     &lt;li&gt;+ --&gt; (same level)&lt;/li&gt;
    *     &lt;li&gt;~ --&gt; (same level)&lt;/li&gt;
    * &lt;/ul&gt;
    *
    * @method _matchesSelectorItem
    * @param vnode {Object} the vnode to inspect
    * @param selectorItem {String} the selector-item to check the match for
    * @return {Boolean} whether the vnode matches the selector-item
    * @protected
    * @private
    * @since 0.0.1
    */
    _matchesSelectorItem = function (vnode, selectorItem) {
        var i = 0,
            len = selectorItem.length,
            character = selectorItem[0],
            tagName, id, className, attributeName, attributeValue, stringMarker, attributeisString, isBoolean, insideAttributeValue, insideAttribute,
            vParent, checkBoolean, treatment, k, min, max, value, len2, index, found, pseudo, pseudoArg, arglevel, count, vParentVChildren;
        if (selectorItem===&#x27;*&#x27;) {
            return true;
        }
        if (!SELECTOR_IDENTIFIERS[character]) {
            // starts with tagName
            tagName = &#x27;&#x27;;
            // reposition i to continue in the right way:
            i--;
            while ((++i&lt;len) &amp;&amp; (character=selectorItem[i]) &amp;&amp; !SELECTOR_IDENTIFIERS[character]) {
                tagName += character;
            }
            if (tagName.toUpperCase()!==vnode.tag) {
                return false;
            }
        }
        while (i&lt;len) {
            switch (character) {
                case &#x27;#&#x27;:
                    id = &#x27;&#x27;;
                    while ((++i&lt;len) &amp;&amp; (character=selectorItem[i]) &amp;&amp; !SELECTOR_IDENTIFIERS[character]) {
                        id += character;
                    }
                    if (id!==vnode.id) {
                        return false;
                    }
                    break;
                case &#x27;.&#x27;:
                    className = &#x27;&#x27;;
                    while ((++i&lt;len) &amp;&amp; (character=selectorItem[i]) &amp;&amp; !SELECTOR_IDENTIFIERS[character]) {
                        className += character;
                    }

                    if (!vnode.hasClass(className)) {
                        return false;
                    }
                    break;
                case &#x27;[&#x27;:
                    attributeName = &#x27;&#x27;;
                    while ((++i&lt;len) &amp;&amp; (character=selectorItem[i]) &amp;&amp; !END_ATTRIBUTENAME[character]) {
                        attributeName += character;
                    }
                    // if character===&#x27;]&#x27; then we have an attribute without a value-definition
                    if (!vnode.attrs[attributeName] || ((character===&#x27;]&#x27;) &amp;&amp; (vnode.attrs[attributeName]!==&#x27;&#x27;))) {
                        return !!vnode.attrs[attributeName];
                    }
                    // now we read the value of the attribute
                    // however, it could be that the selector has a special &#x60;detailed&#x60; identifier set (defined by: ATTR_DETAIL_SPECIFIERS)
                    if (ATTR_DETAIL_SPECIFIERS[character]) {
                        treatment = character; // store the character to know how the attributedata should be treaded
                        i++; // character should be a &quot;=&quot; by now
                    }
                    else {
                        treatment = null;
                    }
                    attributeValue = &#x27;&#x27;;
                    stringMarker = selectorItem[i+1];
                    attributeisString = (stringMarker===&#x27;&quot;&#x27;) || (stringMarker===&quot;&#x27;&quot;);
                    attributeisString &amp;&amp; (i++);

                    // end of attributaValue = (character===&#x27;]&#x27;) &amp;&amp; (!attributeisString || (selectorItem[i-1]===stringMarker))
                    while ((++i&lt;len) &amp;&amp; (character=selectorItem[i]) &amp;&amp; !((character===&#x27;]&#x27;) &amp;&amp; (!attributeisString || (selectorItem[i-1]===stringMarker)))) {
                        attributeValue += character;
                    }

                    if (attributeisString) {
                        // if attribute is string, then we need to _remove to last stringmarker
                        attributeValue = attributeValue.substr(0, attributeValue.length-1);
                    }
                    else {
                        // if attribute is no string, then we need to typecast its value
                        isBoolean = ((attributeValue.length&gt;3) &amp;&amp; (attributeValue.length&lt;6) &amp;&amp;
                                     (checkBoolean=attributeValue.toUpperCase()) &amp;&amp;
                                     ((checkBoolean===&#x27;FALSE&#x27;) || (checkBoolean===&#x27;TRUE&#x27;)));
                        // typecast the value to either Boolean or Number:
                        attributeValue = isBoolean ? (checkBoolean===&#x27;TRUE&#x27;) : parseFloat(attributeValue);
                    }

                    // depending upon how the attributedata should be treated:
                    if (treatment) {
                        switch (treatment) {
                            case &#x27;^&#x27;: // “begins with” selector
                                if (!vnode.attrs[attributeName].startsWith(attributeValue)) {
                                    return false;
                                }
                                break;
                            case &#x27;$&#x27;: // “ends with” selector
                                if (!vnode.attrs[attributeName].endsWith(attributeValue)) {
                                    return false;
                                }
                                break;
                            case &#x27;*&#x27;: // “contains” selector (might be a substring)
                                if (!vnode.attrs[attributeName].contains(attributeValue)) {
                                    return false;
                                }
                                break;
                            case &#x27;~&#x27;: // “contains” selector as a separate word, separated by spaces
                                if (!(&#x27; &#x27;+vnode.attrs[attributeName]+&#x27; &#x27;).contains(&#x27; &#x27;+attributeValue+&#x27; &#x27;)) {
                                    return false;
                                }
                                break;
                            case &#x27;|&#x27;: // “contains” selector as a separate word, separated by &#x60;|&#x60;
                                if (!(&#x27;|&#x27;+vnode.attrs[attributeName]+&#x27;|&#x27;).contains(&#x27;|&#x27;+attributeValue+&#x27;|&#x27;)) {
                                    return false;
                                }
                                break;
                        }
                    }
                    else if (vnode.attrs[attributeName]!==attributeValue) {
                        return false;
                    }

                    // we still need to increase one position:
                    (++i&lt;len) &amp;&amp; (character=selectorItem[i]);
                    break;
                case &#x27;:&#x27;:
                    // we have a pseudo-selector
                    // first, find out which one
                    // because &#x27;::&#x27; is a valid start (though without any selection), we start to back the next character as well:
                    pseudo = &#x27;:&#x27;+selectorItem[++i];
                    pseudoArg = &#x27;&#x27;;
                    vParent = vnode.vParent;
                    vParentVChildren = vParent &amp;&amp; vParent.vChildren;
                    // pseudo-selectors might have an argument passed in, like &#x60;:nth-child(2n+1)&#x60; or &#x60;:not([type=&quot;checkbox&quot;])&#x60; --&gt; we
                    // store this argument inside &#x60;pseudoArg&#x60;
                    // also note that combinations are possible with &#x60;:not&#x60; --&gt; &#x60;:not(:nth-child(2n+1))&#x60;
                    // also note that we cannot &quot;just&quot; look for a closing character when running into the usage of attributes:
                    // for example --&gt; &#x60;:not([data-x=&quot;some data :)&quot;])&#x60;
                    // that&#x27;s why -once we are inside attribute-data- we need to continue until the attribute-data ends
                    while ((++i&lt;len) &amp;&amp; (character=selectorItem[i]) &amp;&amp; !SELECTOR_IDENTIFIERS[character]) {
                        if (character===&#x27;(&#x27;) {
                            // starting arguments
                            arglevel = 1;
                            insideAttribute = false;
                            insideAttributeValue = false;
                            while ((++i&lt;len) &amp;&amp; (character=selectorItem[i]) &amp;&amp; (arglevel&gt;0)) {
                                if (!insideAttribute) {
                                    if (character===&#x27;(&#x27;) {
                                        arglevel++;
                                    }
                                    else if (character===&#x27;)&#x27;) {
                                        arglevel--;
                                    }
                                    else if (character===&#x27;[&#x27;) {
                                        insideAttribute = true;
                                    }
                                }
                                else {
                                    // inside attribute
                                    if (!insideAttributeValue) {
                                        if ((character===&#x27;&quot;&#x27;) || (character===&quot;&#x27;&quot;)) {
                                            insideAttributeValue = true;
                                            stringMarker = character;
                                        }
                                        else if (character===&#x27;]&#x27;) {
                                            insideAttribute = false;
                                        }
                                    }
                                    else if ((character===stringMarker) &amp;&amp; (selectorItem[i+1]===&#x27;]&#x27;)) {
                                        insideAttributeValue = false;
                                    }
                                }
                                (arglevel&gt;0) &amp;&amp; (pseudoArg+=character);
                            }
                        }
                        else {
                            pseudo += character;
                        }
                    }
                    // now, &#x60;pseudo&#x60; is known as well as its possible pseudoArg
                    if (!vParentVChildren &amp;&amp; PSEUDO_REQUIRED_CHILDREN[pseudo]) {
                        return false;
                    }
                    switch (pseudo) {
                        case &#x27;:checked&#x27;: // input:checked   Selects every checked &lt;input&gt; element
                            if (!vnode.attrs.checked) {
                                return false;
                            }
                            break;
                        case &#x27;:disabled&#x27;: // input:disabled  Selects every disabled &lt;input&gt; element
                            if (!vnode.attrs.disabled) {
                                return false;
                            }
                            break;
                        case &#x27;:empty&#x27;: // p:empty Selects every &lt;p&gt; element that has no children (including text nodes)
                            if (vnode.vChildNodes &amp;&amp; (vnode.vChildNodes.length&gt;0)) {
                                return false;
                            }
                            break;
                        case &#x27;:enabled&#x27;: // input:enabled   Selects every enabled &lt;input&gt; element
                            if (vnode.attrs.disabled) {
                                return false;
                            }
                            break;
                        case PSEUDO_FIRST_CHILD: // p:first-child   Selects every &lt;p&gt; element that is the first child of its parent
                            if (vParentVChildren[0]!==vnode) {
                                return false;
                            }
                            break;
                        case PSEUDO_FIRST_OF_TYPE: // p:first-of-type Selects every &lt;p&gt; element that is the first &lt;p&gt; element of its parent
                            for (k=vParentVChildren.indexOf(vnode)-1; k&gt;=0; k--) {
                                if (vParentVChildren[k].tag===vnode.tag) {
                                    return false;
                                }
                            }
                            break;
                        case &#x27;:focus&#x27;: // input:focus Selects the input element which has focus
                            if (vnode.domNode!==DOCUMENT.activeElement) {
                                return false;
                            }
                            break;
                        case &#x27;:in-range&#x27;: // input:in-range  Selects input elements with a value within a specified range
                            if ((vnode.tag!==&#x27;INPUT&#x27;) || ((vnode.attrs.type || &#x27;&#x27;).toLowerCase()!==&#x27;number&#x27;)) {
                                return false;
                            }
                            min = parseInt(vnode.attrs.min, 10);
                            max = parseInt(vnode.attrs.max, 10);
                            value = parseInt(vnode.domNode.value, 10);
                            if (!value || !min || !max || (value&lt;min) || (value&gt;max)) {
                                return false;
                            }
                            break;
                        case &#x27;:lang&#x27;: // p:lang(it)  Selects every &lt;p&gt; element with a lang attribute equal to &quot;it&quot; (Italian)
                            if (vnode.attrs.lang!==pseudoArg) {
                                return false;
                            }
                            break;
                        case PSEUDO_LAST_CHILD: // p:last-child    Selects every &lt;p&gt; element that is the last child of its parent
                            if (vParentVChildren[vParentVChildren.length-1]!==vnode) {
                                return false;
                            }
                            break;
                        case PSEUDO_LAST_OF_TYPE: // p:last-of-type  Selects every &lt;p&gt; element that is the last &lt;p&gt; element of its parent
                            len2 = vParentVChildren.length;
                            for (k=vParentVChildren.indexOf(vnode)+1; k&lt;len2; k++) {
                                if (vParentVChildren[k].tag===vnode.tag) {
                                    return false;
                                }
                            }
                            break;
                        case &#x27;:not&#x27;: // :not(p) Selects every element that is not a &lt;p&gt; element
                            if (vnode.matchesSelector(pseudoArg)) {
                                return false;
                            }
                            break;
                        case PSEUDO_NTH_CHILD: // p:nth-child(2)  Selects every &lt;p&gt; element that is the second child of its parent
                            // NOTE: css &#x60;nth&#x60; starts with 1 instead of 0 !!!
                            index = vParentVChildren.indexOf(vnode)+1;
                            if (!_matchNthChild(pseudoArg, index)) {
                                return false;
                            }
                            break;
                        case PSEUDO_NTH_LAST_CHILD: // p:nth-last-child(2) Selects every &lt;p&gt; element that is the second child of its parent, counting from the last child
                            // NOTE: css &#x60;nth&#x60; starts with 1 instead of 0 !!!
                            // Also, nth-last-child counts from bottom up
                            index = vParentVChildren.length - vParentVChildren.indexOf(vnode);
                            if (!_matchNthChild(pseudoArg, index)) {
                                return false;
                            }
                            break;
                        case PSEUDO_NTH_LAST_OF_TYPE: // p:nth-last-of-type(2)   Selects every &lt;p&gt; element that is the second &lt;p&gt; element of its parent, counting from the last child
                            // NOTE: css &#x60;nth&#x60; starts with 1 instead of 0 !!!
                            // Also, nth-last-child counts from bottom up
                            index = vParentVChildren.length - vParentVChildren.indexOf(vnode);
                            // NOTE: css &#x60;nth&#x60; starts with 1 instead of 0 !!!
                            found = false;
                            index = 0;
                            for (k=vParentVChildren.length-1; (k&gt;=0) &amp;&amp; !found; k--) {
                                (vParentVChildren[k].tag===vnode.tag) &amp;&amp; index++;
                                (vParentVChildren[k]===vnode) &amp;&amp; (found=true);
                            }
                            if (!found || !_matchNthChild(pseudoArg, index)) {
                                return false;
                            }
                            break;
                        case PSEUDO_NTH_OF_TYPE: // p:nth-of-type(2)    Selects every &lt;p&gt; element that is the second &lt;p&gt; element of its parent
                            // NOTE: css &#x60;nth&#x60; starts with 1 instead of 0 !!!
                            found = false;
                            len2 = vParentVChildren.length;
                            index = 0;
                            for (k=0; (k&lt;len2) &amp;&amp; !found; k++) {
                                (vParentVChildren[k].tag===vnode.tag) &amp;&amp; index++;
                                (vParentVChildren[k]===vnode) &amp;&amp; (found=true);
                            }
                            if (!found || !_matchNthChild(pseudoArg, index)) {
                                return false;
                            }
                            break;
                        case PSEUDO_ONLY_OF_TYPE: // p:only-of-type  Selects every &lt;p&gt; element that is the only &lt;p&gt; element of its parent
                            len2 = vParentVChildren.length;
                            count = 0;
                            for (k=0; (k&lt;len2) &amp;&amp; (count&lt;=1); k++) {
                                (vParentVChildren[k].tag===vnode.tag) &amp;&amp; count++;
                            }
                            if (count!==1) {
                                return false;
                            }
                            break;
                        case PSEUDO_ONLY_CHILD: // p:only-child    Selects every &lt;p&gt; element that is the only child of its parent
                            if (vParentVChildren.length!==1) {
                                return false;
                            }
                            break;
                        case &#x27;:optional&#x27;: // input:optional  Selects input elements with no &quot;required&quot; attribute
                            if (vnode.attrs.required) {
                                return false;
                            }
                            break;
                        case &#x27;:out-of-range&#x27;: // input:out-of-range  Selects input elements with a value outside a specified range
                            if ((vnode.tag!==&#x27;INPUT&#x27;) || ((vnode.attrs.type || &#x27;&#x27;).toLowerCase()!==&#x27;number&#x27;)) {
                                return false;
                            }
                            min = parseInt(vnode.attrs.min, 10);
                            max = parseInt(vnode.attrs.max, 10);
                            value = parseInt(vnode.domNode.value, 10);
                            if (!value || !min || !max || ((value&gt;=min) &amp;&amp; (value&lt;=max))) {
                                return false;
                            }
                            break;
                        case &#x27;:read-only&#x27;: // input:read-only Selects input elements with the &quot;readonly&quot; attribute specified
                            if (!vnode.attrs.readonly) {
                                return false;
                            }
                            break;
                        case &#x27;:read-write&#x27;: // input:read-write    Selects input elements with the &quot;readonly&quot; attribute NOT specified
                            if (vnode.attrs.readonly) {
                                return false;
                            }
                            break;
                        case &#x27;:required&#x27;: // input:required  Selects input elements with the &quot;required&quot; attribute specified
                            if (!vnode.attrs.required) {
                                return false;
                            }
                            break;
                        case &#x27;:root&#x27;: // Selects the document&#x27;s root element
                            if (vnode.domNode!==DOCUMENT.documentElement) {
                                return false;
                            }
                            break;
                    }
            }
        }
        return true;
    };

    /**
     * Splits the selector into separate subselector-items that should match different elements through the tree.
     * Special characters &#x27;&gt;&#x27; and &#x27;+&#x27; are added as separate items in the hash.
     *
     * @method _splitSelector
     * @param selector {String} the selector-item to check the match for
     * @return {Array} splitted selectors
     * @protected
     * @private
     * @since 0.0.1
     */
    _splitSelector = function(selector) {
        var list = [],
            len = selector.length,
            sel = &#x27;&#x27;,
            i, character, insideDataAttr;

        for (i=0; i&lt;len; i++) {
            character = selector[i];
            if (character===&#x27;[&#x27;) {
                sel += character;
                insideDataAttr = true;
            }
            else if (character===&#x27;]&#x27;) {
                sel += character;
                insideDataAttr = false;
            }
            else if (insideDataAttr || !SPLIT_CHARACTER[character]) {
                sel += character;
            }
            else {
                // unique selectoritem is found, add it to the list
                if (sel.length&gt;0) {
                    list[list.length] = sel;
                    sel = &#x27;&#x27;;
                }
                // in case the last character was &#x27;&gt;&#x27;, &#x27;+&#x27; or &#x27;~&#x27;, we need to add it as a separate item
                STORABLE_SPLIT_CHARACTER[character] &amp;&amp; (list[list.length]=character);
            }
        }
        // add the last item
        if (sel.length&gt;0) {
            list[list.length] = sel;
            sel = &#x27;&#x27;;
        }
        return list;
    };

    _batchEmit = function() {
        MUTATION_EVENTS.each(function (mutationEvents, vnode) {
            var domNode = vnode.domNode;
            if (mutationEvents[EV_REMOVED]) {
                domNode.emit(EV_REMOVED);
            }
            else if (mutationEvents[EV_INSERTED]) {
                domNode.emit(EV_INSERTED);
            }
            else {
                // contentchange and attributechanges can go hand in hand
                mutationEvents.each(function(value, evt) {
                    domNode.emit(evt, (evt===EV_CONTENT_CHANGE) ? null : {changed: value});
                });
            }
        });
        MUTATION_EVENTS.clear();
        BATCH_WILL_RUN = false;
    };

    _emitDestroyChildren = function(vnode) {
        var children = vnode.vChildren,
            len = children.length,
            i, vChild;
        for (i=0; i&lt;len; i++) {
            vChild = children[i];
            vChild._emit(EV_REMOVED);
            _emitDestroyChildren(vChild);
        }
    };

    _markRemoved = function(vnode) {
        var vChildNodes = vnode.vChildNodes,
            len, i, vChildNode;
        if (vnode.nodeType===1) {
            Object.protectedProp(vnode, &#x27;removedFromDOM&#x27;, true);
            if (vChildNodes) {
                len = vChildNodes.length;
                for (i=0; i &lt; len; i++) {
                    vChildNode = vChildNodes[i];
                    vChildNode &amp;&amp; _markRemoved(vChildNode);
                }
            }
        }
    };

    vNodeProto = window._ITSAmodules.VNode = {
       /**
        * Check whether the vnode&#x27;s domNode is equal, or contains the specified Element.
        *
        * @method contains
        * @return {Boolean} whether the vnode&#x27;s domNode is equal, or contains the specified Element.
        * @since 0.0.1
        */
        contains: function(otherVNode) {
            if (this.vnode.destroyed) {
                return false;
            }
            while (otherVNode &amp;&amp; (otherVNode!==this)) {
                otherVNode = otherVNode.vParent;
            }
            return (otherVNode===this);
        },

        empty: function() {
            this._setChildNodes([]);
        },

       /**
        * Returns the first child-vnode (if any). The child represents an Element (nodeType===1).
        *
        * @method firstOfVChildren
        * @param cssSelector {String} one or more css-selectors
        * @return {Object|null} the first child-vnode or null when not present
        * @since 0.0.1
        */
        firstOfVChildren: function(cssSelector) {
            var instance = this,
                found, i, len, vChildren, element;
            if (!cssSelector) {
                return instance.vFirstElementChild;
            }
            vChildren = instance.vChildren;
            len = vChildren.length;
            for (i=0; !found &amp;&amp; (i&lt;len); i++) {
                element = vChildren[i];
                element.matchesSelector(cssSelector) &amp;&amp; (found=element);
            }
            return found;
        },

       /**
        * Checks whether the vnode has any vChildNodes (nodeType of 1, 3 or 8).
        *
        * @method hasVChildNodes
        * @return {Boolean} whether the vnode has any vChildNodes.
        * @since 0.0.1
        */
        hasVChildNodes: function() {
            return this.vChildNodes ? (this.vChildNodes.length&gt;0) : false;
        },

       /**
        * Checks whether the vnode has any vChildren (vChildNodes with nodeType of 1).
        *
        * @method hasVChildren
        * @return {Boolean} whether the vnode has any vChildren.
        * @since 0.0.1
        */
        hasVChildren: function() {
            return this.vChildNodes ? (this.vChildren.length&gt;0) : false;
        },

       /**
        * Checks whether the className is present on the vnode.
        *
        * @method hasClass
        * @param className {String|Array} the className to check for. May be an Array of classNames, which all needs to be present.
        * @return {Boolean} whether the className (or classNames) is present on the vnode
        * @since 0.0.1
        */
        hasClass: function(className) {
            var instance = this,
                check = function(cl) {
                    return !!instance.classNames[cl];
                };
            if (!instance.classNames) {
                return false;
            }
            if (typeof className === STRING) {
                return check(className);
            }
            else if (Array.isArray(className)) {
                return className.every(check);
            }
            return false;
        },

       /**
        * Returns the last child-vnode (if any). The child represents an Element (nodeType===1).
        *
        * @method lastOfVChildren
        * @param cssSelector {String} one or more css-selectors
        * @return {Object|null} the last child-vnode or null when not present
        * @since 0.0.1
        */
        lastOfVChildren: function(cssSelector) {
            var vChildren = this.vChildren,
                found, i, element;
            if (vChildren) {
                if (!cssSelector) {
                    return this.vLastElementChild;
                }
                for (i=vChildren.length-1; !found &amp;&amp; (i&gt;=0); i--) {
                    element = vChildren[i];
                    element.matchesSelector(cssSelector) &amp;&amp; (found=element);
                }
            }
            return found;
        },

       /**
        * Checks whether the vnode matches one of the specified selectors. &#x60;selectors&#x60; can be one, or multiple css-selectors,
        * separated by a &#x60;comma&#x60;. For example: &quot;#myid li.red blue&quot; is one selector, &quot;div.red, div.blue, div.green&quot; are three selectors.
        *
        * @method matchesSelector
        * @param selectors {String} one or more css-selectors
        * @param [relatedVNode] {vnode} a related vnode where to selectors starting with &#x60;&gt;&#x60;, &#x60;~&#x60; or &#x60;+&#x60; should be compared.
        *        If not specified, any of these three starting selector-characters will be ignored (leading to matching this first character).
        * @return {Boolean} whether the vnode matches one of the selectors
        * @since 0.0.1
        */
        matchesSelector: function(selectors, relatedVNode) {
            var instance = this;
            if (instance.nodeType!==1) {
                return false;
            }
            selectors = selectors.split(&#x27;,&#x27;);
            // we can use Array.some, because there won&#x27;t be many separated selectoritems,
            // so the final invocation won&#x27;t be delayed much compared to looping
            return selectors.some(function(selector) {
                return _matchesOneSelector(instance, selector, relatedVNode);
            });
        },

       /**
        * Reloads the DOM-attribute into the vnode.
        *
        * @method matchesSelector
        * @param attributeName {String} the name of the attribute to be reloaded.
        * @return {Node} the domNode that was reloaded.
        * @since 0.0.1
        */
        reloadAttr: function(attributeName) {
            var instance = this,
                domNode = instance.domNode,
                attributeValue = domNode._getAttribute(attributeName),
                attrs = instance.attrs,
                extractStyle, extractClass;
            if (instance.nodeType===1) {
                attributeValue || (attributeValue=&#x27;&#x27;);
                if (attributeValue===&#x27;&#x27;) {
                    delete attrs[attributeName];
                    // in case of STYLE attributeName --&gt; special treatment
                    (attributeName===STYLE) &amp;&amp; (instance.styles={});
                    // in case of CLASS attributeName --&gt; special treatment
                    (attributeName===CLASS) &amp;&amp; (instance.classNames={});
                    // in case of ID attributeName --&gt; special treatment
                    if ((attributeName===ID) &amp;&amp; (instance.id)) {
                        delete nodeids[instance.id];
                        delete instance.id;
                    }
                }
                else {
                    attrs[attributeName] = attributeValue;
                    // in case of STYLE attributeName --&gt; special treatment
                    if (attributeName===STYLE) {
                        extractStyle = extractor.extractStyle(attributeValue);
                        attributeValue = extractStyle.attrStyle;
                        if (attributeValue) {
                            attrs.style = attributeValue;
                        }
                        else {
                            delete attrs.style;
                        }
                        instance.styles = extractStyle.styles;
                    }
                    else if (attributeName===CLASS) {
                        // in case of CLASS attributeName --&gt; special treatment
                        extractClass = extractor.extractClass(attributeValue);
                        attributeValue = extractClass.attrClass;
                        if (attributeValue) {
                            attrs[CLASS] = attributeValue;
                        }
                        else {
                            delete attrs[CLASS];
                        }
                        instance.classNames = extractClass.classNames;
                    }
                    else if (attributeName===ID) {
                        instance.id &amp;&amp; (instance.id!==attributeValue) &amp;&amp; (delete nodeids[instance.id]);
                        instance.id = attributeValue;
                        nodeids[attributeValue] = domNode;
                    }
                }
            }
            return domNode;
        },

        serializeStyles: function() {
            return extractor.serializeStyles(this.styles);
        },

       /**
        * Syncs the vnode&#x27;s nodeid (if available) inside &#x60;NS-vdom.nodeids&#x60;.
        *
        * Does NOT sync with the dom. Can be invoked multiple times without issues.
        *
        * @method storeId
        * @chainable
        * @since 0.0.1
        */
        storeId: function() {
            // store node/vnode inside WeakMap:
            var instance = this;
            instance.id ? (nodeids[instance.id]=instance.domNode) : (delete nodeids[instance.id]);
            return instance;
        },

        //---- private ------------------------------------------------------------------

        /**
         * Adds a vnode to the end of the list of vChildNodes.
         *
         * Syncs with the DOM.
         *
         * @method _appendChild
         * @param VNode {vnode} vnode to append
         * @private
         * @return {Node} the Node that was appended
         * @since 0.0.1
         */
        _appendChild: function(VNode) {
            var instance = this,
                domNode = VNode.domNode,
                size;
            VNode._moveToParent(instance);
            instance.domNode._appendChild(domNode);
            if (VNode.nodeType===3) {
                size = instance.vChildNodes.length;
                instance._normalize();
                // if the size changed, then the domNode was merged
                (size===instance.vChildNodes.length) || (domNode=instance.vChildNodes[instance.vChildNodes.length-1].domNode);
            }
            VNode._emit(EV_INSERTED);
            return domNode;
        },

       /**
        * Removes the vnode from its parent vChildNodes- and vChildren-list.
        *
        * Does NOT sync with the dom.
        *
        * @method _deleteFromParent
        * @private
        * @chainable
        * @since 0.0.1
        */
        _deleteFromParent: function() {
            var instance = this,
                vParent = instance.vParent;
            if (vParent &amp;&amp; vParent.vChildNodes) {
                vParent.vChildNodes.remove(instance);
                // force to recalculate the vChildren on a next call:
                (instance.nodeType===1) &amp;&amp; (vParent._vChildren=null);
            }
            return instance;
        },

        _cleanData: function() {
            var instance = this,
                data = instance._data;
            data &amp;&amp; data.each(
                function(value, key) {
                    delete data[key];
                }
            );
            return instance;
        },

       /**
        * Destroys the vnode and all its vnode-vChildNodes.
        * Removes it from its vParent.vChildNodes list,
        * also removes its definitions inside &#x60;NS-vdom.nodeids&#x60;.
        *
        * Does NOT sync with the dom.
        *
        * @method _destroy
        * @private
        * @chainable
        * @since 0.0.1
        */
        _destroy: function(silent) {
            var instance = this,
                vChildNodes = instance.vChildNodes,
                len, i, vChildNode, vParent, treeNodes;
            if (!instance.destroyed) {
                silent || instance._emit(EV_REMOVED);
                Object.protectedProp(instance, &#x27;destroyed&#x27;, true);

                // first: determine the dom-tree, which module &#x60;event-dom&#x60; needs to determine where the node was before it was destroyed:
                treeNodes = [instance];
                vParent = instance.vParent;
                while (vParent) {
                    treeNodes[treeNodes.length] = vParent;
                    vParent = vParent.vParent;
                }

                // mark all its vChildNodes so we can see if the node is in the DOM
                _markRemoved(instance);

                // The definite cleanup needs to be done after a timeout:
                // someone might need to handle the Element when removed (fe to cleanup specific things)
                later(function() {
                    instance._cleanData();
                    // _destroy all its vChildNodes
                    if ((instance.nodeType===1) &amp;&amp; vChildNodes) {
                        len = vChildNodes.length;
                        for (i=0; i &lt; len; i++) {
                            vChildNode = vChildNodes[i];
                            vChildNode &amp;&amp; vChildNode._destroy(true);
                        }
                    }
                    instance._vChildren = null;
                    // explicitely set instance.domNode._vnode and instance.domNode to null in order to prevent problems with the GC (we break the circular reference)
                    delete instance.domNode._vnode;
                    // if valid id, then _remove the DOMnodeRef from internal hash
                    instance.id &amp;&amp; delete nodeids[instance.id];
                }, silent ? 0 : DESTROY_DELAY);

                instance._deleteFromParent();
                // Do not make domNode &#x60;null&#x60; --&gt; it could be used even when not in the dom
            }
            return instance;
        },

        _emit: function(evt, attribute, newValue, prevValue) {
           /**
            * Emitted by every Element that gets inserted.
            *
            * @event nodeinsert
            * @param e {Object} eventobject including:
            * @param e.target {HtmlElement} the HtmlElement that is being dragged
            * @param e.currentTarget {HtmlElement} the HtmlElement that is delegating
            * @since 0.1
            */

           /**
            * Emitted by every Element that gets removed.
            *
            * @event noderemove
            * @param e {Object} eventobject including:
            * @param e.target {HtmlElement} the HtmlElement that is being dragged
            * @param e.currentTarget {HtmlElement} the HtmlElement that is delegating
            * @since 0.1
            */

           /**
            * Emitted by every Element that gets its content changed (innerHTML/innerText).
            *
            * @event nodecontentchange
            * @param e {Object} eventobject including:
            * @param e.target {HtmlElement} the HtmlElement that is being dragged
            * @param e.currentTarget {HtmlElement} the HtmlElement that is delegating
            * @since 0.1
            */

           /**
            * Emitted by every Element that gets an attribute inserted.
            *
            * @event attributeinsert
            * @param e {Object} eventobject including:
            * @param e.target {HtmlElement} the HtmlElement that is being dragged
            * @param e.currentTarget {HtmlElement} the HtmlElement that is delegating
            * @param e.changed {Array} Array with Objects having three properties:
            * &lt;ul&gt;
            *     &lt;li&gt;attribute&lt;/li&gt;
            *     &lt;li&gt;newValue&lt;/li&gt;
            * &lt;/ul&gt;
            * @since 0.1
            */

           /**
            * Emitted by every Element that gets an attribute removed.
            *
            * @event attributeremove
            * @param e {Object} eventobject including:
            * @param e.target {HtmlElement} the HtmlElement that is being dragged
            * @param e.currentTarget {HtmlElement} the HtmlElement that is delegating
            * @param e.changed {Array} Array with Strings of the attributeNames that are removed
            * @since 0.1
            */

           /**
            * Emitted by every Element that gets an attribute changed.
            *
            * @event attributechange
            * @param e {Object} eventobject including:
            * @param e.target {HtmlElement} the HtmlElement that is being dragged
            * @param e.currentTarget {HtmlElement} the HtmlElement that is delegating
            * @param e.changed {Array} Array with Objects having three properties:
            * &lt;ul&gt;
            *     &lt;li&gt;attribute&lt;/li&gt;
            *     &lt;li&gt;newValue&lt;/li&gt;
            *     &lt;li&gt;prevValue&lt;/li&gt;
            * &lt;/ul&gt;
            * @since 0.1
            */

            var instance = this,
                silent, attrMutations, mutationEvents, mutation, vParent;
            if (!DOCUMENT.hasMutationSubs || (instance.nodeType!==1)) {
                return;
            }
            silent = !!DOCUMENT._suppressMutationEvents;
            if (!silent &amp;&amp; !instance.destroyed) {
                mutationEvents = MUTATION_EVENTS.get(instance) || {};
                if (attribute) {
                    attrMutations = mutationEvents[evt] || [];
                    if (evt===EV_ATTRIBUTE_REMOVED) {
                        mutation = attribute;
                    }
                    else {
                        mutation = {
                            attribute: attribute
                        };
                        if ((evt===EV_ATTRIBUTE_INSERTED) || (evt===EV_ATTRIBUTE_CHANGED)) {
                            mutation.newValue = newValue;
                        }
                        if ((evt===EV_ATTRIBUTE_CHANGED) &amp;&amp; prevValue) {
                            mutation.prevValue = prevValue;
                        }
                    }
                    attrMutations.push(mutation);
                    mutationEvents[evt] = attrMutations;
                }
                else {
                    mutationEvents[evt] = true;
                }
                MUTATION_EVENTS.set(instance, mutationEvents);
                // now set all parent to have a nodecontentchange:
                vParent = instance;
/*jshint boss:true */
                while (vParent=vParent.vParent) {
/*jshint boss:false */
                    vParent._emit(EV_CONTENT_CHANGE);
                }

                // in case of removal we need to emit EV_REMOVED for all children right now
                // for they will be actually removed silently after a delay of 1 minute
                (evt===EV_REMOVED) &amp;&amp; _emitDestroyChildren(instance);

                if (!BATCH_WILL_RUN) {
                    BATCH_WILL_RUN = true;
                    async(function() {
                        _batchEmit();
                    });
                }
            }
            return instance;
        },

        /**
         * Inserts &#x60;newVNode&#x60; before &#x60;refVNode&#x60;.
         *
         * Syncs with the DOM.
         *
         * @method _insertBefore
         * @param newVNode {vnode} vnode to insert
         * @param refVNode {vnode} The vnode before which newVNode should be inserted.
         * @private
         * @return {Node} the Node being inserted (equals domNode)
         * @since 0.0.1
         */
        _insertBefore: function(newVNode, refVNode) {
            var instance = this,
                domNode = newVNode.domNode,
                index = instance.vChildNodes.indexOf(refVNode);
            if (index!==-1) {
                newVNode._moveToParent(instance, index);
                instance.domNode._insertBefore(domNode, refVNode.domNode);
                (newVNode.nodeType===3) &amp;&amp; instance._normalize();
                newVNode._emit(EV_INSERTED);
            }
            return domNode;
        },

       /**
        * Moves the vnode from its current parent.vChildNodes list towards a new parent vnode at the specified position.
        *
        * Does NOT sync with the dom.
        *
        * @method _moveToParent
        * @param parentVNode {vnode} the parent-vnode
        * @param [index] {Number} the position of the child. When not specified, it will be appended.
        * @private
        * @chainable
        * @since 0.0.1
        */
        _moveToParent: function(parentVNode, index) {
            var instance = this,
                vParent = instance.vParent;
            instance._deleteFromParent();
            instance.vParent = parentVNode;
            parentVNode.vChildNodes || (parentVNode.vChildNodes=[]);
            (typeof index===&#x27;number&#x27;) ? parentVNode.vChildNodes.insertAt(instance, index) : (parentVNode.vChildNodes[parentVNode.vChildNodes.length]=instance);
            // force to recalculate the vChildren on a next call:
            vParent &amp;&amp; (instance.nodeType===1) &amp;&amp; (vParent._vChildren = null);
            // force to recalculate the vChildren on a next call:
            parentVNode &amp;&amp; (instance.nodeType===1) &amp;&amp; (parentVNode._vChildren=null);
            return instance;
        },

       /**
        * Removes empty TextNodes and merges following TextNodes inside the vnode.
        *
        * Syncs with the dom.
        *
        * @method _normalize
        * @private
        * @chainable
        * @since 0.0.1
        */
        _normalize: function() {
            var instance = this,
                domNode = instance.domNode,
                vChildNodes = instance.vChildNodes,
                changed = false,
                i, preChildNode, vChildNode;
            if (!instance._unNormalizable &amp;&amp; vChildNodes) {
                for (i=vChildNodes.length-1; i&gt;=0; i--) {
                    vChildNode = vChildNodes[i];
                    preChildNode = vChildNodes[i-1]; // i will get the value &#x60;-1&#x60; eventually, which leads into undefined preChildNode
                    if (vChildNode.nodeType===3) {
                        if (vChildNode.text===&#x27;&#x27;) {
                            domNode._removeChild(vChildNode.domNode);
                            vChildNode._destroy();
                            changed = true;
                        }
                        else if (preChildNode &amp;&amp; preChildNode.nodeType===3) {
                            preChildNode.text += vChildNode.text;
                            preChildNode.domNode.nodeValue = preChildNode.text;
                            domNode._removeChild(vChildNode.domNode);
                            vChildNode._destroy();
                            changed = true;
                        }
                    }
                }
            }
            changed &amp;&amp; instance._emit(EV_CONTENT_CHANGE);
            return instance;
        },

       /**
        * Makes the vnode &#x60;normalizable&#x60;. Could be set to &#x60;false&#x60; when batch-inserting nodes, while &#x60;normalizaing&#x60; manually at the end.
        * Afterwards, you should always reset &#x60;normalizable&#x60; to true.
        *
        * @method _normalizable
        * @param value {Boolean} whether the vnode should be normalisable.
        * @private
        * @chainable
        * @since 0.0.1
        */
        _normalizable: function(value) {
            var instance = this;
            value ? (delete instance._unNormalizable) : (instance._unNormalizable=true);
            return instance;
        },

       /**
        * Prevents MutationObserver from making the dom sync with the vnode.
        * Should be used when manipulating the dom from within the vnode itself (to preventing looping)
        *
        * @method _noSync
        * @chainable
        * @private
        * @since 0.0.1
        */
        _noSync: function() {
            var instance = this;
            if (!instance._nosync) {
                instance._nosync = true;
                async(function() {
                    instance._nosync = false;
                });
            }
            return instance;
        },

       /**
        * Removes the attribute of both the vnode as well as its related dom-node.
        *
        * Syncs with the dom.
        *
        * @method _removeAttr
        * @param attributeName {String}
        * @private
        * @chainable
        * @since 0.0.1
        */
        _removeAttr: function(attributeName) {
            var instance = this;
            if (instance.attrs[attributeName]!==undefined) {
                delete instance.attrs[attributeName];
                // in case of STYLE attribute --&gt; special treatment
                (attributeName===STYLE) &amp;&amp; (instance.styles={});
                // in case of CLASS attribute --&gt; special treatment
                (attributeName===CLASS) &amp;&amp; (instance.classNames={});
                if (attributeName===ID) {
                    delete nodeids[instance.id];
                    delete instance.id;
                }
                instance.domNode._removeAttribute(attributeName);
                instance._emit(EV_ATTRIBUTE_REMOVED, attributeName);
            }
            return instance;
        },

        /**
        * Removes the vnode&#x27;s child-vnode from its vChildren and the DOM.
        *
         * Syncs with the DOM.
         *
        * @method removeChild
        * @param VNode {vnode} the child-vnode to remove
        * @private
        * @since 0.0.1
        */
        _removeChild: function(VNode) {
            var instance = this,
                domNode = VNode.domNode,
                hadFocus = domNode.hasFocus() &amp;&amp; (VNode.attrs[&#x27;fm-lastitem&#x27;]===&#x27;true&#x27;),
                parentVNode = VNode.vParent;
            VNode._destroy();
            instance.domNode._removeChild(VNode.domNode);
            instance._normalize();
            // now, reset the focus on focusmanager when needed:
            if (hadFocus) {
                while (parentVNode &amp;&amp; !parentVNode.attrs[&#x27;fm-manage&#x27;]) {
                    parentVNode = parentVNode.vParent;
                }
                parentVNode &amp;&amp; parentVNode.domNode.focus();
            }
        },

       /**
        * Replaces the current vnode at the parent.vChildNode list by &#x60;newVNode&#x60;
        *
        * Does NOT sync with the dom.
        *
        * @method _replaceAtParent
        * @param newVNode {Object} the new vnode which should take over the place of the current vnode
        * @private
        * @chainable
        * @since 0.0.1
        */
        _replaceAtParent: function(newVNode) {
            var instance = this,
                vParent = instance.vParent,
                vChildNodes, index;
            if (vParent &amp;&amp; (vChildNodes=vParent.vChildNodes)) {
                index = vChildNodes.indexOf(instance);
                // force to recalculate the vChildren on a next call:
                ((instance.nodeType===1) || (newVNode.nodeType===1)) &amp;&amp; (instance.vParent._vChildren=null);
                vChildNodes[index] = newVNode;
            }
            return instance._destroy();
        },

       /**
        * Sets the attribute of both the vnode as well as its related dom-node.
        *
        * Syncs with the dom.
        *
        * @method _setAttr
        * @param attributeName {String}
        * @param value {String} the value for the attributeName
        * @private
        * @chainable
        * @since 0.0.1
        */
        _setAttr: function(attributeName, value) {
            var instance = this,
                extractStyle, extractClass,
                attrs = instance.attrs,
                prevVal = attrs[attributeName];
            // don&#x27;t check by !== --&gt; value isn&#x27;t parsed into a String yet

            if (prevVal!=value) {
                if ((value===undefined) || (value===null)) {
                    instance._removeAttr(attributeName);
                    return instance;
                }
                // attribute-values are always Strings:
                value = String(value);
                attrs[attributeName] = value;
                // in case of STYLE attribute --&gt; special treatment
                if (attributeName===STYLE) {
                    extractStyle = extractor.extractStyle(value);
                    value = extractStyle.attrStyle;
                    if (value) {
                        attrs.style = value;
                    }
                    else {
                        delete attrs.style;
                    }
                    instance.styles = extractStyle.styles;
                }
                else if (attributeName===CLASS) {
                    // in case of CLASS attribute --&gt; special treatment
                    extractClass = extractor.extractClass(value);
                    value = extractClass.attrClass;
                    if (value) {
                        attrs[CLASS] = value;
                    }
                    else {
                        delete attrs[CLASS];
                    }
                    instance.classNames = extractClass.classNames;
                }
                else if (attributeName===ID) {
                    instance.id &amp;&amp; (delete nodeids[instance.id]);
                    instance.id = value;
                    nodeids[value] = instance.domNode;
                }
                instance.domNode._setAttribute(attributeName, value);
                instance._emit(prevVal ? EV_ATTRIBUTE_CHANGED : EV_ATTRIBUTE_INSERTED, attributeName, value, prevVal);
            }
            return instance;
        },

       /**
        * Redefines the attributes of both the vnode as well as its related dom-node. The new
        * definition replaces any previous attributes (without touching unmodified attributes).
        *
        * Syncs the new vnode&#x27;s attributes with the dom.
        *
        * @method _setAttrs
        * @param newAttrs {Object|Array} the new attributes to be set
        * @private
        * @chainable
        * @since 0.0.1
        */
        _setAttrs: function(newAttrs) {
            // does sync the DOM
            var instance = this,
                attrsObj, attr, attrs, i, key, keys, len, value;
            if (instance.nodeType!==1) {
                return;
            }
            instance._noSync();
            attrs = instance.attrs;
            attrs.id &amp;&amp; (delete nodeids[attrs.id]);

            if (Object.isObject(newAttrs)) {
                attrsObj = newAttrs;
            }
            else {
                attrsObj = {};
                len = newAttrs.length;
                for (i=0; i&lt;len; i++) {
                    attr = newAttrs[i];
                    attrsObj[attr.name] = attr.value;
                }
            }

            // first _remove the attributes that are no longer needed.
            // quickest way for object iteration: http://jsperf.com/object-keys-iteration/20
            keys = Object.keys(attrs);
            len = keys.length;
            for (i = 0; i &lt; len; i++) {
                key = keys[i];
                attrsObj[key] || instance._removeAttr(key);
            }

            // next: every attribute that differs: redefine
            keys = Object.keys(attrsObj);
            len = keys.length;
            for (i = 0; i &lt; len; i++) {
                key = keys[i];
                value = attrsObj[key];
                (attrs[key]===value) || instance._setAttr(key, value);
            }

            return instance;
        },

       /**
        * Redefines the childNodes of both the vnode as well as its related dom-node. The new
        * definition replaces any previous nodes. (without touching unmodified nodes).
        *
        * Syncs the new vnode&#x27;s childNodes with the dom.
        *
        * @method _setChildNodes
        * @param newVChildNodes {Array} array with vnodes which represent the new childNodes
        * @private
        * @chainable
        * @since 0.0.1
        */
        _setChildNodes: function(newVChildNodes) {
            // does sync the DOM
            var instance = this,
                vChildNodes = instance.vChildNodes || [],
                domNode = instance.domNode,
                forRemoval = [],
                i, oldChild, newChild, newLength, len, len2, childDomNode, nodeswitch, bkpAttrs, bkpChildNodes, needNormalize;

            instance._noSync();
            // first: reset ._vChildren --&gt; by making it empty, its getter will refresh its list on a next call
            instance._vChildren = null;
            // if newVChildNodes is undefined, then we assume it to be empty --&gt; an empty array
            newVChildNodes || (newVChildNodes=[]);
            // quickest way to loop through array is by using for loops: http://jsperf.com/array-foreach-vs-for-loop/5
            len = vChildNodes.length;
            newLength = newVChildNodes.length;
            for (i=0; i&lt;len; i++) {
                oldChild = vChildNodes[i];
                childDomNode = oldChild.domNode;
                if (i &lt; newLength) {
                    newChild = newVChildNodes[i];
/*jshint boss:true */
                    switch (nodeswitch=NODESWITCH[oldChild.nodeType][newChild.nodeType]) {
/*jshint boss:false */
                        case 1: // oldNodeType==Element, newNodeType==Element
                            if ((oldChild.tag!==newChild.tag) || ((oldChild.tag===&#x27;SCRIPT&#x27;) &amp;&amp; (oldChild.text!==newChild.text))) {
                                // new tag --&gt; completely replace
                                bkpAttrs = newChild.attrs;
                                bkpChildNodes = newChild.vChildNodes;
                                oldChild.attrs.id &amp;&amp; (delete nodeids[oldChild.attrs.id]);
                                newChild.attrs = {}; // reset to force defined by &#x60;_setAttrs&#x60;
                                newChild.vChildNodes = []; // reset , to force defined by &#x60;_setAttrs&#x60;
                                domNode._replaceChild(newChild.domNode, childDomNode);
                                newChild.vParent = instance;
                                newChild._setAttrs(bkpAttrs);
                                newChild._setChildNodes(bkpChildNodes);
                                newChild.id &amp;&amp; (nodeids[newChild.id]=newChild.domNode);
                                oldChild._replaceAtParent(newChild);
                                newChild._emit(EV_INSERTED);
                            }
                            else {
                                // same tag --&gt; only update what is needed
                                oldChild.attrs = newChild.attrs;
                                oldChild._setAttrs(newChild.attrs);
                                // next: sync the vChildNodes:
                                oldChild._setChildNodes(newChild.vChildNodes);
                                // reset ref. to the domNode, for it might heva been changed by newChild:
                                oldChild.id &amp;&amp; (nodeids[oldChild.id]=childDomNode);
                                newVChildNodes[i] = oldChild;
                            }
                            break;
                        case 2: // oldNodeType==Element, newNodeType==TextNode
                                // case2 and case3 should be treated the same
                        case 3: // oldNodeType==Element, newNodeType==Comment
                            oldChild.attrs.id &amp;&amp; (delete nodeids[oldChild.attrs.id]);
                            newChild.domNode.nodeValue = newChild.text;
                            domNode._replaceChild(newChild.domNode, childDomNode);
                            newChild.vParent = instance;
                            oldChild._replaceAtParent(newChild);
                            instance._emit(EV_CONTENT_CHANGE);
                            break;
                        case 4: // oldNodeType==TextNode, newNodeType==Element
                                // case4 and case7 should be treated the same
                        case 7: // oldNodeType==Comment, newNodeType==Element
                            bkpAttrs = newChild.attrs;
                            bkpChildNodes = newChild.vChildNodes;
                            newChild.attrs = {}; // reset, to force defined by &#x60;_setAttrs&#x60;
                            newChild.vChildNodes = []; // reset to current state, to force defined by &#x60;_setAttrs&#x60;
                            domNode._replaceChild(newChild.domNode, childDomNode);
                            newChild._setAttrs(bkpAttrs);
                            newChild._setChildNodes(bkpChildNodes);
                            newChild.id &amp;&amp; (nodeids[newChild.id]=newChild.domNode);
                            oldChild.isVoid = newChild.isVoid;
                            delete oldChild.text;
                            instance._emit(EV_CONTENT_CHANGE);
                            newChild._emit(EV_INSERTED);
                            break;
                        case 5: // oldNodeType==TextNode, newNodeType==TextNode
                                // case5 and case9 should be treated the same
                        case 9: // oldNodeType==Comment, newNodeType==Comment
                            if (oldChild.text!==newChild.text) {
                                oldChild.domNode.nodeValue = oldChild.text = newChild.text;
                                instance._emit(EV_CONTENT_CHANGE);
                            }
                            newVChildNodes[i] = oldChild;
                            break;
                        case 6: // oldNodeType==TextNode, newNodeType==Comment
                                // case6 and case8 should be treated the same
                        case 8: // oldNodeType==Comment, newNodeType==TextNode
                            newChild.domNode.nodeValue = newChild.text;
                            domNode._replaceChild(newChild.domNode, childDomNode);
                            newChild.vParent = oldChild.vParent;
                            instance._emit(EV_CONTENT_CHANGE);
                    }
                    if ((nodeswitch===2) || (nodeswitch===5) || (nodeswitch===8)) {
                        needNormalize = true;
                    }
                }
                else {
                    // _remove previous definition
                    domNode._removeChild(oldChild.domNode);
                    // the oldChild needs to be removed, however, this cannot be done right now, for it would effect the loop
                    // so we store it inside a hash to remove it later
                    forRemoval[forRemoval.length] = oldChild;
                }
            }
            // now definitely remove marked childNodes:
            len2 = forRemoval.length;
            for (i=0; i&lt;len2; i++) {
                forRemoval[i]._destroy();
            }
            // now we add all new vChildNodes that go beyond &#x60;len&#x60;:
            for (i = len; i &lt; newLength; i++) {
                newChild = newVChildNodes[i];
                newChild.vParent = instance;
                switch (newChild.nodeType) {
                    case 1: // Element
                        bkpAttrs = newChild.attrs;
                        bkpChildNodes = newChild.vChildNodes;
                        newChild.attrs = {}; // reset, to force defined by &#x60;_setAttrs&#x60;
                        newChild.vChildNodes = []; // reset to current state, to force defined by &#x60;_setAttrs&#x60;
                        domNode._appendChild(newChild.domNode);
                        newChild._setAttrs(bkpAttrs);
                        newChild._setChildNodes(bkpChildNodes);
                        newChild._emit(EV_INSERTED);
                        break;
                    case 3: // TextNode
                        needNormalize = true;
                        // we need to break through --&gt; no &#x60;break&#x60;
                        /* falls through */
                    default: // TextNode or CommentNode
                        newChild.domNode.nodeValue = newChild.text;
                        domNode._appendChild(newChild.domNode);
                        instance._emit(EV_CONTENT_CHANGE);
                }
                newChild.storeId();
            }
            instance.vChildNodes = newVChildNodes;
            needNormalize &amp;&amp; instance._normalize();
            return instance;
        }

    };


    //---- properties ------------------------------------------------------------------

    /**
     * A hash of all the &#x60;attributes&#x60; of the vnode&#x27;s representing dom-node.
     *
     * @property attrs
     * @type Object
     * @since 0.0.1
     */

    /**
     * Hash with all the classes of the vnode. Every class represents a key, all values are set &#x60;true&#x60;.
     *
     * @property classNames
     * @type Object
     * @since 0.0.1
     */

    /**
     * The &#x60;id&#x60; of the vnode&#x27;s representing dom-node (if any).
     *
     * @property id
     * @type String
     * @since 0.0.1
     */

    /**
     * Tells whether tag is a void Element. Examples are: &#x60;br&#x60;, &#x60;img&#x60; and &#x60;input&#x60;. Non-void Elements are f.e. &#x60;div&#x60; and &#x60;table&#x60;.
     * For TextNodes and CommentNodes, this property is &#x60;undefined&#x60;.
     *
     * @property isVoid
     * @type Boolean
     * @since 0.0.1
     */

    /**
     * The &#x60;nodeType&#x60; of the vnode&#x27;s representing dom-node (1===ElementNode, 3===TextNode, 8===CommentNode).
     *
     * @property nodeType
     * @type Number
     * @since 0.0.1
     */

    /**
     * The &#x60;tag&#x60; of the vnode&#x27;s representing dom-node (allways uppercase).
     *
     * @property tag
     * @type String
     * @since 0.0.1
     */

    /**
     * The &#x60;content&#x60; of the vnode&#x27;s representing dom-node, in case it is a TextNode or CommentNode.
     * Equals dom-node.nodeValue.
     *
     * Is &#x60;undefined&#x60; for ElementNodes.
     *
     * @property text
     * @type String
     * @since 0.0.1
     */

    /**
     * Hash with all the childNodes (vnodes). vChildNodes are any kind of vnodes (nodeType===1, 3 or 8)
     *
     * @property vChildNodes
     * @type Array
     * @since 0.0.1
     */

    /**
     * The underlying &#x60;dom-node&#x60; that the vnode represents.
     *
     * @property domNode
     * @type domNode
     * @since 0.0.1
     */

    /**
     * vnode&#x27;s parentNode (defined as a vnode itself).
     *
     * @property vParent
     * @type vnode
     * @since 0.0.1
     */

    Object.defineProperties(vNodeProto, {
        /**
         * Gets or sets the innerHTML of both the vnode as well as the representing dom-node.
         *
         * The setter syncs with the DOM.
         *
         * @property innerHTML
         * @type String
         * @since 0.0.1
         */
        innerHTML: {
            get: function() {
                var instance = this,
                    html, vChildNodes, len, i, vChildNode;
                if (instance.nodeType===1) {
                    html = &#x27;&#x27;;
                    vChildNodes = instance.vChildNodes;
                    len = vChildNodes ? vChildNodes.length : 0;
                    for (i=0; i&lt;len; i++) {
                        vChildNode = vChildNodes[i];
                        switch (vChildNode.nodeType) {
                            case 1:
                                html += vChildNode.outerHTML;
                                break;
                            case 3:
                                html += vChildNode.text.replace(/&lt;/g, &#x27;&amp;lt;&#x27;).replace(/&gt;/g, &#x27;&amp;gt;&#x27;);
                                break;
                            case 8:
                                html += &#x27;&lt;!--&#x27; + vChildNode.text.replace(/&lt;/g, &#x27;&amp;lt;&#x27;).replace(/&gt;/g, &#x27;&amp;gt;&#x27;) + &#x27;--&gt;&#x27;;
                        }
                    }
                }
                return html;
            },
            set: function(v) {
                this._setChildNodes(htmlToVNodes(v, vNodeProto));
            }
        },

        /**
         * Gets or sets the innerHTML of both the vnode as well as the representing dom-node.
         *
         * The setter syncs with the DOM.
         *
         * @property nodeValue
         * @type String
         * @since 0.0.1
         */
        nodeValue: {
            get: function() {
                var instance = this;
                return ((instance.nodeType===3) || (instance.nodeType===8)) ? instance.text : null;
            },
            set: function(v) {
                var instance = this,
                    newTextContent, prevTextContent;
                if ((instance.nodeType===3) || (instance.nodeType===8)) {
                    prevTextContent = instance.domNode.textContent;
                    instance.domNode.textContent = v;
                    // set .text AFTER the dom-node is updated --&gt; the content might be escaped!
                    newTextContent = instance.text = instance.domNode.textContent;
                    (newTextContent!==prevTextContent) &amp;&amp; instance._emit(EV_CONTENT_CHANGE);
                }
            }
        },

        /**
         * Gets or sets the outerHTML of both the vnode as well as the representing dom-node.
         *
         * The setter syncs with the DOM.
         *
         * @property outerHTML
         * @type String
         * @since 0.0.1
         */
        outerHTML: {
            get: function() {
                var instance = this,
                    html,
                    attrs = instance.attrs;
                if (instance.nodeType===1) {
                    if (instance.nodeType!==1) {
                        return instance.textContent;
                    }
                    html = &#x27;&lt;&#x27; + instance.tag.toLowerCase();
                    attrs.each(function(value, key) {
                        html += &#x27; &#x27;+key+&#x27;=&quot;&#x27;+value+&#x27;&quot;&#x27;;
                    });
                    html += &#x27;&gt;&#x27;;
                    if (!instance.isVoid) {
                        html += instance.innerHTML + &#x27;&lt;/&#x27; + instance.tag.toLowerCase() + &#x27;&gt;&#x27;;
                    }
                }
                return html;
            },
            set: function(v) {
                var instance = this,
                    vParent = instance.vParent,
                    id = instance.attrs.id,
                    vnode, vnodes, bkpAttrs, bkpChildNodes, i, len, vChildNodes, isLastChildNode, index, refDomNode;
                if ((instance.nodeType!==1) || !vParent) {
                    return;
                }
                instance._noSync();
                vChildNodes = vParent.vChildNodes;
                index = vChildNodes.indexOf(instance);
                isLastChildNode = (index===(vChildNodes.length-1));
                isLastChildNode || (refDomNode=vChildNodes[index+1].domNode);
                vnodes = htmlToVNodes(v, vNodeProto, vParent);
                len = vnodes.length;
                if (len&gt;0) {
                    // the first vnode will replace the current instance:
                    vnode = vnodes[0];
                    if (vnode.nodeType===1) {
                        if (vnode.tag!==instance.tag) {
                            // new tag --&gt; completely replace
                            bkpAttrs = vnode.attrs;
                            bkpChildNodes = vnode.vChildNodes;
                            id &amp;&amp; (delete nodeids[id]);
                            vnode.attrs = {}; // reset to force defined by &#x60;_setAttrs&#x60;
                            vnode.vChildNodes = []; // reset , to force defined by &#x60;_setAttrs&#x60;
                            vParent.domNode._replaceChild(vnode.domNode, instance.domNode);
                            vnode._setAttrs(bkpAttrs);
                            vnode._setChildNodes(bkpChildNodes);
                            // vnode.attrs = bkpAttrs;
                            // vnode.vChildNodes = bkpChildNodes;
                            vnode.id &amp;&amp; (nodeids[vnode.id]=vnode.domNode);
                            instance._replaceAtParent(vnode);
                            vnode._emit(EV_INSERTED);
                        }
                        else {
                            instance._setAttrs(vnode.attrs);
                            instance._setChildNodes(vnode.vChildNodes);
                        }
                    }
                    else {
                        id &amp;&amp; (delete nodeids[id]);
                        vnode.domNode.nodeValue = vnode.text;
                        vParent.domNode._replaceChild(vnode.domNode, instance.domNode);
                        instance._replaceAtParent(vnode);
                        vnode._emit(EV_INSERTED);
                    }
                }
                for (i=1; i&lt;len; i++) {
                    vnode = vnodes[i];
                    switch (vnode.nodeType) {
                        case 1: // Element
                            bkpAttrs = vnode.attrs;
                            bkpChildNodes = vnode.vChildNodes;
                            vnode.attrs = {}; // reset, to force defined by &#x60;_setAttrs&#x60;
                            vnode.vChildNodes = []; // reset to current state, to force defined by &#x60;_setAttrs&#x60;
                            isLastChildNode ? vParent.domNode._appendChild(vnode.domNode) : vParent.domNode._insertBefore(vnode.domNode, refDomNode);
                            vnode._emit(EV_INSERTED);
                            vnode._setAttrs(bkpAttrs);
                            vnode._setChildNodes(bkpChildNodes);
                            break;
                        default: // TextNode or CommentNode
                            vnode.domNode.nodeValue = vnode.text;
                            isLastChildNode ? vParent.domNode._appendChild(vnode.domNode) : vParent.domNode._appendChild(vnode.domNode, refDomNode);
                    }
                    vnode.storeId();
                    vnode._moveToParent(vParent, index+i);
                }
            }
        },

        /**
         * Gets or sets the innerContent of the Node as plain text.
         *
         * The setter syncs with the DOM.
         *
         * @property textContent
         * @type String
         * @since 0.0.1
         */
        textContent: {
            get: function() {
                var instance = this,
                    text = &#x27;&#x27;,
                    vChildNodes = instance.vChildNodes,
                    len, i, vChildNode;
                if (instance.nodeType===1) {
                    vChildNodes = instance.vChildNodes;
                    len = vChildNodes ? vChildNodes.length : 0;
                    for (i=0; i&lt;len; i++) {
                        vChildNode = vChildNodes[i];
                        text += (vChildNode.nodeType===3) ? vChildNode.text : ((vChildNode.nodeType===1) ? vChildNode.textContent : &#x27;&#x27;);
                    }
                }
                else {
                    text = instance.text;
                }
                return text;
            },
            set: function(v) {
                var vnode = Object.create(vNodeProto);
                vnode.domNode = DOCUMENT.createTextNode(v);
                // create circular reference:
                vnode.domNode._vnode = vnode;
                vnode.nodeType = 3;
                vnode.text = vnode.domNode.textContent;
                this._setChildNodes([vnode]);
            }
        },

        /**
         * Hash with all the children (vnodes). vChildren are vnodes that have a representing dom-node that is an HtmlElement (nodeType===1)
         *
         * @property vChildren
         * @type Array
         * @since 0.0.1
         */
        vChildren: {
            get: function() {
                var instance = this,
                    children = instance._vChildren,
                    vChildNode, vChildNodes, i, len;
                vChildNodes = instance.vChildNodes;
                if (vChildNodes &amp;&amp; !children) {
                    children = instance._vChildren = [];
                    len = vChildNodes.length;
                    for (i=0; i&lt;len; i++) {
                        vChildNode = vChildNodes[i];
                        (vChildNode.nodeType===1) &amp;&amp; (children[children.length]=vChildNode);
                    }
                }
                children || (children = instance._vChildren = []);
                return children;
            }
        },

        /**
         * Reference to the first of sibbling vNode&#x27;s, where the related dom-node is either an Element, TextNode or CommentNode (nodeType===1, 3 or 8).
         *
         * @property vFirst
         * @type vnode
         * @since 0.0.1
         */
        vFirst: {
            get: function() {
                var vParent = this.vParent;
                if (!vParent) {
                    return null;
                }
                return vParent.vFirstChild;
            }
        },

        /**
         * Reference to the first vChildNode, where the related dom-node is either an Element, TextNode or CommentNode (nodeType===1, 3 or 8).
         *
         * @property vFirstChild
         * @type vnode
         * @since 0.0.1
         */
        vFirstChild: {
            get: function() {
                return (this.vChildNodes &amp;&amp; this.vChildNodes[0]) || null;
            }
        },

        /**
         * Reference to the first of sibbling vNode&#x27;s, where the related dom-node is an Element(nodeType===1).
         *
         * @property vFirstElement
         * @type vnode
         * @since 0.0.1
         */
        vFirstElement: {
            get: function() {
                var vParent = this.vParent;
                if (!vParent) {
                    return null;
                }
                return vParent.vFirstElementChild;
            }
        },

        /**
         * Reference to the first vChild, where the related dom-node an Element (nodeType===1).
         *
         * @property vFirstElementChild
         * @type vnode
         * @since 0.0.1
         */
        vFirstElementChild: {
            get: function() {
                return this.vChildren[0] || null;
            }
        },

        /**
         * Reference to the last of sibbling vNode&#x27;s, where the related dom-node is either an Element, TextNode or CommentNode (nodeType===1, 3 or 8).
         *
         * @property vLast
         * @type vnode
         * @since 0.0.1
         */
        vLast: {
            get: function() {
                var vParent = this.vParent;
                if (!vParent) {
                    return null;
                }
                return vParent.vLastChild;
            }
        },

        /**
         * Reference to the last vChildNode, where the related dom-node is either an Element, TextNode or CommentNode (nodeType===1, 3 or 8).
         *
         * @property vLastChild
         * @type vnode
         * @since 0.0.1
         */
        vLastChild: {
            get: function() {
                var vChildNodes = this.vChildNodes;
                return (vChildNodes &amp;&amp; vChildNodes[vChildNodes.length-1]) || null;
            }
        },

        /**
         * Reference to the last of sibbling vNode&#x27;s, where the related dom-node is an Element(nodeType===1).
         *
         * @property vLastElement
         * @type vnode
         * @since 0.0.1
         */
        vLastElement: {
            get: function() {
                var vParent = this.vParent;
                if (!vParent) {
                    return null;
                }
                return vParent.vLastElementChild;
            }
        },

        /**
         * Reference to the last vChild, where the related dom-node an Element (nodeType===1).
         *
         * @property vLastElementChild
         * @type vnode
         * @since 0.0.1
         */
        vLastElementChild: {
            get: function() {
                var vChildren = this.vChildren;
                return vChildren[vChildren.length-1] || null;
            }
        },

        /**
         * the Parent vnode
         *
         * @property vParent
         * @type vnode
         * @since 0.0.1
         */

        /**
         * Reference to the next of sibbling vNode&#x27;s, where the related dom-node is either an Element, TextNode or CommentNode (nodeType===1, 3 or 8).
         *
         * @property vNext
         * @type vnode
         * @since 0.0.1
         */
        vNext: {
            get: function() {
                return _findNodeSibling(this, true);
            }
        },

        /**
         * Reference to the next of sibbling vNode&#x27;s, where the related dom-node is an Element(nodeType===1).
         *
         * @property vNextElement
         * @type vnode
         * @since 0.0.1
         */
        vNextElement: {
            get: function() {
                return _findElementSibling(this, true);
            }
        },

        /**
         * Reference to the previous of sibbling vNode&#x27;s, where the related dom-node is either an Element, TextNode or CommentNode (nodeType===1, 3 or 8).
         *
         * @property vPrevious
         * @type vnode
         * @since 0.0.1
         */
        vPrevious: {
            get: function() {
                return _findNodeSibling(this);
            }
        },

        /**
         * Reference to the previous of sibbling vNode&#x27;s, where the related dom-node is an Element(nodeType===1).
         *
         * @property vPreviousElement
         * @type vnode
         * @since 0.0.1
         */
        vPreviousElement: {
            get: function() {
                return _findElementSibling(this);
            }
        }
    });

    return vNodeProto;

};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
