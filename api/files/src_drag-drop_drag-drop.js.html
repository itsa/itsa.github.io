<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/drag-drop/drag-drop.js - Itsa</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Itsa"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/DD.html">DD</a></li>
            
                <li><a href="../classes/document.html">document</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/FocusManager.html">FocusManager</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/NS-vdom.html">NS-vdom</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Plugins.html">Plugins</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/String.html">String</a></li>
            
                <li><a href="../classes/USERAGENT.html">USERAGENT</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vnode.html">vnode</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/attribute-extractor.html">attribute-extractor</a></li>
            
                <li><a href="../modules/drag.html">drag</a></li>
            
                <li><a href="../modules/drag-drop.html">drag-drop</a></li>
            
                <li><a href="../modules/element-array.html">element-array</a></li>
            
                <li><a href="../modules/element-plugin.html">element-plugin</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-hover.html">event-hover</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/event-mobile.html">event-mobile</a></li>
            
                <li><a href="../modules/extend-document.html">extend-document</a></li>
            
                <li><a href="../modules/extend-element.html">extend-element</a></li>
            
                <li><a href="../modules/focusmanager.html">focusmanager</a></li>
            
                <li><a href="../modules/html-parser.html">html-parser</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/itsa.build.html">itsa.build</a></li>
            
                <li><a href="../modules/js-ext.html">js-ext</a></li>
            
                <li><a href="../modules/lib_array.js.html">lib/array.js</a></li>
            
                <li><a href="../modules/lib_function.js.html">lib/function.js</a></li>
            
                <li><a href="../modules/lib_object.js.html">lib/object.js</a></li>
            
                <li><a href="../modules/lib_promise.s.html">lib/promise.s</a></li>
            
                <li><a href="../modules/lib_string.js.html">lib/string.js</a></li>
            
                <li><a href="../modules/node-parser.html">node-parser</a></li>
            
                <li><a href="../modules/node-win.html">node-win</a></li>
            
                <li><a href="../modules/useragent.html">useragent</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/vdom.html">vdom</a></li>
            
                <li><a href="../modules/vdom-ns.html">vdom-ns</a></li>
            
                <li><a href="../modules/vnode.html">vnode</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/drag-drop/drag-drop.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;

/**
 * Provides &#x60;drag and drop&#x60; functionality with dropzones
 *
 *
 * &lt;i&gt;Copyright (c) 2014 ITSA - https://github.com/itsa&lt;/i&gt;
 * New BSD License - http://choosealicense.com/licenses/bsd-3-clause/
 *
 * @example
 * DD = require(&#x27;drag-drop&#x27;)(window);
 * DD.init();
 *
 * @module drag-drop
 * @class DD
 * @since 0.0.4
*/


// Redefine the API for the events &#x60;dd&#x60;, &#x60;dd-drag&#x60; and &#x60;dd-drop&#x60;, for they have more properties:

/**
* Emitted during the drag-cycle of a draggable Element (while it is dragged).
*
* @event *:dd-drag (extended by drag-drop)
* @param e {Object} eventobject including:
* @param e.target {HtmlElement} the HtmlElement that is being dragged
* @param e.dragNode {HtmlElement} The HtmlElement that is being dragged (equals e.target)
* @param [e.sourceNode] {HtmlElement} The original Element. Only when a &#x60;copy&#x60; is made --&gt; e.dragNode is being moved while
*        e.sourceNode stand at its place.
* @param e.currentTarget {HtmlElement} the HtmlElement that is delegating
* @param e.sourceTarget {HtmlElement} the deepest HtmlElement where the mouse lies upon
* @param [e.dropTarget] {HtmlElement} The dropzone HtmlElement that will be available whenever the draggable gets over a dropzone.
* @param e.dd {Promise} Promise that gets fulfilled when dragging is ended. The fullfilled-callback has no arguments.
* @param [e.dropzone] {Promise} a Promise that will be available whenever the draggable gets over a dropzone.
*        The Promise that gets fulfilled as soon as the draggable is dropped, or outside the dropzone
*        Will fulfill with one argument: &#x60;onDropzone&#x60; {Boolean} when &#x60;true&#x60;, the draggable is dropped inside the dropzone, otherwise
*        the draggable got outside the dropzone without beging dropped.
* @param e.ctrlKey {Boolean} Whether the Ctrl/cmd key is pressed
* @param e.isCopied {Boolean} Whether the drag is a copy-drag
* @param e.xMouse {Number} the current x-position in the window-view
* @param e.yMouse {Number} the current y-position in the window-view
* @param e.clientX {Number} the current x-position in the window-view
* @param e.clientY {Number} the current y-position in the window-view
* @param e.xMouseOrigin {Number} the original x-position in the document when drag started (incl. scrollOffset)
* @param e.yMouseOrigin {Number} the original y-position in the document when drag started (incl. scrollOffset)
* @param [e.relatives] {NodeList} an optional list that the user could set in a &#x60;before&#x60;-subscriber of the &#x60;dd&#x60;-event
*        to inform which nodes are related to the draggable node and should be dragged as well.
* @param [e.relativeDragNodes] {NodeList} an optional list that holds the HtmlElements that corresponds with
*        the &#x60;e.relative&#x60; list, but is a list with draggable Elements.

* @since 0.0.1
*/

/**
* Emitted when drag-cycle of a draggable Element is ended.
*
* @event *:dd-drop (extended by drag-drop)
* @param e {Object} eventobject including:
* @param e.target {HtmlElement} the HtmlElement that is being dragged
* @param e.dragNode {HtmlElement} The HtmlElement that is being dragged (equals e.target)
* @param [e.sourceNode] {HtmlElement} The original Element. Only when a &#x60;copy&#x60; is made --&gt; e.dragNode is being moved while
*        e.sourceNode stand at its place.
* @param e.currentTarget {HtmlElement} the HtmlElement that is delegating
* @param e.sourceTarget {HtmlElement} the deepest HtmlElement where the mouse lies upon
* @param [e.dropTarget] {HtmlElement} The dropzone HtmlElement that will be available whenever the draggable gets over a dropzone.
* @param e.dd {Promise} Promise that gets fulfilled when dragging is ended. The fullfilled-callback has no arguments.
* @param [e.dropzone] {Promise} a Promise that will be available whenever the draggable gets over a dropzone.
*        The Promise that gets fulfilled as soon as the draggable is dropped, or outside the dropzone
*        Will fulfill with one argument: &#x60;onDropzone&#x60; {Boolean} when &#x60;true&#x60;, the draggable is dropped inside the dropzone, otherwise
*        the draggable got outside the dropzone without beging dropped.
* @param e.ctrlKey {Boolean} Whether the Ctrl/cmd key is pressed
* @param e.isCopied {Boolean} Whether the drag is a copy-drag
* @param e.xMouse {Number} the current x-position in the window-view
* @param e.yMouse {Number} the current y-position in the window-view
* @param e.clientX {Number} the current x-position in the window-view
* @param e.clientY {Number} the current y-position in the window-view
* @param e.xMouseOrigin {Number} the original x-position in the document when drag started (incl. scrollOffset)
* @param e.yMouseOrigin {Number} the original y-position in the document when drag started (incl. scrollOffset)
* @param [e.relatives] {NodeList} an optional list that the user could set in a &#x60;before&#x60;-subscriber of the &#x60;dd&#x60;-event
*        to inform which nodes are related to the draggable node and should be dragged as well.
* @param [e.relativeDragNodes] {NodeList} an optional list that holds the HtmlElements that corresponds with
*        the &#x60;e.relative&#x60; list, but is a list with draggable Elements.

* @since 0.0.1
*/

/**
* Emitted when a draggable Element&#x27;s drag-cycle starts. You can use a &#x60;before&#x60;-subscriber to specify
* e.relatives, which should be a nodelist with HtmlElements, that should be dragged togehter with the master
* draggable Element.
*
* @event dd (extended by drag-drop)
* @param e {Object} eventobject including:
* @param e.target {HtmlElement} the HtmlElement that is being dragged
* @param e.dragNode {HtmlElement} The HtmlElement that is being dragged (equals e.target)
* @param [e.sourceNode] {HtmlElement} The original Element. Only when a &#x60;copy&#x60; is made --&gt; e.dragNode is being moved while
*        e.sourceNode stand at its place.
* @param e.currentTarget {HtmlElement} the HtmlElement that is delegating
* @param e.sourceTarget {HtmlElement} the deepest HtmlElement where the mouse lies upon
* @param e.dd {Promise} Promise that gets fulfilled when dragging is ended. The fullfilled-callback has no arguments.
* @param e.ctrlKey {Boolean} Whether the Ctrl/cmd key is pressed
* @param e.isCopied {Boolean} Whether the drag is a copy-drag
* @param e.xMouse {Number} the current x-position in the window-view
* @param e.yMouse {Number} the current y-position in the window-view
* @param e.clientX {Number} the current x-position in the window-view
* @param e.clientY {Number} the current y-position in the window-view
* @param e.xMouseOrigin {Number} the original x-position in the document when drag started (incl. scrollOffset)
* @param e.yMouseOrigin {Number} the original y-position in the document when drag started (incl. scrollOffset)
* @param [e.relatives] {NodeList} an optional list that the user could set in a &#x60;before&#x60;-subscriber of the &#x60;dd&#x60;-event
*        to inform which nodes are related to the draggable node and should be dragged as well.
* @param [e.relativeDragNodes] {NodeList} an optional list that holds the HtmlElements that corresponds with
*        the &#x60;e.relative&#x60; list, but is a list with draggable Elements.

* @since 0.0.1
*/

/**
 * Objecthash containing all specific information about the particular drag-cycle.
 * It has a structure like this:
 *
 * ddProps = {
 *     sourceNode {HtmlElement} original node (defined by drag-drop)
 *     dragNode {HtmlElement} Element that is dragged
 *     x {Number} absolute x-position of the draggable inside &#x60;document&#x60; when the drag starts
 *     y {Number} absolute y-position of the draggable inside &#x60;document&#x60; when the drag starts
 *     inlineLeft {String} inline css of the property &#x60;left&#x60; when drag starts
 *     inlineTop {String} inline css of the property &#x60;top&#x60; when drag starts
 *     winConstrained {Boolean} whether the draggable should be constrained to &#x60;window&#x60;
 *     xMouseLast {Number} absolute x-position of the mouse inside &#x60;document&#x60; when the drag starts
 *     yMouseLast {Number} absolute y-position of the draggable inside &#x60;document&#x60; when the drag starts
 *     winScrollLeft {Number} the left-scroll of window when drag starts
 *     winScrollTop {Number} the top-scroll of window when drag starts
 *     constrain = { // constrain-properties when constrained to a HtmlElement
 *         xOrig {Number} x-position in the document, included with left-border-width
 *         yOrig {Number} y-position in the document, included with top-border-width
 *         x {Number} xOrig corrected with scroll-left of the constrained node
 *         y {Number} yOrig corrected with scroll-top of the constrained node
 *         w {Number} scrollWidth
 *         h {Number} scrollHeight
 *     };
 *     dropzoneSpecified {Boolean} whether the draggable has a dropzone specified (either by &#x60;dd-dropzone&#x60; or by &#x60;dd-emitter&#x60;) (defined by drag-drop)
 *     dragOverEv {Object} Eventhandler that watches for &#x60;mousemove&#x60; to detect dropzone-over events (defined by drag-drop)
 *     relatives[{ // Array with objects that represent all draggables that come along with the master-draggable (in case of multiple items), excluded the master draggable itself
 *         sourceNode {HtmlElement} original node (defined by drag-drop)
 *         dragNode {HtmlElement} draggable node
 *         shiftX {Number} the amount of left-pixels that this HtmlElement differs from the dragged element
 *         shiftY {Number} the amount of top-pixels that this HtmlElement differs from the dragged element
 *         inlineLeft {String} inline css of the property &#x60;left&#x60; when drag starts
 *         inlineTop {String} inline css of the property &#x60;top&#x60; when drag starts
 *     }]
 *     relativeDragNodes [HtmlElements] Array with all &#x60;copyied&#x60; Nodes corresponding to &#x60;ddProps.relatives&#x60;. Only in case of copying multiple items (defined by drag-drop)
 * }
 *
 * @property ddProps (extended by drag-drop)
 * @default {}
 * @type Object
 * @since 0.0.1
*/

var DRAG = &#x27;drag&#x27;,
    DROP = &#x27;drop&#x27;,
    NAME = &#x27;[&#x27;+DRAG+&#x27;-&#x27;+DROP+&#x27;]: &#x27;,
    COPY = &#x27;copy&#x27;,
    DROPZONE = DROP+&#x27;zone&#x27;,
    SOURCE = &#x27;source&#x27;,
    DRAGGABLE = DRAG+&#x27;gable&#x27;,
    DEL_DRAGGABLE = &#x27;del-&#x27;+DRAGGABLE,
    DD_MINUS = &#x27;dd-&#x27;,
    DD_DRAGGING_CLASS = DD_MINUS+DRAG+&#x27;ging&#x27;,
    DD_MASTER_CLASS = DD_MINUS+&#x27;master&#x27;,
    DD_HANDLE = DD_MINUS+&#x27;handle&#x27;,
    DD_SOURCE_ISCOPIED_CLASS = DD_MINUS+COPY+SOURCE,
    DD_COPIED_CLASS = DD_MINUS+COPY,
    DD_DROPZONE_MOVABLE = DD_MINUS+DROPZONE+&#x27;-movable&#x27;,
    CONSTRAIN_ATTR = &#x27;constrain-selector&#x27;,
    MOUSE = &#x27;mouse&#x27;,
    DROPZONE_OVER = DROPZONE+&#x27;-over&#x27;,
    DROPZONE_DROP = DROPZONE+&#x27;-&#x27;+DROP,
    DD_DROPZONE = DD_MINUS+DROPZONE,
    NO_TRANS_CLASS = &#x27;el-notrans&#x27;, // delivered by &#x60;vdom&#x60;
    DD_HIDDEN_SOURCE_CLASS = DD_MINUS+&#x27;hidden-&#x27;+SOURCE,
    INVISIBLE_CLASS = &#x27;el-invisible&#x27;, // delivered by &#x60;vdom&#x60;
    DD_TRANSITION_CLASS = DD_MINUS+&#x27;transition&#x27;,
    DD_OPACITY_CLASS = DD_MINUS+&#x27;opacity&#x27;,
    HIGH_Z_CLASS = DD_MINUS+&#x27;high-z&#x27;,
    DD_DROPACTIVE_CLASS = DROPZONE+&#x27;-awake&#x27;,
    DD_ABOVE_DROPZONE_CLASS = DD_MINUS+&#x27;above&#x27;+DROPZONE,
    REGEXP_MOVE = /\bmove\b/i,
    REGEXP_COPY = /\bcopy\b/i,
    REGEXP_ALL = /\b(all|true)\b/i,
    EMITTER = &#x27;emitter&#x27;,
    REGEXP_EMITTER = /\bemitter=((\w|,)+)\b/,
    DD_EMITTER = DD_MINUS+EMITTER,
    MOVE = &#x27;move&#x27;,
    DROPZONE_OUT = DROPZONE+&#x27;-out&#x27;,
    DD_DROP = DD_MINUS+DROP,
    DD_FAKE = DD_MINUS+&#x27;fake-&#x27;,
    DOWN = &#x27;down&#x27;,
    UP = &#x27;up&#x27;,
    KEY = &#x27;key&#x27;,
    MOUSEMOVE = MOUSE+MOVE,
    PANMOVE = &#x27;pan&#x27;+MOVE,
    DD_FAKE_MOUSEMOVE = DD_FAKE+MOUSEMOVE,
    UI = &#x27;UI&#x27;,
    DROPZONE_BRACKETS = &#x27;[&#x27; + DD_DROPZONE + &#x27;]&#x27;,
    DD_EFFECT_ALLOWED = DD_MINUS+&#x27;effect-allowed&#x27;,
    BORDER = &#x27;border&#x27;,
    WIDTH = &#x27;width&#x27;,
    BORDER_LEFT_WIDTH = BORDER+&#x27;-left-&#x27;+WIDTH,
    BORDER_RIGHT_WIDTH = BORDER+&#x27;-right-&#x27;+WIDTH,
    BORDER_TOP_WIDTH = BORDER+&#x27;-top-&#x27;+WIDTH,
    BORDER_BOTTOM_WIDTH = BORDER+&#x27;-bottom-&#x27;+WIDTH,
    LEFT = &#x27;left&#x27;,
    TOP = &#x27;top&#x27;,
    POSITION = &#x27;position&#x27;,
    ABSOLUTE = &#x27;absolute&#x27;,
    TRUE = &#x27;true&#x27;,
    DD_MINUSDRAGGABLE = DD_MINUS+DRAGGABLE,
    PLUGIN_ATTRS = [DD_DROPZONE, CONSTRAIN_ATTR, DD_EMITTER, DD_HANDLE, DD_EFFECT_ALLOWED, DD_DROPZONE_MOVABLE];

require(&#x27;polyfill/polyfill-base.js&#x27;);
require(&#x27;js-ext&#x27;);
require(&#x27;./css/drag-drop.css&#x27;);

module.exports = function (window) {

    window._ITSAmodules || Object.protectedProp(window, &#x27;_ITSAmodules&#x27;, {});

    if (window._ITSAmodules.DragDrop) {
        return window._ITSAmodules.DragDrop; // DragDrop was already created
    }

    var Event = require(&#x27;event-dom&#x27;)(window),
        nodePlugin = require(&#x27;vdom&#x27;)(window).Plugins.nodePlugin,
        DragModule = require(&#x27;drag&#x27;)(window),
        $superInit = DragModule.DD.init,
        ctrlPressed = false,
        dropEffect = MOVE,
        DOCUMENT = window.document,
        isMobile = require(&#x27;useragent&#x27;)(window).isMobile,
        supportHammer = !!Event.Hammer,
        mobileEvents = supportHammer &amp;&amp; isMobile,
        DD, DD_Object;

    require(&#x27;window-ext&#x27;)(window);

    DD = {
      /**
        * Returns the allowed effects on the dragable-HtmlElement. Is determined by the attribute &#x60;dd-effect-allowed&#x60;
        * Will be set to &quot;move&quot; when undefined.
        *
        * @method _allowedEffects
        * @param dragableElement {HtmlElement} HtmlElement that is checked for its allowed effects
        * @return {String} allowed effects: &quot;move&quot;, &quot;copy&quot; or &quot;all&quot;
        * @private
        * @since 0.0.1
        */
        _allowedEffects: function(dragableElement) {
            console.log(NAME, &#x27;_allowedEffects&#x27;);
            var allowedEffects = dragableElement.getAttr(DD_EFFECT_ALLOWED);
            return allowedEffects || MOVE;
        },

        /**
         * Default function for the &#x60;*:dd-drop&#x60;-event. Overrides the definition of the &#x60;drag&#x60;-module.
         *
         * @method _defFnDrop (extended by drag-drop)
         * @param e {Object} eventobject
         * @param sourceNode {HtmlElement} the original HtmlElement
         * @param dragNode {HtmlElement} the dragged HtmlElement (either original or clone)
         * @param dropzoneSpecified {Boolean} whether the sourceNode had a dropzone specified
         * @param relatives {Array} hash with all draggables that are being move togerther with the master draggable
         * @private
         * @since 0.0.1
         */
        _defFnDrop: function(e, ddProps) {
            console.log(NAME, &#x27;_defFnDrop: default function dd-drop. dropzoneSpecified: &#x27;+ddProps.dropzoneSpecified);
            var instance = this,
                sourceNode = ddProps.sourceNode,
                dragNode = ddProps.dragNode,
                dropzoneSpecified = ddProps.dropzoneSpecified,
                relatives = ddProps.relatives,
                willBeCopied,
                removeClasses = function (node) {
                    node.removeClass([NO_TRANS_CLASS, HIGH_Z_CLASS, DD_DRAGGING_CLASS, DEL_DRAGGABLE, DD_MASTER_CLASS, DD_SOURCE_ISCOPIED_CLASS]);
                };

            willBeCopied =  (e.dropTarget &amp;&amp; ((ctrlPressed &amp;&amp; instance.allowCopy(dragNode)) || instance.onlyCopy(dragNode)));
            willBeCopied || (e.relativeDragNodes=null);
            e.isCopied = willBeCopied;

            // handle drop
            if (dropzoneSpecified) {
                instance._handleDrop(e, sourceNode, dragNode, relatives);
            }
            else {
                PLUGIN_ATTRS.forEach(function(attribute) {
                    var data = &#x27;_del_&#x27;+attribute;
                    if (dragNode.getData(data)) {
                        dragNode.removeAttr(attribute);
                        dragNode.removeData(data);
                    }
                });
                removeClasses(dragNode);
                ddProps.relatives &amp;&amp; ddProps.relatives.forEach(
                    function(item) {
                        removeClasses(item.dragNode);
                    }
                );
            }
            instance.restoreDraggables = function() {/* NOOP */ return this;};
        },

       /**
         * Default function for the &#x60;*:dropzone&#x60;-event
         *
         * @method _defFnOver
         * @param e {Object} eventobject
         * @private
         * @since 0.0.1
         */
        _defFnOver: function(e) {
            console.log(NAME, &#x27;_defFnOver: default function dropzone&#x27;);
            var dropzone = e.target;
            dropzone.setClass(DD_DROPACTIVE_CLASS);
            e.sourceNode.setClass(DD_ABOVE_DROPZONE_CLASS);
            e.dragNode.setClass(DD_ABOVE_DROPZONE_CLASS);
            e.dropzone.then(
                function(insideDropTarget) {
                    dropzone.removeClass(DD_DROPACTIVE_CLASS);
                    e.sourceNode.removeClass(DD_ABOVE_DROPZONE_CLASS);
                    e.dragNode.removeClass(DD_ABOVE_DROPZONE_CLASS);
                    /**
                    * Emitted when the draggable gets out of the dropzone.
                    *
                    * @event *:dropzone-out
                    * @param e {Object} eventobject including:
                    * @param e.target {HtmlElement} the dropzone
                    * @param e.dragNode {HtmlElement} The HtmlElement that is being dragged
                    * @param e.dropzone {Promise} The Promise that gets fulfilled as soon as the draggable is dropped, or outside the dropzone
                    *        Will fulfill with one argument: &#x60;onDropzone&#x60; {Boolean} when &#x60;true&#x60;, the draggable is dropped inside the dropzone, otherwise
                    *        the draggable got outside the dropzone without beging dropped.
                    * @param e.dropTarget {HtmlElement} The dropzone HtmlElement. Equals e.target
                    * @param e.ctrlKey {Boolean} Whether the Ctrl/cmd key is pressed
                    * @param e.isCopied {Boolean} Whether the drag is a copy-drag
                    * @param [e.sourceNode] {HtmlElement} The original Element. Only when a &#x60;copy&#x60; is made --&gt; e.dragNode is being moved while
                    *        e.sourceNode stand at its place.
                    * @param e.currentTarget {HtmlElement} the HtmlElement that is delegating the draggable
                    * @param e.sourceTarget {HtmlElement} the deepest HtmlElement of the draggable where the mouse lies upon
                    * @param e.dd {Promise} Promise that gets fulfilled when dragging is ended. The fullfilled-callback has no arguments.
                    * @param e.xMouse {Number} the current x-position in the window-view
                    * @param e.yMouse {Number} the current y-position in the window-view
                    * @param e.clientX {Number} the current x-position in the window-view
                    * @param e.clientY {Number} the current y-position in the window-view
                    * @param e.xMouseOrigin {Number} the original x-position in the document when drag started (incl. scrollOffset)
                    * @param e.yMouseOrigin {Number} the original y-position in the document when drag started (incl. scrollOffset)
                    * @param [e.relatives] {NodeList} an optional list that the user could set in a &#x60;before&#x60;-subscriber of the &#x60;dd&#x60;-event
                    *        to inform which nodes are related to the draggable node and should be dragged as well.
                    * @param [e.relativeDragNodes] {NodeList} an optional list that holds the HtmlElements that corresponds with
                    *        the &#x60;e.relative&#x60; list, but is a list with draggable Elements.
                    * @since 0.1
                    */
                    insideDropTarget || e._noDDoutEvt || Event.emit(dropzone, e.emitter+&#x27;:&#x27;+DROPZONE_OUT, e);
                }
            );
        },

        /**
         * Defines the definition of the &#x60;dd-drop&#x60; event: the last phase of the drag-eventcycle (dd-start, *:dd-drag, *:dd-drop)
         *
         * @method _defineDropEv
         * @param e {Object} eventobject
         * @param sourceNode {HtmlElement} the original HtmlElement
         * @param dragNode {HtmlElement} the dragged HtmlElement (either original or clone)
         * @param dropzoneSpecified {Boolean} whether the sourceNode had a dropzone specified
         * @param x {Number} x-position in coordinaties relative to &#x60;document&#x60; (like getX())
         * @param y {Number} y-position in coordinaties relative to &#x60;document&#x60; (like getX())
         * @param inlineLeft {String} inline css &#x60;left&#x60; for the original sourceNode
         * @param inlineTop {String} inline css &#x60;top&#x60; for the original sourceNode
         * @param relatives {Array} hash with all draggables that are being move togerther with the master draggable
         * @private
         * @since 0.0.1
         */
        _defineDropEv: function(e, ddProps) {
            console.log(NAME, &#x27;_defineDropEv &#x27;+ddProps.dragNode);
            var instance = this;
            instance.restoreDraggables = instance._restoreDraggables.bind(instance, e, ddProps);
            Event.defineEvent(e.emitter+&#x27;:&#x27;+DD_DROP)
                .defaultFn(instance._defFnDrop.rbind(instance, ddProps))
                .forceAssign(); // need to reassign, because all arguments need to be bound again and we need to override the definition of the &#x60;drag&#x60;-module
        },

        /**
         * Defines the definition of the &#x60;dropzone&#x60; event.
         * Also sets up listeners to tricker dd-over when the mouse is above an dropzone.
         *
         * @method _defineOverEv
         * @param e {Object} eventobject
         * @param dropzones {NodeList} list with dropzonenodes
         * @private
         * @since 0.0.1
         */
        _defineOverEv: function(e, dropzones) {
            console.log(NAME, &#x27;_defineOverEv&#x27;);
            var instance = this,
                emitterName = e.emitter,
                ddProps = instance.ddProps;
            Event.defineEvent(emitterName+&#x27;:&#x27;+DROPZONE_OVER)
                 .defaultFn(instance._defFnOver.bind(instance)); // no need to reassign
            return Event.after([mobileEvents ? PANMOVE : MOUSEMOVE, DD_FAKE_MOUSEMOVE], function(e2) {
                var overDropzone = false,
                    dragNode = ddProps.dragNode;
                if (typeof e2.center===&#x27;object&#x27;) {
                    e2.clientX = e2.center.x;
                    e2.clientY = e2.center.y;
                }
                ddProps.mouseOverNode = e.target;
                if (e2.clientX) {
                    ddProps.xMouseLast = e2.clientX + window.getScrollLeft();
                    ddProps.yMouseLast = e2.clientY + window.getScrollTop();
                }
                dropzones.forEach(
                    function(dropzone) {
                        // don&#x27;t do double:
                        if (dropzone === e.dropTarget) {
                            overDropzone = true;
                            return;
                        }
                        var dropzoneAccept = dropzone.getAttr(DD_DROPZONE) || &#x27;&#x27;,
                            dropzoneMove = REGEXP_MOVE.test(dropzoneAccept),
                            dropzoneCopy = REGEXP_COPY.test(dropzoneAccept),
                            dropzoneDefDraggable = dragNode.getAttr(DD_DROPZONE),
                            dragOverPromise, dragOutEvent, effectAllowed, emitterAllowed, dropzoneEmitter, xMouseLast, yMouseLast, dropzoneAllowed;

                        // check if the mouse is inside the dropzone
                        // also check if the mouse is inside the dragged node: the dragged node might have been constrained
                        // and check if the dragged node is effectAllowed to go into the dropzone
                        xMouseLast = ddProps.xMouseLast;
                        yMouseLast = ddProps.yMouseLast;

                        if (dropzone.insidePos(xMouseLast, yMouseLast) &amp;&amp; dragNode.insidePos(xMouseLast, yMouseLast)) {
                            effectAllowed = (!dropzoneMove &amp;&amp; !dropzoneCopy) || (dropzoneCopy &amp;&amp; (dropEffect===COPY)) || (dropzoneMove &amp;&amp; (dropEffect===MOVE));
                            dropzoneEmitter = instance.getDropzoneEmitter(dropzoneAccept);
                            emitterAllowed = !dropzoneEmitter || (dropzoneEmitter.contains(emitterName));
                            dropzoneAllowed = !dropzoneDefDraggable || ((dropzoneDefDraggable===TRUE) || dropzone.matchesSelector(dropzoneDefDraggable));
                            if (dropzoneAllowed &amp;&amp; effectAllowed &amp;&amp; emitterAllowed) {
                                overDropzone = true;
                                e.dropTarget = dropzone;
                                // mouse is in area of dropzone
                                dragOverPromise = Promise.manage();
                                e.dropzone = dragOverPromise;
                                dragOutEvent = Event.after(
                                    [mobileEvents ? PANMOVE : MOUSEMOVE, DD_FAKE_MOUSEMOVE],
                                    function() {
                                        dragOverPromise.fulfill(false);
                                    },
                                    function(e3) {
                                        var effectAllowed, dropzoneAccept, dropzoneMove, dropzoneCopy;
                                        if (e3.type===DD_FAKE_MOUSEMOVE) {
                                            dropzoneAccept = dropzone.getAttr(DD_DROPZONE) || &#x27;&#x27;;
                                            dropzoneMove = REGEXP_MOVE.test(dropzoneAccept);
                                            dropzoneCopy = REGEXP_COPY.test(dropzoneAccept);
                                            effectAllowed = (!dropzoneMove &amp;&amp; !dropzoneCopy) || (dropzoneCopy &amp;&amp; (dropEffect===COPY)) || (dropzoneMove &amp;&amp; (dropEffect===MOVE));
                                            return !effectAllowed;
                                        }
                                        return !dropzone.insidePos((e3.clientX || e3.center.x)+window.getScrollLeft(), (e3.clientY || e3.center.y)+window.getScrollTop());
                                    }
                                );
                                dragOverPromise.finally(
                                    function(insideDropzone) {
                                        dragOutEvent.detach();
                                        insideDropzone || (e.dropTarget=null);
                                    }
                                );
                                ddProps.dragOverList.push(dragOverPromise);
                                /**
                                * Emitted when the draggable gets inside a dropzone.
                                *
                                * @event *:dropzone-over
                                * @param e {Object} eventobject including:
                                * @param e.target {HtmlElement} the dropzone
                                * @param e.dragNode {HtmlElement} The HtmlElement that is being dragged
                                * @param e.dropzone {Promise} The Promise that gets fulfilled as soon as the draggable is dropped, or outside the dropzone
                                *        Will fulfill with one argument: &#x60;onDropzone&#x60; {Boolean} when &#x60;true&#x60;, the draggable is dropped inside the dropzone, otherwise
                                *        the draggable got outside the dropzone without beging dropped.
                                * @param e.dropTarget {HtmlElement} The dropzone HtmlElement. Equals e.target
                                * @param e.ctrlKey {Boolean} Whether the Ctrl/cmd key is pressed
                                * @param e.isCopied {Boolean} Whether the drag is a copy-drag
                                * @param [e.sourceNode] {HtmlElement} The original Element. Only when a &#x60;copy&#x60; is made --&gt; e.dragNode is being moved while
                                *        e.sourceNode stand at its place.
                                * @param e.currentTarget {HtmlElement} the HtmlElement that is delegating the draggable
                                * @param e.sourceTarget {HtmlElement} the deepest HtmlElement of the draggable where the mouse lies upon
                                * @param e.dd {Promise} Promise that gets fulfilled when dragging is ended. The fullfilled-callback has no arguments.
                                * @param e.xMouse {Number} the current x-position in the window-view
                                * @param e.yMouse {Number} the current y-position in the window-view
                                * @param e.clientX {Number} the current x-position in the window-view
                                * @param e.clientY {Number} the current y-position in the window-view
                                * @param e.xMouseOrigin {Number} the original x-position in the document when drag started (incl. scrollOffset)
                                * @param e.yMouseOrigin {Number} the original y-position in the document when drag started (incl. scrollOffset)
                                * @param [e.relatives] {NodeList} an optional list that the user could set in a &#x60;before&#x60;-subscriber of the &#x60;dd&#x60;-event
                                *        to inform which nodes are related to the draggable node and should be dragged as well.
                                * @param [e.relativeDragNodes] {NodeList} an optional list that holds the HtmlElements that corresponds with
                                *        the &#x60;e.relative&#x60; list, but is a list with draggable Elements.
                                * @since 0.1
                                */
                                Event.emit(dropzone, emitterName+&#x27;:&#x27;+DROPZONE_OVER, e);
                            }
                        }
                    }
                );
                overDropzone || (e.dropTarget=null);
            });
        },

       /**
         * Emits a dropzone-drop event.
         *
         * @method _emitDropzoneDrop
         * @param e {Object} eventobject to pass arround
         * @private
         * @since 0.0.1
         */
        _emitDropzoneDrop: function(e) {
            /**
            * Emitted when a draggable gets dropped inside a dropzone.
            *
            * @event *:dropzone-drop
            * @param e {Object} eventobject including:
            * @param e.target {HtmlElement} the dropzone
            * @param e.dragNode {HtmlElement} The HtmlElement that is being dragged
            * @param e.dropzone {Promise} The Promise that gets fulfilled as soon as the draggable is dropped, or outside the dropzone
            *        Will fulfill with one argument: &#x60;onDropzone&#x60; {Boolean} when &#x60;true&#x60;, the draggable is dropped inside the dropzone, otherwise
            *        the draggable got outside the dropzone without beging dropped.
            * @param e.dropTarget {HtmlElement} The dropzone HtmlElement. Equals e.target
            * @param e.ctrlKey {Boolean} Whether the Ctrl/cmd key is pressed
            * @param e.isCopied {Boolean} Whether the drag is a copy-drag
            * @param [e.sourceNode] {HtmlElement} The original Element. Only when a &#x60;copy&#x60; is made --&gt; e.dragNode is being moved while
            *        e.sourceNode stand at its place.
            * @param e.currentTarget {HtmlElement} the HtmlElement that is delegating the draggable
            * @param e.sourceTarget {HtmlElement} the deepest HtmlElement of the draggable where the mouse lies upon
            * @param e.dd {Promise} Promise that gets fulfilled when dragging is ended. The fullfilled-callback has no arguments.
            * @param e.xMouse {Number} the current x-position in the window-view
            * @param e.yMouse {Number} the current y-position in the window-view
            * @param e.clientX {Number} the current x-position in the window-view
            * @param e.clientY {Number} the current y-position in the window-view
            * @param e.xMouseOrigin {Number} the original x-position in the document when drag started (incl. scrollOffset)
            * @param e.yMouseOrigin {Number} the original y-position in the document when drag started (incl. scrollOffset)
            * @param [e.relatives] {NodeList} an optional list that the user could set in a &#x60;before&#x60;-subscriber of the &#x60;dd&#x60;-event
            *        to inform which nodes are related to the draggable node and should be dragged as well.
            * @param [e.relativeDragNodes] {NodeList} an optional list that holds the HtmlElements that corresponds with
            *        the &#x60;e.relative&#x60; list, but is a list with draggable Elements.
            * @since 0.1
            */
            Event.emit(e.dropTarget, e.emitter+&#x27;:&#x27;+DROPZONE_DROP, e);
        },

      /**
        * Sets the draggable node back to its original position
        *
        * @method _handleDrop
        * @param e {Object} eventobject
        * @param sourceNode {HtmlElement} the original HtmlElement
        * @param dragNode {HtmlElement} the dragged HtmlElement (either original or clone)
        * @param relatives {Array} hash with all draggables that are being move togerther with the master draggable
        * @private
        * @since 0.0.1
        */
        _handleDrop: function(e, sourceNode, dragNode, relatives) {
            console.log(NAME, &#x27;_handleDrop &#x27;+dragNode);
            var instance = this,
                dropzoneNode = e.dropTarget,
                delegatedDragging = sourceNode.hasClass(DEL_DRAGGABLE),
                constrainRectangle, borderLeft, borderTop, dragNodeX, dragNodeY, copyToDropzone, moveToDropzone,
                moveInsideDropzone, isCopied, dropzoneDelegatedDraggable, dropzoneIsDelegated;
            if (dropzoneNode) {
                dropzoneDelegatedDraggable = dropzoneNode.getAttr(DD_MINUSDRAGGABLE);
                dropzoneIsDelegated = dropzoneDelegatedDraggable &amp;&amp; (dropzoneNode.getAttr(DD_MINUSDRAGGABLE)!==&#x27;true&#x27;);
                copyToDropzone = function(nodeSource, nodeDrag, shiftX, shiftY) {
                    if (delegatedDragging) {
                        dropzoneIsDelegated || nodeDrag.setAttr(DD_MINUSDRAGGABLE, TRUE);
                        nodeDrag.removeClass(DEL_DRAGGABLE);
                    }
                    PLUGIN_ATTRS.forEach(function(attribute) {
                        var data = &#x27;_del_&#x27;+attribute,
                            attr = sourceNode.getData(data);
                        if (attr) {
                            if (dropzoneIsDelegated) {
                                nodeDrag.removeAttr(attribute);
                            }
                            else {
                                nodeDrag.setAttr(attribute, attr);
                            }
                            nodeSource.removeAttr(attribute);
                            nodeSource.removeData(data);
                            nodeDrag.removeData(data);
                        }
                    });
                    dropzoneNode.append(nodeDrag);
                    nodeDrag.removeClass([DD_OPACITY_CLASS, DD_TRANSITION_CLASS, HIGH_Z_CLASS, DD_DRAGGING_CLASS, NO_TRANS_CLASS, DD_MASTER_CLASS, DD_COPIED_CLASS]);
                    nodeSource.removeClass(DD_SOURCE_ISCOPIED_CLASS);
                    nodeDrag.setXY(dragNodeX+shiftX, dragNodeY+shiftY, constrainRectangle, true);
                    // make the new HtmlElement non-copyable: it only can be replaced inside its dropzone
                    dropzoneIsDelegated || nodeDrag.setAttr(DD_EFFECT_ALLOWED, MOVE).setAttr(DD_DROPZONE_MOVABLE, TRUE); // to make moving inside the dropzone possible without return to its startposition
                };
                moveToDropzone = function(nodeSource, nodeDrag, shiftX, shiftY) {
                    nodeSource.setInlineStyle(POSITION, ABSOLUTE);
                    if (delegatedDragging) {
                        dropzoneIsDelegated || nodeSource.setAttr(DD_MINUSDRAGGABLE, TRUE);
                        nodeSource.removeClass(DEL_DRAGGABLE);
                    }
                    PLUGIN_ATTRS.forEach(function(attribute) {
                        var data = &#x27;_del_&#x27;+attribute,
                            attr = sourceNode.getData(data);
                        if (attr) {
                            if (dropzoneIsDelegated) {
                                nodeSource.removeAttr(attribute);
                            }
                            else {
                                nodeSource.setAttr(attribute, attr);
                            }
                            nodeSource.removeData(data);
                        }
                    });
                    dropzoneNode.append(nodeSource);
                    nodeSource.setXY(dragNodeX+shiftX, dragNodeY+shiftY, constrainRectangle, true);
                    // make the new HtmlElement non-copyable: it only can be replaced inside its dropzone
                    dropzoneIsDelegated || nodeSource.setAttr(DD_EFFECT_ALLOWED, MOVE).setAttr(DD_DROPZONE_MOVABLE, TRUE); // to make moving inside the dropzone possible without return to its startposition
                    nodeSource.removeClass(DD_HIDDEN_SOURCE_CLASS);
                    nodeDrag.remove();
                };
                // reset its position, only now constrain it to the dropzondenode
                // we need to specify exactly the droparea: because we don&#x27;t want to compare to any
                // scrollWidth/scrollHeight, but exaclty to the visible part of the dropzone
                borderLeft = parseInt(dropzoneNode.getStyle(BORDER_LEFT_WIDTH), 10);
                borderTop = parseInt(dropzoneNode.getStyle(BORDER_TOP_WIDTH), 10);
                constrainRectangle = {
                    x: dropzoneNode.left + borderLeft,
                    y: dropzoneNode.top + borderTop,
                    w: dropzoneNode.offsetWidth - borderLeft - parseInt(dropzoneNode.getStyle(BORDER_RIGHT_WIDTH), 10),
                    h: dropzoneNode.offsetHeight - borderTop - parseInt(dropzoneNode.getStyle(BORDER_BOTTOM_WIDTH), 10)
                };
                isCopied = (ctrlPressed &amp;&amp; instance.allowCopy(dragNode)) || instance.onlyCopy(dragNode);
                if (isCopied) {
                    // backup x,y before move it into dropzone (which leads to new x,y)
                    dragNodeX = dragNode.left;
                    dragNodeY = dragNode.top;
                    // now move the dragNode into dropzone
                    relatives &amp;&amp; relatives.forEach(
                        function(item) {
                            (dragNode!==item.dragNode) &amp;&amp; copyToDropzone(item.sourceNode, item.dragNode, item.shiftX, item.shiftY);
                        }
                    );
                    copyToDropzone(sourceNode, dragNode, 0 ,0);
                }
                else {
                    dragNodeX = dragNode.left;
                    dragNodeY = dragNode.top;
                    relatives &amp;&amp; relatives.forEach(
                        function(item) {
                           (dragNode!==item.dragNode) &amp;&amp; moveToDropzone(item.sourceNode, item.dragNode, item.shiftX, item.shiftY);
                        }
                    );
                    moveToDropzone(sourceNode, dragNode, 0, 0);
                }

                sourceNode.removeClass(DEL_DRAGGABLE);
                instance._emitDropzoneDrop(e);
            }
            else {
                (dragNode.hasAttr(DD_DROPZONE_MOVABLE)) &amp;&amp; (dropzoneNode=dragNode.inside(DROPZONE_BRACKETS));
                if (dropzoneNode &amp;&amp; dragNode.rectangleInside(dropzoneNode)) {
                    moveInsideDropzone = function(hasMatch, nodeSource, nodeDrag, shiftX, shiftY) {
                        hasMatch &amp;&amp; nodeSource.setXY(nodeSource+shiftX, nodeSource+shiftY, constrainRectangle, true);
                        if (delegatedDragging) {
                            nodeSource.removeClass(DEL_DRAGGABLE);
                        }
                        PLUGIN_ATTRS.forEach(function(attribute) {
                            var data = &#x27;_del_&#x27;+attribute,
                                attr = dragNode.getData(data);
                            if (attr) {
                                if (dropzoneIsDelegated) {
                                    nodeSource.removeAttr(attribute);
                                }
                                else {
                                    nodeSource.setAttr(attribute, attr);
                                }
                                nodeSource.removeData(data);
                            }
                        });
                        nodeSource.removeClass(DD_HIDDEN_SOURCE_CLASS);
                        nodeDrag.remove();
                    };
                    // reset its position, only now constrain it to the dropzondenode
                    // we need to specify exactly the droparea: because we don&#x27;t want to compare to any
                    // scrollWidth/scrollHeight, but exaclty to the visible part of the dropzone
                    dropzoneDelegatedDraggable = dropzoneNode.getAttr(DD_MINUSDRAGGABLE);
                    dropzoneIsDelegated = dropzoneDelegatedDraggable &amp;&amp; (dropzoneNode.getAttr(DD_MINUSDRAGGABLE)!==&#x27;true&#x27;);
                    borderLeft = parseInt(dropzoneNode.getStyle(BORDER_LEFT_WIDTH), 10);
                    borderTop = parseInt(dropzoneNode.getStyle(BORDER_TOP_WIDTH), 10);
                    constrainRectangle = {
                        x: dropzoneNode.left + borderLeft,
                        y: dropzoneNode.top + borderTop,
                        w: dropzoneNode.offsetWidth - borderLeft - parseInt(dropzoneNode.getStyle(BORDER_RIGHT_WIDTH), 10),
                        h: dropzoneNode.offsetHeight - borderTop - parseInt(dropzoneNode.getStyle(BORDER_BOTTOM_WIDTH), 10)
                    };
                    dragNodeX = dragNode.left;
                    dragNodeY = dragNode.top;
                    relatives &amp;&amp; relatives.forEach(
                        function(item) {
                            (sourceNode!==item.sourceNode) &amp;&amp; moveInsideDropzone(dropzoneNode, item.sourceNode, item.dragNode, item.shiftX, item.shiftY);
                        }
                    );
                    moveInsideDropzone(dropzoneNode, sourceNode, dragNode, 0, 0);
                }
                else {
                    instance.restoreDraggables();
                }
            }
            sourceNode.removeClass(DD_MASTER_CLASS);
            dragNode.removeClass(DD_MASTER_CLASS);
        },

       /**
         * Sets the draggable items back to their original place. Should only be used when you prevent the default-function of &#x60;dd-drop&#x60;,
         * so you can choose to do set the draggables back conditionally.
         *
         * @method _restoreDraggables
         * @param e {Object} eventobject
         * @param sourceNode {HtmlElement} the original HtmlElement
         * @param dragNode {HtmlElement} the dragged HtmlElement (either original or clone)
         * @param dropzoneSpecified {Boolean} whether the sourceNode had a dropzone specified
         * @param x {Number} x-position in coordinaties relative to &#x60;document&#x60; (like getX())
         * @param y {Number} y-position in coordinaties relative to &#x60;document&#x60; (like getX())
         * @param inlineLeft {String} inline css &#x60;left&#x60; for the original sourceNode
         * @param inlineTop {String} inline css &#x60;top&#x60; for the original sourceNode
         * @param relatives {Array} hash with all draggables that are being move togerther with the master draggable
         * @private
         * @since 0.0.1
         */
        _restoreDraggables: function(e, ddProps) {
            console.log(NAME, &#x27;_restoreDraggables&#x27;);
            var instance = this,
                sourceNode = ddProps.sourceNode,
                dragNode = ddProps.dragNode,
                dropzoneSpecified = ddProps.dropzoneSpecified,
                x = ddProps.x,
                y = ddProps.y,
                inlineLeft = ddProps.inlineLeft,
                inlineTop = ddProps.inlineTop,
                relatives = ddProps.relatives;
            instance.restoreDraggables = function() {/* NOOP */ return this;};
            instance._setBack(e, sourceNode, dragNode, dropzoneSpecified, x, y, inlineLeft, inlineTop, e.dropzone);
            relatives &amp;&amp; relatives.forEach(
                function(item) {
                    (dragNode!==item.dragNode) &amp;&amp; instance._setBack(e, item.sourceNode, item.dragNode, dropzoneSpecified, x+item.shiftX, y+item.shiftY, item.inlineLeft, item.inlineTop);
                }
            );
            return instance;
        },

      /**
        * Sets the draggable node back to its original position
        *
        * @method _setBack
        * @param sourceNode {HtmlElement} the original HtmlElement
        * @param dragNode {HtmlElement} the dragged HtmlElement (either original or clone)
        * @param dropzoneSpecified {Boolean} whether the sourceNode had a dropzone specified
        * @param x {Number} x-position in coordinaties relative to &#x60;document&#x60; (like getX())
        * @param y {Number} y-position in coordinaties relative to &#x60;document&#x60; (like getX())
        * @param inlineLeft {String} inline css &#x60;left&#x60; for the original sourceNode
        * @param inlineTop {String} inline css &#x60;top&#x60; for the original sourceNode
        * @param [emitDropzoneEvent] {Boolean} whether dropzone-event should be emitted
        * @private
        * @since 0.0.1
        */
        _setBack: function(e, sourceNode, dragNode, dropzoneSpecified, x, y, inlineLeft, inlineTop, emitDropzoneEvent) {
            console.log(NAME, &#x27;_setBack to &#x27;+x+&#x27;, &#x27;+y);
            var tearedDown,
                winScrollTop,
                winScrollLeft,
                dropzones,
                tearDown = function() {
                    // dragNode might be gone when this method is called for the second time
                    // therefor check its existance:
                    if (!tearedDown) {
                        tearedDown = true;
// notransRemoval || (dragNode.removeEventListener &amp;&amp; dragNode.removeEventListener(TRANS_END, tearDown, true));
                        if (dropzoneSpecified) {
                            sourceNode.removeClass([DD_HIDDEN_SOURCE_CLASS, DEL_DRAGGABLE, DD_MASTER_CLASS, DD_SOURCE_ISCOPIED_CLASS]);
                            dragNode.remove();
                        }
                        else {
                            dragNode.removeClass([DD_TRANSITION_CLASS, HIGH_Z_CLASS, DD_DRAGGING_CLASS, DEL_DRAGGABLE, DD_MASTER_CLASS, DD_SOURCE_ISCOPIED_CLASS]);
                            dragNode.setInlineStyle(LEFT, inlineLeft)
                                    .setInlineStyle(TOP, inlineTop);
                        }
                        PLUGIN_ATTRS.forEach(function(attribute) {
                            var data = &#x27;_del_&#x27;+attribute;
                            if (sourceNode.getData(data)) {
                                sourceNode.removeAttr(attribute)
                                          .removeData(data);
                            }
                        });
                    }
                };
            dragNode.removeClass([NO_TRANS_CLASS, DD_DRAGGING_CLASS]);
            dragNode.setClass(DD_TRANSITION_CLASS);
            // transitions only work with IE10+, and that browser has addEventListener
            // when it doesn&#x27;t have, it doesn;t harm to leave the transitionclass on: it would work anyway
            // nevertheless we will remove it with a timeout
// if (dragNode.addEventListener) {
    // dragNode.addEventListener(TRANS_END, tearDown, true);
// }
// ALWAYS tearDowm after delay --&gt; when there was no repositioning, there never will be a transition-event
// LATER(tearDown, 260);
            dragNode.setXY(x, y).finally(tearDown);
            // now we might need to fire a last &#x60;dropzone&#x60; event when the dragged element returns to a dropzone when it wasn&#x27;t before set it back
            if (emitDropzoneEvent) {
                dropzones = DOCUMENT.getAll(DROPZONE_BRACKETS);
                if (dropzones) {
                    winScrollTop = window.getScrollTop();
                    winScrollLeft = window.getScrollLeft();
                    dropzones.forEach(
                        function(dropzone) {
                            if (dropzone.insidePos(x, y) &amp;&amp; !dropzone.insidePos(e.xMouse+winScrollLeft, e.yMouse+winScrollTop)) {
                                e.dropTarget = dropzone;
                                e._noDDoutEvt = true;
                                Event.emit(dropzone, e.emitter+&#x27;:&#x27;+DROPZONE_OVER, e);
                            }
                        }
                    );
                }
            }
        },

      /**
        * Sets up a &#x60;keydown&#x60; and &#x60;keyup&#x60; listener, to monitor whether a &#x60;ctrlKey&#x60; (windows) or &#x60;metaKey&#x60; (Mac)
        * is pressed to support the copying of draggable items
        *
        * @method _setupKeyEv
        * @private
        * @since 0.0.1
        */
        _setupKeyEv: function() {
            console.log(NAME, &#x27;_setupKeyEv&#x27;);
            var instance = this,
                changeClasses = function(sourceNode, dragNode) {
                    sourceNode.toggleClass(DD_HIDDEN_SOURCE_CLASS, !ctrlPressed);
                    sourceNode.toggleClass(DD_SOURCE_ISCOPIED_CLASS, ctrlPressed);
                    dragNode.toggleClass([DD_OPACITY_CLASS, DD_COPIED_CLASS], ctrlPressed);
                };
            Event.after([KEY+DOWN, KEY+UP], function(e) {
                console.log(NAME, &#x27;event &#x27;+e.type);
                var ddProps = instance.ddProps,
                    sourceNode = ddProps.sourceNode,
                    dragNode, mouseOverNode;
                ctrlPressed = e.ctrlKey || e.metaKey;
                if (sourceNode &amp;&amp; instance.allowSwitch(sourceNode)) {
                    dragNode = ddProps.dragNode;
                    mouseOverNode = ddProps.mouseOverNode;
                    dropEffect = ctrlPressed ? COPY : MOVE;
                    changeClasses(sourceNode, dragNode);
                    ddProps.relatives &amp;&amp; ddProps.relatives.forEach(
                        function(item) {
                            changeClasses(item.sourceNode, item.dragNode);
                        }
                    );
                    // now, it could be that any droptarget should change its appearance (DD_DROPACTIVE_CLASS).
                    // we need to recalculate it for all targets
                    // we do this by emitting a DD_FAKE_MOUSEMOVE event
                    /**
                    * Fired when the mouse comes back into the browser-window while dd-drag was busy yet no buttons are pressed.
                    * This is a correction to the fact that the mouseup-event wasn&#x27;t noticed because the mouse was outside the browser.
                    *
                    * @event dd-fake-mousemove
                    * @private
                    * @since 0.1
                    */
                    mouseOverNode &amp;&amp; Event.emit(mouseOverNode, UI+&#x27;:&#x27;+DD_FAKE_MOUSEMOVE);
                }
            });
        },

      /**
        * Cleansup the dragover subscriber and fulfills any dropzone-promise.
        *
        * @method _teardownOverEvent
        * @param e {Object} eventobject
        * @private
        * @since 0.0.1
        */
        _teardownOverEvent: function(e, ddProps) {
            console.log(&#x27;_teardownOverEvent&#x27;);
            var dragOverEvent = ddProps.dragOverEv,
                mouseX = e.xMouse,
                mouseY = e.yMouse,
                winScrollTop, winScrollLeft;
            if (dragOverEvent) {
                dragOverEvent.detach();
                winScrollTop = window.getScrollTop();
                winScrollLeft = window.getScrollLeft();
                ddProps.dragOverList.forEach(function(promise) {
                    promise.fulfill(e.dropTarget &amp;&amp; e.dropTarget.insidePos(mouseX+winScrollLeft, mouseY+winScrollTop));
                });
            }
        },

       /**
         * Returns true if the dropzone-HtmlElement accepts copy-dragables.
         * Is determined by the attribute &#x60;dd-effect-allowed=&quot;copy&quot;&#x60; or &#x60;dd-effect-allowed=&quot;all&quot;&#x60;
         *
         * @method allowCopy
         * @param dropzone {HtmlElement} HtmlElement that is checked for its allowed effects
         * @return {Boolean} if copy-dragables are allowed
         * @since 0.0.1
         */
        allowCopy: function(dropzone) {
            var allowedEffects = this._allowedEffects(dropzone);
            console.log(&#x27;allowCopy --&gt; &#x27;+REGEXP_ALL.test(allowedEffects) || REGEXP_COPY.test(allowedEffects));
            return REGEXP_ALL.test(allowedEffects) || REGEXP_COPY.test(allowedEffects);
        },

       /**
         * Returns true if the dragable-HtmlElement allowes to switch between &#x60;copy&#x60; and &#x60;move&#x60;.
         *
         * @method allowSwitch
         * @param dragableElement {HtmlElement} HtmlElement that is checked for its allowed effects
         * @return {Boolean} if copy-dragables are allowed
         * @since 0.0.1
         */
        allowSwitch: function(dragableElement) {
            console.log(&#x27;allowSwitch --&gt; &#x27;+REGEXP_ALL.test(this._allowedEffects(dragableElement)));
            return REGEXP_ALL.test(this._allowedEffects(dragableElement));
        },

       /**
         * Returns the emitterName that the dropzone accepts.
         *
         * @method getDropzoneEmitter
         * @param dropzone {String} dropzone attribute of the dropzone HtmlElement
         * @return {String|null} the emitterName that is accepted
         * @since 0.0.1
         */
        getDropzoneEmitter: function(dropzone) {
            var extract = dropzone.match(REGEXP_EMITTER);
            console.log(&#x27;getDropzoneEmitter --&gt; &#x27;+(extract &amp;&amp; extract[1]));
            return extract &amp;&amp; (&#x27;,&#x27;+extract[1]+&#x27;,&#x27;);
        },

       /**
         * Initializes dragdrop. Needs to be invoked, otherwise DD won&#x27;t run.
         *
         * @method init (extended by drag-drop)
         * @param dragableElement {HtmlElement} HtmlElement that is checked for its allowed effects
         * @return {Boolean} if copy-dragables are allowed
         * @since 0.0.1
         */
        init: function() {
            console.log(NAME, &#x27;init&#x27;);
            var instance = this;
            if (!instance._ddInited) {
                // we will initialize &#x60;Drag&#x60; --&gt; don;t worry if it was initialised before,
                // Drag.init() will only run once
                $superInit.call(instance);
                instance._setupKeyEv();

                instance.notify(function(e, ddProps) {
                    var dropzones, sourceNode,
                        dragNode = ddProps.dragNode,
                        dropzoneSpecified = ddProps.dropzoneSpecified = dragNode.hasAttr(DD_DROPZONE) || dragNode.hasAttr(DD_EMITTER) || (e.emitter!==UI),
                        setupDragnode = function(nodeSource, nodeDrag, shiftX, shiftY) {
                            if (dropEffect===COPY) {
                                nodeDrag.setClass([DD_OPACITY_CLASS, DD_COPIED_CLASS]);
                                nodeSource.setClass(DD_SOURCE_ISCOPIED_CLASS);
                            }
                            else {
                                nodeSource.setClass(DD_HIDDEN_SOURCE_CLASS);
                            }
                            nodeDrag.setClass(INVISIBLE_CLASS);
                            nodeDrag.setInlineStyle(POSITION, ABSOLUTE);
                            nodeSource.parentNode.append(nodeDrag, false, nodeSource);
                            nodeDrag.setXY(ddProps.xMouseLast+shiftX, ddProps.yMouseLast+shiftY, ddProps.constrain, true);
                            nodeDrag.removeClass(INVISIBLE_CLASS);
                        };
                    if (dropzoneSpecified) {
                        sourceNode = e.sourceNode = ddProps.sourceNode = ddProps.dragNode;
                        e.dragNode = ddProps.dragNode = ddProps.sourceNode.cloneNode(true);
                        // correct sourceNode class: reset CSS set by &#x60;drag&#x60;:
                        sourceNode.removeClass([NO_TRANS_CLASS, HIGH_Z_CLASS, DD_DRAGGING_CLASS]);
                        // also correct inline CSS style for &#x60;left&#x60; and &#x60;top&#x60; of the sourceNode:
                        sourceNode.setInlineStyle(LEFT, ddProps.inlineLeft);
                        sourceNode.setInlineStyle(TOP, ddProps.inlineTop);

                        dropEffect = (instance.onlyCopy(dragNode) || (ctrlPressed &amp;&amp; instance.allowCopy(dragNode))) ? COPY : MOVE;
                        setupDragnode(ddProps.sourceNode, ddProps.dragNode, 0, 0);
                        if (ddProps.relatives) {
                            e.relativeDragNodes = [];
                            ddProps.relatives.forEach(
                                function(item) {
                                    item.sourceNode = item.dragNode;
                                    item.dragNode = item.dragNode.cloneNode(true);
                                    setupDragnode(item.sourceNode, item.dragNode, item.shiftX, item.shiftY);
                                    e.relativeDragNodes.push(item.dragNode);
                                }
                            );
                        }
                        dropzones = DOCUMENT.getAll(DROPZONE_BRACKETS);
                        if (dropzones.length&gt;0) {
                            // create a custom over-event that fires exactly when the mouse is over any dropzone
                            // we cannot use &#x60;hover&#x60;, because that event fails when there is an absolute floated element outsize &#x60;dropzone&#x60;
                            // lying on top of the dropzone. -&gt; we need to check by cordinates
                            ddProps.dragOverEv = instance._defineOverEv(e, dropzones);

                        }
                    }
                    else {
                        e.dragNode = ddProps.dragNode;
                    }
                    ddProps.dragDropEv = instance._defineDropEv(e, ddProps);
                }, instance, true);

                instance.notify(instance._teardownOverEvent, instance);

            }
            instance._ddInited = true;
        },

       /**
         * Returns true if the dragable-HtmlElement accepts only copy-dragables (no moveable)
         * Is determined by the attribute &#x60;dd-effect-allowed=&quot;copy&quot;&#x60;
         *
         * @method onlyCopy
         * @param dragableElement {HtmlElement} HtmlElement that is checked for its allowed effects
         * @return {Boolean} if only copy-dragables are allowed
         * @since 0.0.1
         */
        onlyCopy: function(dragableElement) {
            console.log(&#x27;onlyCopy --&gt; &#x27;+REGEXP_COPY.test(this._allowedEffects(dragableElement)));
            return REGEXP_COPY.test(this._allowedEffects(dragableElement));
        },

       /**
         * Sets the draggable items back to their original place. Should only be used when you prevent the default-function of &#x60;dd-drop&#x60;,
         * so you can choose to do set the draggables back conditionally.
         *
         * @method restoreDraggables
         * @private
         * @chainable
         * @since 0.0.1
         */
        restoreDraggables: function() {/* NOOP */ return this;}

    };

    DD_Object = window._ITSAmodules.DragDrop = {
        DD: DragModule.DD.merge(DD, true),
        Plugins: {
            nodeDD: DragModule.Plugins.nodeDD,
            nodeDropzone: nodePlugin.definePlugin(&#x27;dd&#x27;, {dropzone: &#x27;true&#x27;})
        }
    };

    return DD_Object;

};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
