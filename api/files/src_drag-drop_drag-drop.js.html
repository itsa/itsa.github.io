<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/drag-drop/drag-drop.js - Itsa</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Itsa"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/document.html">document</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/NodeList.html">NodeList</a></li>
            
                <li><a href="../classes/NodePlugin.html">NodePlugin</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/String.html">String</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/dom-ext.html">dom-ext</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-dragdrop.html">event-dragdrop</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-hover.html">event-hover</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/event-mobile.html">event-mobile</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/itsa.build.html">itsa.build</a></li>
            
                <li><a href="../modules/js-ext.html">js-ext</a></li>
            
                <li><a href="../modules/lib_array.js.html">lib/array.js</a></li>
            
                <li><a href="../modules/lib_document.js.html">lib/document.js</a></li>
            
                <li><a href="../modules/lib_element-plugin.js.html">lib/element-plugin.js</a></li>
            
                <li><a href="../modules/lib_element.js.html">lib/element.js</a></li>
            
                <li><a href="../modules/lib_function.js.html">lib/function.js</a></li>
            
                <li><a href="../modules/lib_nodelist.js.html">lib/nodelist.js</a></li>
            
                <li><a href="../modules/lib_object.js.html">lib/object.js</a></li>
            
                <li><a href="../modules/lib_promise.s.html">lib/promise.s</a></li>
            
                <li><a href="../modules/lib_string.js.html">lib/string.js</a></li>
            
                <li><a href="../modules/node-win.html">node-win</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/drag-drop/drag-drop.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;

/**
 * Adds the &#x60;hover&#x60; event as a DOM-event to event-dom. more about DOM-events:
 * http://www.smashingmagazine.com/2013/11/12/an-introduction-to-dom-events/
 *
 * More about drag and drop: https://dev.opera.com/articles/drag-and-drop/
 *
 *
 * &lt;i&gt;Copyright (c) 2014 ITSA - https://github.com/itsa&lt;/i&gt;
 * New BSD License - http://choosealicense.com/licenses/bsd-3-clause/
 *
 * @example
 * Event = require(&#x27;event-dom/dragdrop.js&#x27;)(window);
 *
 * or
 *
 * @example
 * Event = require(&#x27;event-dom&#x27;)(window);
 * require(&#x27;event-dom/event-dragdrop.js&#x27;)(window);
 *
 * @module event
 * @submodule event-dragdrop
 * @class Event
 * @since 0.0.2
*/


var NAME = &#x27;[dragdrop]: &#x27;,
    DRAGGABLE = &#x27;draggable&#x27;,
    DD_DRAGGING_CLASS = &#x27;dd-dragging&#x27;,
    CONSTRAIN_ATTR = &#x27;xy-constrain&#x27;,
    PROXY = &#x27;proxy&#x27;,
    MOUSE = &#x27;mouse&#x27;,
    DATA_KEY = &#x27;dragDrop&#x27;,
    DD_EFFECT_ALLOWED = &#x27;dd-effect-allowed&#x27;,
    DD_DROPZONE = &#x27;dd-dropzone&#x27;,
    NO_TRANS_CLASS = &#x27;el-notrans&#x27;, // delivered by &#x60;dom-ext&#x60;
    INVISIBLE_CLASS = &#x27;el-invisible&#x27;, // delivered by &#x60;dom-ext&#x60;
    DD_TRANSITION_CLASS = &#x27;dd-transition&#x27;,
    DD_OPACITY_CLASS = &#x27;dd-opacity&#x27;,
    HIGH_Z_CLASS = &#x27;dd-high-z&#x27;,
    DD_DROPACTIVE_CLASS = &#x27;dropactive&#x27;,
    REGEXP_MOVE = /\bmove\b/i,
    REGEXP_COPY = /\bcopy\b/i,
    REGEXP_NODE_ID = /^#\S+$/,
    REGEXP_ALL = /\ball\b/i,
    REGEXP_COPY = /\bcopy\b/i,
    REGEXP_EMITTER = /\bemitter=(\w+)\b/,
    LATER = require(&#x27;utils&#x27;).later;

require(&#x27;polyfill/polyfill-base.js&#x27;);
require(&#x27;js-ext&#x27;);
require(&#x27;./css/drag-drop.css&#x27;);

module.exports = function (window) {
    var Event = require(&#x27;event-dom&#x27;)(window),
        NodePlugin = require(&#x27;dom-ext&#x27;)(window).Plugins.NodePlugin,
        ctrlPressed = false,
        initialised = false,
        dropEffect = &#x27;move&#x27;,
        DD, NodeDD, NodeDropzone;

    require(&#x27;window-ext&#x27;)(window);

    DD = {
       ddProps: {},
      /**
        * Returns the allowed effects on the dragable-HtmlElement. Is determined by the attribute &#x60;dd-effect-allowed&#x60;
        * Will be set to &quot;move&quot; when undefined.
        *
        * @method _allowedEffects
        * @param dragableElement {HtmlElement} HtmlElement that is checked for its allowed effects
        * @return {String} allowed effects: &quot;move&quot;, &quot;copy&quot; or &quot;all&quot;
        * @private
        * @since 0.0.1
        */
        _allowedEffects: function(dragableElement) {
console.info(NAME, &#x27;_allowedEffects&#x27;);
            var allowedEffects = dragableElement.getAttr(DD_EFFECT_ALLOWED);
            return allowedEffects || &#x27;move&#x27;;
        },

        /**
        * Default function for the &#x60;*:dd-drag&#x60;-event
        *
        * @method _defFnDrag
        * @param e {Object} eventobject
        * @private
        * @since 0.0.1
        */
        _defFnDrag: function(e) {
// console.info(NAME, &#x27;_defFnDrag: default function dd-drag&#x27;);
            var ddProps = this.ddProps,
                dragNode = ddProps.dragNode,
                constrainNode = ddProps.constrainNode,
                winConstrained = ddProps.winConstrained;
            // is the drag is finished, there will be no ddProps.defined
            // return then, to prevent any events that stayed behind
            if (!ddProps.defined) {
                return;
            }

            // caution: the user might have put the mouse out of the screen and released the mousebutton!
            // If that is the case, the a mouseup-event should be initiated instead of draggin the element
            if (e.buttons===0) {
                // no more button pressed
                Event.emit(dragNode, &#x27;dd-fake-mouseup&#x27;);
            }
            else {
// console.info(NAME, &#x27;_defFnDrag: dragging:&#x27;);
                if (constrainNode) {
                    ddProps.constrain.x = ddProps.constrain.xOrig - constrainNode.getScrollLeft();
                    ddProps.constrain.y = ddProps.constrain.yOrig - constrainNode.getScrollTop();
                }
                dragNode.setXY(ddProps.x+e.xMouse+(winConstrained ? ddProps.winScrollLeft : window.getScrollLeft())-e.xMouseOrigin, ddProps.y+e.yMouse+(winConstrained ? ddProps.winScrollTop : window.getScrollTop())-e.yMouseOrigin, ddProps.constrain, true);
                ddProps.winConstrained || dragNode.forceIntoView(true);
                constrainNode &amp;&amp; dragNode.forceIntoNodeView(constrainNode);
            }
        },

        /**
         * Default function for the &#x60;*:dd-drop&#x60;-event
         *
         * @method _defFnDrag
         * @param e {Object} eventobject
         * @param sourceNode {HtmlElement} the original HtmlElement
         * @param dragNode {HtmlElement} the dragged HtmlElement (either original or clone)
         * @param dropzoneSpecified {Boolean} whether the sourceNode had a dropzone specified
         * @param x {Number} x-position in coordinaties relative to &#x60;document&#x60; (like getX())
         * @param y {Number} y-position in coordinaties relative to &#x60;document&#x60; (like getX())
         * @private
         * @since 0.0.1
         */
        _defFnDrop: function(e, sourceNode, dragNode, dropzoneSpecified, x, y) {
console.info(NAME, &#x27;_defFnDrop: default function dd-drop. dropzoneSpecified: &#x27;+dropzoneSpecified);
            // handle drop
            if (dropzoneSpecified) {
                this._handleDrop(e, sourceNode, dragNode, dropzoneSpecified, x, y);
            }
            else {
                dragNode.removeClass(NO_TRANS_CLASS).removeClass(HIGH_Z_CLASS).removeClass(DD_DRAGGING_CLASS);
            }
        },

       /**
         * Default function for the &#x60;*:dd-over&#x60;-event
         *
         * @method _defFnOver
         * @param e {Object} eventobject
         * @private
         * @since 0.0.1
         */
        _defFnOver: function(e) {
console.info(NAME, &#x27;_defFnOver: default function dd-over&#x27;);
            var dropzone = e.target;
            dropzone.setClass(DD_DROPACTIVE_CLASS);
            e.over.then(
                function() {
                    dropzone.removeClass(DD_DROPACTIVE_CLASS);
                }
            );
        },

        /**
         * Default function for the &#x60;UI:dd-start&#x60;-event
         *
         * @method _defFnDrag
         * @param e {Object} eventobject
         * @private
         * @since 0.0.1
         */
        _defFnStart: function(e) {
            var instance = this,
                customEvent;
            e.emitterName = e.emitterName || e.target.getAttr(&#x27;dd-emitter-name&#x27;) || &#x27;UI&#x27;,
            customEvent = e.emitterName + &#x27;:dd-drag&#x27;;
console.info(NAME, &#x27;_defFnStart: default function UI:dd-start. Defining customEvent &#x27;+customEvent);
            Event.defineEvent(customEvent).defaultFn(instance._defFnDrag.bind(instance));
            instance._initializeDrag(e);
        },

      /**
        * Defines the definition of the &#x60;dd-start&#x60; event: the first phase of the drag-eventcycle (dd-start, *:dd-drag, *:dd-drop)
        *
        * @method _defineDDStart
        * @param e {Object} eventobject
        * @private
        * @since 0.0.1
        */
        _defineDDStart: function() {
console.info(NAME, &#x27;_defineDDStart&#x27;);
            var instance = this;
            // by using dd-start before dd-drag, the user can create a &#x60;before&#x60;-subscriber to dd-start
            // and define e.emitterName and/or e.relatives before going into &#x60;dd-drag&#x60;
            Event.defineEvent(&#x27;UI:dd-start&#x27;)
                .defaultFn(instance._defFnStart.bind(instance))
                .preventedFn(instance._prevFnStart.bind(instance));
        },

        /**
         * Defines the definition of the &#x60;dd-drop&#x60; event: the last phase of the drag-eventcycle (dd-start, *:dd-drag, *:dd-drop)
         *
         * @method _defineDropEv
         * @param e {Object} eventobject
         * @param sourceNode {HtmlElement} the original HtmlElement
         * @param dragNode {HtmlElement} the dragged HtmlElement (either original or clone)
         * @param dropzoneSpecified {Boolean} whether the sourceNode had a dropzone specified
         * @param x {Number} x-position in coordinaties relative to &#x60;document&#x60; (like getX())
         * @param y {Number} y-position in coordinaties relative to &#x60;document&#x60; (like getX())
         * @private
         * @since 0.0.1
         */
        _defineDropEv: function(emitterName, sourceNode, dragNode, dropzoneSpecified, x, y) {
console.info(NAME, &#x27;_defineDropEv &#x27;+dragNode);
            var instance = this;
            Event.defineEvent(emitterName+&#x27;:dd-drop&#x27;)
                .defaultFn(instance._defFnDrop.rbind(instance, sourceNode, dragNode, dropzoneSpecified, x, y))
                .forceAssign(); // need to reassign, because all arguments need to be bound again
        },

        /**
         * Defines the definition of the &#x60;dd-over&#x60; event.
         * Also sets up listeners to tricker dd-over when the mouse is above an dropzone.
         *
         * @method _defineOverEv
         * @param e {Object} eventobject
         * @private
         * @since 0.0.1
         */
        _defineOverEv: function(e) {
console.info(NAME, &#x27;_defineOverEv&#x27;);
            var instance = this,
                emitterName = e.emitterName,
                ddProps = instance.ddProps,
                dropzones = window.document.getAll(&#x27;[dropzone]&#x27;);
            if (dropzones.length&gt;0) {
                Event.defineEvent(emitterName+&#x27;:dd-over&#x27;)
                     .defaultFn(instance._defFnOver.bind(instance)); // no need to reassign
                return Event.after([&#x27;mousemove&#x27;, &#x27;dd-fake-mousemove&#x27;], function(e2) {
                    var overDropzone = false;
                    ddProps.mouseOverNode = e.target;
                    dropzones.forEach(
                        function(dropzone) {
                            // don&#x27;t do double:
                            if (dropzone === e.dropTarget) {
                                overDropzone = true;
                                return;
                            }
                            var dropzoneAccept = dropzone.getAttr(&#x27;dropzone&#x27;) || &#x27;&#x27;,
                                dropzoneMove = REGEXP_MOVE.test(dropzoneAccept),
                                dropzoneCopy = REGEXP_COPY.test(dropzoneAccept),
                                dragOverPromise, dragOutEvent, effectAllowed, emitterAllowed, dropzoneEmitter, xMouseLast, yMouseLast;

                            if (e2.clientX) {
                                ddProps.xMouseLast = e2.clientX + window.getScrollLeft();
                                ddProps.yMouseLast = e2.clientY + window.getScrollTop();
                            }

                            // check if the mouse is inside the dropzone
                            // also check if the mouse is inside the dragged node: the dragged node might have been constrained
                            // and check if the dragged node is effectAllowed to go into the dropzone
                            xMouseLast = ddProps.xMouseLast;
                            yMouseLast = ddProps.yMouseLast;

                            if (dropzone.insidePos(xMouseLast, yMouseLast) &amp;&amp; ddProps.dragNode.insidePos(xMouseLast, yMouseLast)) {
                                effectAllowed = (!dropzoneMove &amp;&amp; !dropzoneCopy) || (dropzoneCopy &amp;&amp; (dropEffect===&#x27;copy&#x27;)) || (dropzoneMove &amp;&amp; (dropEffect===&#x27;move&#x27;));
                                dropzoneEmitter = instance.getDropzoneEmitter(dropzoneAccept);
console.warn(dropzoneEmitter+&#x27; | &#x27;+emitterName);
                                emitterAllowed = !dropzoneEmitter || (dropzoneEmitter===emitterName);
console.warn(emitterAllowed);
                                if (effectAllowed &amp;&amp; emitterAllowed) {
                                    overDropzone = true;
                                    e.dropTarget = dropzone;
                                    // mouse is in area of dropzone
                                    dragOverPromise = Promise.manage();
                                    e.over = dragOverPromise;
                                    dragOutEvent = Event.after(
                                        [&#x27;mousemove&#x27;, &#x27;dd-fake-mousemove&#x27;],
                                        function(e3) {
    console.info(NAME, &#x27;outside dropzone: fulfilling promise&#x27;);
                                            dragOverPromise.fulfill(e3.target);
                                        },
                                        function(e3) {
                                            var effectAllowed, dropzoneAccept, dropzoneMove, dropzoneCopy;
                                            if (e3.type===&#x27;dd-fake-mousemove&#x27;) {
                                                dropzoneAccept = dropzone.getAttr(&#x27;dropzone&#x27;) || &#x27;&#x27;;
                                                dropzoneMove = REGEXP_MOVE.test(dropzoneAccept);
                                                dropzoneCopy = REGEXP_COPY.test(dropzoneAccept);
                                                effectAllowed = (!dropzoneMove &amp;&amp; !dropzoneCopy) || (dropzoneCopy &amp;&amp; (dropEffect===&#x27;copy&#x27;)) || (dropzoneMove &amp;&amp; (dropEffect===&#x27;move&#x27;));
                                                return !effectAllowed;
                                            }
                                            return !dropzone.insidePos((e3.clientX || e3.center.x)+window.getScrollLeft(), (e3.clientY || e3.center.y)+window.getScrollTop());
                                        }
                                    );
                                    dragOverPromise.finally(
                                        function() {
                                            dragOutEvent.detach();
                                            e.dropTarget = null;
                                        }
                                    );
                                    ddProps.dragOverList.push(dragOverPromise);
    console.info(NAME, &#x27;Over dropzone: emitting dd-over event&#x27;);
                                    Event.emit(dropzone, emitterName+&#x27;:dd-over&#x27;, e);
                                }
                            }
                        }
                    );
                    overDropzone || (e.dropTarget=null);
                });
            }
        },

      /**
        * Sets the draggable node back to its original position
        *
        * @method _setBack
        * @param e {Object} eventobject
        * @param sourceNode {HtmlElement} the original HtmlElement
        * @param dragNode {HtmlElement} the dragged HtmlElement (either original or clone)
        * @param dropzoneSpecified {Boolean} whether the sourceNode had a dropzone specified
        * @param x {Number} x-position in coordinaties relative to &#x60;document&#x60; (like getX())
        * @param y {Number} y-position in coordinaties relative to &#x60;document&#x60; (like getX())
        * @private
        * @since 0.0.1
        */
        _handleDrop: function(e, sourceNode, dragNode, dropzoneSpecified, x, y) {
console.info(NAME, &#x27;_handleDrop &#x27;+dragNode);
            var instance = this,
                dropzoneNode = e.dropTarget,
                constrainRectangle, borderLeft, borderTop, dragNodeX, dragNodeY, match;
            if (dropzoneNode) {
                // reset its position, only now constrain it to the dropzondenode
                // we need to specify exactly the droparea: because we don&#x27;t want to compare to any
                // scrollWidth/scrollHeight, but exaclty to the visible part of the dropzone
                borderLeft = parseInt(dropzoneNode.getStyle(&#x27;border-left-width&#x27;), 10);
                borderTop = parseInt(dropzoneNode.getStyle(&#x27;border-top-width&#x27;), 10);
                constrainRectangle = {
                    x: dropzoneNode.getX() + borderLeft,
                    y: dropzoneNode.getY() + borderTop,
                    w: dropzoneNode.offsetWidth - borderLeft - parseInt(dropzoneNode.getStyle(&#x27;border-right-width&#x27;), 10),
                    h: dropzoneNode.offsetHeight - borderTop - parseInt(dropzoneNode.getStyle(&#x27;border-bottom-width&#x27;), 10)
                };
                if ((ctrlPressed &amp;&amp; instance.allowCopy(dragNode)) || instance.onlyCopy(dragNode)) {
                    // backup x,y before move it into dropzone (which leads to new x,y)
                    dragNodeX = dragNode.getX();
                    dragNodeY = dragNode.getY();
                    // now move the dragNode into dropzone
                    dropzoneNode.append(dragNode);
                    dragNode.removeClass(DD_OPACITY_CLASS).removeClass(DD_TRANSITION_CLASS).removeClass(HIGH_Z_CLASS).removeClass(DD_DRAGGING_CLASS);
                    dragNode.setXY(dragNodeX, dragNodeY, constrainRectangle);
                    // make the new HtmlElement non-copyable: it only can be replaced inside its dropzone
                    dragNode.setAttr(&#x27;dd-effect-allowed&#x27;, &#x27;move&#x27;)
                            .setAttr(&#x27;dd-copied-node&#x27;, &#x27;true&#x27;); // to make moving inside the dropzone possible without return to its startposition
                }
                else {
                    dropzoneNode.append(sourceNode);
                    sourceNode.setXY(dragNode.getX(), dragNode.getY(), constrainRectangle);
                    sourceNode.removeClass(INVISIBLE_CLASS);
                    dragNode.remove();
                }
            }
            else {
                if (dragNode.hasAttr(&#x27;dd-copied-node&#x27;)) {
                    // reset its position, only now constrain it to the dropzondenode
                    // we need to specify exactly the droparea: because we don&#x27;t want to compare to any
                    // scrollWidth/scrollHeight, but exaclty to the visible part of the dropzone
                    match = false;
                    dropzoneNode = dragNode.parentNode;
                    while (dropzoneNode.matchesSelector &amp;&amp; !match) {
                        match = dropzoneNode.matchesSelector(&#x27;[dropzone]&#x27;);
                        // if there is a match, then make sure x and y fall within the region
                        match || (dropzoneNode=dropzoneNode.parentNode);
                    }
                    if (match) {
                        borderLeft = parseInt(dropzoneNode.getStyle(&#x27;border-left-width&#x27;), 10);
                        borderTop = parseInt(dropzoneNode.getStyle(&#x27;border-top-width&#x27;), 10);
                        constrainRectangle = {
                            x: dropzoneNode.getX() + borderLeft,
                            y: dropzoneNode.getY() + borderTop,
                            w: dropzoneNode.offsetWidth - borderLeft - parseInt(dropzoneNode.getStyle(&#x27;border-right-width&#x27;), 10),
                            h: dropzoneNode.offsetHeight - borderTop - parseInt(dropzoneNode.getStyle(&#x27;border-bottom-width&#x27;), 10)
                        };
                        dragNode.setXY(dragNode.getX(), dragNode.getY(), constrainRectangle);
                    }
                    dragNode.removeClass(DD_OPACITY_CLASS).removeClass(DD_TRANSITION_CLASS).removeClass(HIGH_Z_CLASS).removeClass(DD_DRAGGING_CLASS);
                }
                else {
                    instance._setBack(e, sourceNode, dragNode, dropzoneSpecified, x, y);
                }
            }
        },

       /**
         * Default function for the &#x60;*:dd-drag&#x60;-event
         *
         * @method _initializeDrag
         * @param e {Object} eventobject
         * @private
         * @since 0.0.1
         */
        _initializeDrag: function(e) {
console.info(NAME, &#x27;_initializeDrag &#x27;+e.xMouseOrigin);
            var instance = this,
                sourceNode = e.target,
                constrain = sourceNode.getAttr(CONSTRAIN_ATTR),
                ddProps = instance.ddProps,
                emitterName = e.emitterName,
                dropzoneSpecified = sourceNode.hasAttr(DD_DROPZONE) || (emitterName!==&#x27;UI&#x27;),
                moveEv, dragNode, x, y, byExactId, match, constrainNode, winConstrained, winScrollLeft, winScrollTop,
                inlineLeft, inlineTop, xOrig, yOrig;

            // define ddProps --&gt; internal object with data about the draggable instance
            ddProps.sourceNode = sourceNode;
            ddProps.dragNode = dragNode = dropzoneSpecified ? sourceNode.clone(true) : sourceNode;
            ddProps.x = x = sourceNode.getX();
            ddProps.y = y = sourceNode.getY();
            ddProps.inlineLeft = inlineLeft = sourceNode.getInlineStyle(&#x27;left&#x27;);
            ddProps.inlineTop = inlineTop = sourceNode.getInlineStyle(&#x27;top&#x27;);
            ddProps.dropzoneSpecified = dropzoneSpecified;
            ddProps.winConstrained = winConstrained = (constrain===&#x27;window&#x27;);
            ddProps.xMouseLast = x;
            ddProps.yMouseLast = y;
            if (constrain) {
                if (ddProps.winConstrained) {
                    ddProps.winScrollLeft = winScrollLeft = window.getScrollLeft();
                    ddProps.winScrollTop = winScrollTop = window.getScrollTop();
                    ddProps.constrain = {
                        x: winScrollLeft,
                        y: winScrollTop,
                        w: window.getWidth(),
                        h: window.getHeight()
                    };
                }
                else {
                    byExactId = REGEXP_NODE_ID.test(constrain);
                    constrainNode = sourceNode.parentNode;
                    while (constrainNode.matchesSelector &amp;&amp; !match) {
                        match = byExactId ? (constrainNode.id===constrain.substr(1)) : constrainNode.matchesSelector(constrain);
                        // if there is a match, then make sure x and y fall within the region
                        if (match) {
                            ddProps.constrainNode = constrainNode;
                            xOrig = constrainNode.getX() + parseInt(constrainNode.getStyle(&#x27;border-left-width&#x27;), 10);
                            yOrig = constrainNode.getY() + parseInt(constrainNode.getStyle(&#x27;border-top-width&#x27;), 10);
                            ddProps.constrain = {
                                xOrig: xOrig,
                                yOrig: yOrig,
                                x: xOrig - constrainNode.getScrollLeft(),
                                y: yOrig - constrainNode.getScrollTop(),
                                w: constrainNode.scrollWidth,
                                h: constrainNode.scrollHeight
                            };
                        }
                        else {
                            constrainNode = constrainNode.parentNode;
                        }
                    }
                }
            }

            // create listener for &#x60;mousemove&#x60; and transform it into the &#x60;*:dd:drag&#x60;-event
            moveEv = Event.after(MOUSE+&#x27;move&#x27;, function(e2) {
                if (!e2.clientX &amp;&amp; !e2.center) {
                    return;
                }
                // move the object
                e.xMouse = e2.clientX || e2.center.x;
                e.yMouse = e2.clientY || e2.center.y;
                Event.emit(sourceNode, emitterName+&#x27;:dd-drag&#x27;, e);
                e.drag.callback(e);
            });

            // create a custom over-event that fires exactly when the mouse is over any dropzone
            // we cannot use &#x60;hover&#x60;, because that event fails when there is an absolute floated element outsize &#x60;dropzone&#x60;
            // lying on top of the dropzone. -&gt; we need to check by co√∂rdinates
            instance.ddProps.dragOverEv = instance._defineOverEv(e);

            instance.ddProps.dragDropEv = instance._defineDropEv(emitterName, sourceNode, dragNode, dropzoneSpecified, inlineLeft, inlineTop);

            dragNode.setClass(NO_TRANS_CLASS).setClass(HIGH_Z_CLASS).setClass(DD_DRAGGING_CLASS);

console.info(NAME, &#x27;setting up mouseup  event&#x27;);
            Event.onceAfter([MOUSE+&#x27;up&#x27;, &#x27;dd-fake-mouseup&#x27;], function(e3) {
console.info(NAME, &#x27;Event &#x27;+e3.type+&#x27; occured&#x27;);
                moveEv.detach();
                instance._teardownOverEvent(e);
                instance.ddProps = {};
                Event.emit(sourceNode, emitterName+&#x27;:dd-drop&#x27;, e);
                e.drag.fulfill(e);
            });

            if (dropzoneSpecified) {
                dropEffect = (instance.onlyCopy(sourceNode) || (ctrlPressed &amp;&amp; instance.allowCopy(sourceNode))) ? &#x27;copy&#x27; : &#x27;move&#x27;;
                (dropEffect===&#x27;copy&#x27;) ? dragNode.setClass(DD_OPACITY_CLASS) : sourceNode.setClass(INVISIBLE_CLASS);
                dragNode.setClass(INVISIBLE_CLASS);
                sourceNode.parentNode.append(dragNode);
                dragNode.setXY(ddProps.xMouseLast, ddProps.yMouseLast, ddProps.constrain, true);
                dragNode.removeClass(INVISIBLE_CLASS);
            }
            else {
                dropEffect = null;
                dragNode.setXY(ddProps.xMouseLast, ddProps.yMouseLast, ddProps.constrain, true);
            }
        },

        /**
         * Prevented function for the &#x60;*:dd-start&#x60;-event
         *
         * @method _prevFnStart
         * @param e {Object} eventobject
         * @private
         * @since 0.0.1
         */
        _prevFnStart: function(e) {
console.info(NAME, &#x27;_prevFnStart&#x27;);
            e.drag.reject();
        },

      /**
        * Sets the draggable node back to its original position
        *
        * @method _setBack
        * @param e {Object} eventobject
        * @param sourceNode {HtmlElement} the original HtmlElement
        * @param dragNode {HtmlElement} the dragged HtmlElement (either original or clone)
        * @param dropzoneSpecified {Boolean} whether the sourceNode had a dropzone specified
        * @param x {Number} x-position in coordinaties relative to &#x60;document&#x60; (like getX())
        * @param y {Number} y-position in coordinaties relative to &#x60;document&#x60; (like getX())
        * @private
        * @since 0.0.1
        */
        _setBack: function(e, sourceNode, dragNode, dropzoneSpecified, x, y) {
console.info(NAME, &#x27;_setBack to &#x27;+x+&#x27;, &#x27;+y);
            var tearedDown,
                tearDown = function(notransRemoval) {
console.info(NAME, &#x27;_setBack -&gt; tearDown&#x27;);
                    // dragNode might be gone when this method is called for the second time
                    // therefor check its existance:
                    if (!tearedDown) {
                        tearedDown = true;
                        notransRemoval || (dragNode.removeEventListener &amp;&amp; dragNode.removeEventListener(&#x27;transitionend&#x27;, tearDown, true));
                        if (dropzoneSpecified) {
                            sourceNode.removeClass(INVISIBLE_CLASS);
                            dragNode.remove();
                        }
                        else {
                            dragNode.removeClass(DD_TRANSITION_CLASS).removeClass(HIGH_Z_CLASS).removeClass(DD_DRAGGING_CLASS);
                        }
                    }
                };

            dragNode.removeClass(NO_TRANS_CLASS);

            dragNode.removeClass(DD_DRAGGING_CLASS);
            dragNode.setClass(DD_TRANSITION_CLASS);
            // transitions only work with IE10+, and that browser has addEventListener
            // when it doesn&#x27;t have, it doesn;t harm to leave the transitionclass on: it would work anyway
            // nevertheless we will remove it with a timeout
            if (dragNode.addEventListener) {
                dragNode.addEventListener(&#x27;transitionend&#x27;, tearDown, true);
            }
            // ALWAYS tearDowm after delay --&gt; when there was no repositioning, there never will be a transition-event
            LATER(tearDown, 250);
            dragNode.setInlineStyle(&#x27;left&#x27;, x);
            dragNode.setInlineStyle(&#x27;top&#x27;, y);
        },

      /**
        * Sets up a &#x60;keydown&#x60; and &#x60;keyup&#x60; listener, to monitor whether a &#x60;ctrlKey&#x60; (windows) or &#x60;metaKey&#x60; (Mac)
        * is pressed to support the copying of draggable items
        *
        * @method _setupKeyEv
        * @private
        * @since 0.0.1
        */
        _setupKeyEv: function() {
console.info(NAME, &#x27;_setupKeyEv&#x27;);
            var instance = this;
            Event.after([&#x27;keydown&#x27;, &#x27;keyup&#x27;], function(e) {
console.info(NAME, &#x27;event &#x27;+e.type);
                var ddProps = instance.ddProps,
                    sourceNode = ddProps.sourceNode,
                    dragNode, mouseOverNode;
                ctrlPressed = e.ctrlKey || e.metaKey;
                if (sourceNode &amp;&amp; instance.allowSwitch(sourceNode)) {
                    dragNode = ddProps.dragNode;
                    mouseOverNode = ddProps.mouseOverNode;
                    dropEffect = ctrlPressed ? &#x27;copy&#x27; : &#x27;move&#x27;;
                    if (ctrlPressed) {
                        sourceNode.removeClass(INVISIBLE_CLASS);
                        dragNode.setClass(DD_OPACITY_CLASS);
                    }
                    else {
                        sourceNode.setClass(INVISIBLE_CLASS);
                        dragNode.removeClass(DD_OPACITY_CLASS);
                    }
                    // now, it could be that any droptarget should change its appearance (DD_DROPACTIVE_CLASS).
                    // we need to recalculate it for all targets
                    // we do this by emitting a &#x27;dd-fake-mousemove&#x27; event
                    mouseOverNode &amp;&amp; Event.emit(mouseOverNode, &#x27;UI:dd-fake-mousemove&#x27;);
                }
            });
        },

      /**
        * Engine behinf the dragdrop-cycle.
        * Sets up a &#x60;mousedown&#x60; listener to initiate a drag-drop eventcycle. The eventcycle start whenever
        * one of these events happens on a HtmlElement with the attribute &#x60;draggable=&quot;true&quot;&#x60;.
        * The drag-drop eventcycle consists of the events: &#x60;dd-start&#x60;, &#x60;emitterName:dd-drag&#x60; and &#x60;emitterName:dd-drop&#x60;
        *
        *
        * @method _setupMouseEv
        * @private
        * @since 0.0.1
        */
        _setupMouseEv: function() {
            var instance = this;
console.info(NAME, &#x27;_setupMouseEv: setting up mousedown event&#x27;);
            Event.before(MOUSE+&#x27;down&#x27;, function(e) {
                var node = e.target,
                    handle, availableHandles, insideHandle;

                // first check if there is a handle to determine if the drag started here:
                handle = node.getAttr(&#x27;dd-handle&#x27;);
                if (handle) {
                    availableHandles = node.getAll(handle);
                    insideHandle = false;
                    availableHandles.some(function(handleNode) {
                        insideHandle = handleNode.contains(e.sourceTarget);
                        return insideHandle;
                    });
                    if (!insideHandle) {
                        return;
                    }
                }

                // initialize ddProps: have to do here, because the event might not start because it wasn&#x27;t inside the handle when it should be
                instance.ddProps = {
                    defined: true,
                    dragOverList: []
                };

                // prevent the emitter from resetting e.target to e.sourceTarget:
                e._noResetSourceTarget = true;
                // add &#x60;drag&#x60;-Promise to the eventobject --&gt; this Promise will be resolved once the pointer has released.
                e.drag = Promise.manage();
                // define e.setOnDrag --&gt; users
                e.setOnDrag = function(callbackFn) {
                    e.drag.setCallback(callbackFn);
                };
                // store the orriginal mouseposition:
                e.xMouseOrigin = e.clientX + window.getScrollLeft();
                e.yMouseOrigin = e.clientY + window.getScrollTop();
                // now we can start the eventcycle by emitting UI:dd-start:
                Event.emit(e.target, &#x27;UI:dd-start&#x27;, e);
            }, &#x27;[draggable=&quot;true&quot;]&#x27;);

        },

      /**
        * Cleansup the dragover subscriber and fulfills any dropzone-promise.
        *
        * @method _teardownOverEvent
        * @param e {Object} eventobject
        * @private
        * @since 0.0.1
        */
        _teardownOverEvent: function(e) {
console.info(&#x27;_teardownOverEvent&#x27;);
            var ddProps = this.ddProps,
                dragOverEvent = ddProps.dragOverEv;
            if (dragOverEvent) {
                dragOverEvent.detach();
                ddProps.dragOverList.forEach(function(promise) {
                    promise.fulfill(e.dropTarget);
                });
            }
        },

       /**
         * Returns true if the dropzone-HtmlElement accepts copy-dragables.
         * Is determined by the attribute &#x60;dd-effect-allowed=&quot;copy&quot;&#x60; or &#x60;dd-effect-allowed=&quot;all&quot;&#x60;
         *
         * @method allowCopy
         * @param dropzone {HtmlElement} HtmlElement that is checked for its allowed effects
         * @return {Boolean} if copy-dragables are allowed
         * @since 0.0.1
         */
        allowCopy: function(dropzone) {
            var allowedEffects = this._allowedEffects(dropzone);
console.info(&#x27;allowCopy --&gt; &#x27;+REGEXP_ALL.test(allowedEffects) || REGEXP_COPY.test(allowedEffects));
            return REGEXP_ALL.test(allowedEffects) || REGEXP_COPY.test(allowedEffects);
        },

       /**
         * Returns true if the dragable-HtmlElement allowes to switch between &#x60;copy&#x60; and &#x60;move&#x60;.
         *
         * @method allowSwitch
         * @param dragableElement {HtmlElement} HtmlElement that is checked for its allowed effects
         * @return {Boolean} if copy-dragables are allowed
         * @since 0.0.1
         */
        allowSwitch: function(dragableElement) {
console.info(&#x27;allowSwitch --&gt; &#x27;+REGEXP_ALL.test(this._allowedEffects(dragableElement)));
            return REGEXP_ALL.test(this._allowedEffects(dragableElement));
        },

       /**
         * Returns the emitterName that the dropzone accepts.
         *
         * @method getDropzoneEmitter
         * @param dropzone {String} dropzone attribute of the dropzone HtmlElement
         * @return {String|null} the emitterName that is accepted
         * @since 0.0.1
         */
        getDropzoneEmitter: function(dropzone) {
            var extract = dropzone.match(REGEXP_EMITTER);
console.info(&#x27;getDropzoneEmitter --&gt; &#x27;+(extract &amp;&amp; extract[1]));
            return extract &amp;&amp; extract[1];
        },

       /**
         * Initializes dragdrop. Needs to be invoked, otherwise DD won&#x27;t run.
         *
         * @method init
         * @param dragableElement {HtmlElement} HtmlElement that is checked for its allowed effects
         * @return {Boolean} if copy-dragables are allowed
         * @since 0.0.1
         */
        init: function() {
console.info(NAME, &#x27;init&#x27;);
            var instance = this;
            if (!instance.initialised) {
                instance._setupKeyEv();
                instance._defineDDStart();
                instance._setupMouseEv(); // engine behind the dragdrop-eventcycle
            }
            instance.initialised = true;
        },

       /**
         * Returns true if the dragable-HtmlElement accepts only copy-dragables (no moveable)
         * Is determined by the attribute &#x60;dd-effect-allowed=&quot;copy&quot;&#x60;
         *
         * @method onlyCopy
         * @param dragableElement {HtmlElement} HtmlElement that is checked for its allowed effects
         * @return {Boolean} if only copy-dragables are allowed
         * @since 0.0.1
         */
        onlyCopy: function(dragableElement) {
console.info(&#x27;onlyCopy --&gt; &#x27;+REGEXP_COPY.test(this._allowedEffects(dragableElement)));
            return REGEXP_COPY.test(this._allowedEffects(dragableElement));
        }
    };

    NodeDD = NodePlugin.subClass(
        function (config) {
            config || (config={});
            this.draggable = true;
            this[&#x27;dd-dropzone&#x27;] = config.dropzone;
            this[&#x27;xy-constrain&#x27;] = config.constrain;
            this[&#x27;dd-emitter-name&#x27;] = config.emitterName;
            this[&#x27;dd-handle&#x27;] = config.handle;
            this[&#x27;dd-effect-allowed&#x27;] = config.effectAllowed;
        }
    );

    NodeDropzone = NodePlugin.subClass(
        function (config) {
            var dropzone = &#x27;true&#x27;,
                emitterName;
            config || (config={});
            if (config.copy &amp;&amp; !config.move) {
                dropzone = &#x27;copy&#x27;;
            }
            else if (!config.copy &amp;&amp; config.move) {
                dropzone = &#x27;move&#x27;;
            }
            (emitterName=config.emitterName) &amp;&amp; (dropzone+=&#x27; emitter-name=&#x27;+emitterName);
            this.dropzone = dropzone;
        }
    );

    return {
        DD: DD,
        Plugins: {
            NodeDD: NodeDD,
            NodeDropzone: NodeDropzone
        }
    };
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
