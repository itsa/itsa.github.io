<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/event-dom/event-dom.js - Itsa</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Itsa"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/BaseClass.html">BaseClass</a></li>
            
                <li><a href="../classes/Classes.html">Classes</a></li>
            
                <li><a href="../classes/DD.html">DD</a></li>
            
                <li><a href="../classes/Dialog.html">Dialog</a></li>
            
                <li><a href="../classes/document.html">document</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/FocusManager.html">FocusManager</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/HTMLElement.html">HTMLElement</a></li>
            
                <li><a href="../classes/Icons.html">Icons</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/Math.html">Math</a></li>
            
                <li><a href="../classes/Messages.html">Messages</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/NodePlugin.html">NodePlugin</a></li>
            
                <li><a href="../classes/NS-vdom.html">NS-vdom</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Panel.html">Panel</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/String.html">String</a></li>
            
                <li><a href="../classes/USERAGENT.html">USERAGENT</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vnode.html">vnode</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/attribute-extractor.html">attribute-extractor</a></li>
            
                <li><a href="../modules/dialog.html">dialog</a></li>
            
                <li><a href="../modules/drag.html">drag</a></li>
            
                <li><a href="../modules/drag-drop.html">drag-drop</a></li>
            
                <li><a href="../modules/element-array.html">element-array</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-blurnode.html">event-blurnode</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-focusnode.html">event-focusnode</a></li>
            
                <li><a href="../modules/event-hover.html">event-hover</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/event-mobile.html">event-mobile</a></li>
            
                <li><a href="../modules/extend-document.html">extend-document</a></li>
            
                <li><a href="../modules/extend-element.html">extend-element</a></li>
            
                <li><a href="../modules/extra_classes.js.html">extra/classes.js</a></li>
            
                <li><a href="../modules/focusmanager.html">focusmanager</a></li>
            
                <li><a href="../modules/html-parser.html">html-parser</a></li>
            
                <li><a href="../modules/icons.html">icons</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/itsa.build.html">itsa.build</a></li>
            
                <li><a href="../modules/js-ext.html">js-ext</a></li>
            
                <li><a href="../modules/lib_array.js.html">lib/array.js</a></li>
            
                <li><a href="../modules/lib_function.js.html">lib/function.js</a></li>
            
                <li><a href="../modules/lib_math.js.html">lib/math.js</a></li>
            
                <li><a href="../modules/lib_object.js.html">lib/object.js</a></li>
            
                <li><a href="../modules/lib_promise.s.html">lib/promise.s</a></li>
            
                <li><a href="../modules/lib_string.js.html">lib/string.js</a></li>
            
                <li><a href="../modules/messages.html">messages</a></li>
            
                <li><a href="../modules/node-parser.html">node-parser</a></li>
            
                <li><a href="../modules/node-plugin.html">node-plugin</a></li>
            
                <li><a href="../modules/node-win.html">node-win</a></li>
            
                <li><a href="../modules/panel.html">panel</a></li>
            
                <li><a href="../modules/useragent.html">useragent</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/vdom.html">vdom</a></li>
            
                <li><a href="../modules/vdom-ns.html">vdom-ns</a></li>
            
                <li><a href="../modules/vnode.html">vnode</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/event-dom/event-dom.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;

/**
 * Integrates DOM-events to event. more about DOM-events:
 * http://www.smashingmagazine.com/2013/11/12/an-introduction-to-dom-events/
 *
 *
 * &lt;i&gt;Copyright (c) 2014 ITSA - https://github.com/itsa&lt;/i&gt;
 * New BSD License - http://choosealicense.com/licenses/bsd-3-clause/
 *
 * @example
 * Event = require(&#x27;event-dom&#x27;)(window);
 *
 * @module event
 * @submodule event-dom
 * @class Event
 * @since 0.0.1
*/


var NAME = &#x27;[event-dom]: &#x27;,
    Event = require(&#x27;event&#x27;),
    later = require(&#x27;utils&#x27;).later,
    createHashMap = require(&#x27;js-ext/extra/hashmap.js&#x27;).createMap,
    OUTSIDE = &#x27;outside&#x27;,
    REGEXP_NODE_ID = /^#\S+$/,
    REGEXP_EXTRACT_NODE_ID = /#(\S+)/,
    REGEXP_UI_OUTSIDE = /^.+outside$/,
    TIME_BTN_PRESSED = 200,
    PURE_BUTTON_ACTIVE = &#x27;pure-button-active&#x27;,
    UI = &#x27;UI:&#x27;,
    NODE = &#x27;node&#x27;,
    REMOVE = &#x27;remove&#x27;,
    INSERT = &#x27;insert&#x27;,
    CHANGE = &#x27;change&#x27;,
    ATTRIBUTE = &#x27;attribute&#x27;,
    TAP = &#x27;tap&#x27;,
    CLICK = &#x27;click&#x27;,
    RIGHTCLICK = &#x27;right&#x27;+CLICK,
    CENTERCLICK = &#x27;center&#x27;+CLICK,
    ANCHOR_CLICK = &#x27;anchor&#x27;+CLICK,
    EV_REMOVED = UI+NODE+REMOVE,
    EV_INSERTED = UI+NODE+INSERT,
    EV_CONTENT_CHANGE = UI+NODE+&#x27;content&#x27;+CHANGE,
    EV_ATTRIBUTE_REMOVED = UI+ATTRIBUTE+REMOVE,
    EV_ATTRIBUTE_CHANGED = UI+ATTRIBUTE+CHANGE,
    EV_ATTRIBUTE_INSERTED = UI+ATTRIBUTE+INSERT,
    mutationEventsDefined = false,
    NO_DEEP_SEARCH = {},

    /*
     * Internal hash containing all DOM-events that are listened for (at &#x60;document&#x60;).
     *
     * DOMEvents = {
     *     &#x27;tap&#x27;: callbackFn,
     *     &#x27;mousemove&#x27;: callbackFn,
     *     &#x27;keypress&#x27;: callbackFn
     * }
     *
     * @property DOMEvents
     * @default {}
     * @type Object
     * @private
     * @since 0.0.1
    */
    DOMEvents = {};

    require(&#x27;js-ext/lib/string.js&#x27;);
    require(&#x27;js-ext/lib/array.js&#x27;);
    require(&#x27;js-ext/lib/object.js&#x27;);
    require(&#x27;polyfill/polyfill-base.js&#x27;);

module.exports = function (window) {
    var DOCUMENT = window.document,
        _domSelToFunc, _evCallback, _findCurrentTargets, _preProcessor, _setupEvents, _setupMutationListener, _teardownMutationListener,
        _setupDomListener, _teardownDomListener, SORT, _sortFunc, _sortFuncReversed, _getSubscribers, _selToFunc, MUTATION_EVENTS, preventClick;

    require(&#x27;vdom&#x27;)(window);

    window._ITSAmodules || Object.protectedProp(window, &#x27;_ITSAmodules&#x27;, createHashMap());

    if (window._ITSAmodules.EventDom) {
        return Event; // Event was already extended
    }

    MUTATION_EVENTS = [EV_REMOVED, EV_INSERTED, EV_CONTENT_CHANGE, EV_ATTRIBUTE_REMOVED, , EV_ATTRIBUTE_CHANGED, EV_ATTRIBUTE_INSERTED];

    /*
     * Transforms the selector to a valid function
     *
     * @method _selToFunc
     * @param customEvent {String} the customEvent that is transported to the eventsystem
     * @param subscriber {Object} subscriber
     * @param subscriber.o {Object} context
     * @param subscriber.cb {Function} callbackFn
     * @param subscriber.f {Function|String} filter
     * @private
     * @since 0.0.1
     */
    _selToFunc = function(customEvent, subscriber) {
        Event._sellist.some(function(selFn) {
            return selFn(customEvent, subscriber);
        });
    };

    /*
     * Creates a filterfunction out of a css-selector. To be used for catching any dom-element, without restrictions
     * of any context (like Parcels can --&gt; Parcel.Event uses _parcelSelToDom instead)
     * On &quot;non-outside&quot; events, subscriber.t is set to the node that first matches the selector
     * so it can be used to set as e.target in the final subscriber
     *
     * @method _domSelToFunc
     * @param customEvent {String} the customEvent that is transported to the eventsystem
     * @param subscriber {Object} subscriber
     * @param subscriber.o {Object} context
     * @param subscriber.cb {Function} callbackFn
     * @param subscriber.f {Function|String} filter
     * @private
     * @since 0.0.1
     */
    _domSelToFunc = function(customEvent, subscriber) {
        // this stage is runned during subscription
        var outsideEvent = REGEXP_UI_OUTSIDE.test(customEvent),
            selector = subscriber.f,
            context = subscriber.o,
            vnode = subscriber.o.vnode,
            isCustomElement = vnode &amp;&amp; vnode.isItag,
            visibleContent = isCustomElement &amp;&amp; !vnode.domNode.contentHidden,
            nodeid, byExactId, newTarget, deepSearch;

        console.log(NAME, &#x27;_domSelToFunc type of selector = &#x27;+typeof selector);
        // note: selector could still be a function: in case another subscriber
        // already changed it.
        if ((!selector &amp;&amp; !isCustomElement) || (typeof selector === &#x27;function&#x27;)) {
            subscriber.n || (subscriber.n = isCustomElement ? context : DOCUMENT);
            return true;
        }
        selector || (selector=&#x27;&#x27;);

        nodeid = selector.match(REGEXP_EXTRACT_NODE_ID);
        nodeid ? (subscriber.nId=nodeid[1]) : (subscriber.n=isCustomElement ? context : DOCUMENT);
        byExactId = REGEXP_NODE_ID.test(selector);

        deepSearch = !NO_DEEP_SEARCH[customEvent];
        // set the selector to &#x60;subscriber._s&#x60; so that e.currentTarget can calculate it:
        subscriber._s = selector;

        subscriber.f = function(e) {
            // this stage is runned when the event happens
            console.log(NAME, &#x27;_domSelToFunc inside filter. selector: &#x27;+selector);
            var node = e.target,
                vnode = node.vnode,
                character1 = selector &amp;&amp; selector.substr(1),
                match = false;
            if (!isCustomElement || visibleContent || context.contains(node)) {
                if (selector===&#x27;&#x27;) {
                    match = true;
                }
                else {
                    // e.target is the most deeply node in the dom-tree that caught the event
                    // our listener uses &#x60;selector&#x60; which might be a node higher up the tree.
                    // we will reset e.target to this node (if there is a match)
                    // note that e.currentTarget will always be &#x60;document&#x60; --&gt; we&#x27;re not interested in that
                    // also, we don&#x27;t check for &#x60;node&#x60;, but for node.matchesSelector: the highest level &#x60;document&#x60;
                    // is not null, yet it doesn&#x27;t have .matchesSelector so it would fail
                    // we DON&#x27;T want this for the focus and blur event!
                    if (deepSearch) {
                        if (vnode) {
                            // we go through the vdom
                            if (!vnode.removedFromDOM) {
                                while (vnode &amp;&amp; !match) {
                                    console.log(NAME, &#x27;_domSelToFunc inside filter check match using the vdom&#x27;);
                                    match = byExactId ? (vnode.id===character1) : vnode.matchesSelector(selector);
                                    // if there is a match, then set
                                    // e.target to the target that matches the selector
                                    if (match &amp;&amp; !outsideEvent) {
                                        subscriber.t = vnode.domNode;
                                    }
                                    vnode = vnode.vParent;
                                }
                            }
                        }
                        else {
                            // we go through the dom
                            while (node.matchesSelector &amp;&amp; !match) {
                                console.log(NAME, &#x27;_domSelToFunc inside filter check match using the dom&#x27;);
                                match = byExactId ? (node.id===character1) : node.matchesSelector(selector);
                                // if there is a match, then set
                                // e.target to the target that matches the selector
                                if (match &amp;&amp; !outsideEvent) {
                                    subscriber.t = node;
                                }
                                node = node.parentNode;
                            }
                        }
                    }
                    else {
                        console.log(NAME, &#x27;_domSelToFunc inside filter check match using the vdom&#x27;);
                        if (vnode) {
                            match = byExactId ? (vnode.id===character1) : vnode.matchesSelector(selector);
                        }
                        else {
                            match = node.matchesSelector &amp;&amp; (byExactId ? (node.id===character1) : node.matchesSelector(selector));
                        }
                        match &amp;&amp; (e.sourceTarget=node);
                    }
                }
            }
            if (outsideEvent &amp;&amp; !match) {
                // there is a match for the outside-event:
                // we need to set e.sourceTarget and e.target:
                newTarget = DOCUMENT.getElement(selector, true);
                if (newTarget) {
                    e.sourceTarget = node;
                    subscriber.t = newTarget;
                }
                else {
                    // make return &#x60;false&#x60; because the selector is not in the dom
                    match = true;
                }
            }
            console.log(NAME, &#x27;_domSelToFunc filter returns &#x27;+(!outsideEvent ? match : !match));
            return !outsideEvent ? match : !match;
        };
        return true;
    };

    // at this point, we need to find out what are the current node-refs. whenever there is
    // a filter that starts with &#x60;#&#x60; --&gt; in those cases we have a bubble-chain, because the selector isn&#x27;t
    // set up with &#x60;document&#x60; at its root.
    // we couldn&#x27;t do this at time of subscribtion, for the nodes might not be there at that time.
    // however, we only need to do this once: we store the value if we find them
    // no problem when the nodes leave the dom later: the previous filter wouldn&#x27;t pass
    _findCurrentTargets = function(subscribers) {
        console.log(NAME, &#x27;_findCurrentTargets&#x27;);
        subscribers.forEach(
            function(subscriber) {
                console.log(NAME, &#x27;_findCurrentTargets for single subscriber. nId: &#x27;+subscriber.nId);
                subscriber.nId &amp;&amp; (subscriber.n=DOCUMENT.getElementById(subscriber.nId, true));
            }
        );
    };

    /*
     * Generates an event through our Event-system. Does the actual transportation from DOM-events
     * into our Eventsystem. It also looks at the response of our Eventsystem: if our system
     * halts or preventDefaults the customEvent, then the original DOM-event will be preventDefaulted.
     *
     * @method _evCallback
     * @param e {Object} eventobject
     * @private
     * @since 0.0.1
     */
    _evCallback = function(e) {
        console.log(NAME, &#x27;_evCallback&#x27;);
        var allSubscribers = Event._subs,
            eType = e.type,
            eventobject, subs, wildcard_named_subs, named_wildcard_subs, wildcard_wildcard_subs, subsOutside,
            subscribers, eventobjectOutside, wildcard_named_subsOutside, customEvent, eventName, which, eTarget;

        eventName = eType;
        // first: a &#x60;click&#x60; event might be needed to transformed into &#x60;rightclick&#x60;:
        if (eventName===CLICK) {
            which = e.which;
            (which===2) &amp;&amp; (eventName=CENTERCLICK);
            (which===3) &amp;&amp; (eventName=RIGHTCLICK);
        }
        if ((eventName===&#x27;tap&#x27;) &amp;&amp; (!e.target.vnode || (e.target.vnode.tag!==&#x27;A&#x27;))) {
            // prevent the next click-event
            preventClick = true;
            e.clientX || (e.clientX = e.center &amp;&amp; e.center.x);
            e.clientY || (e.clientY = e.center &amp;&amp; e.center.y);
        }
        else if (preventClick &amp;&amp; (eventName===CLICK)) {
            preventClick = false;
            return;
        }

if (Event._working &amp;&amp; (eventName===&#x27;mousedown&#x27;)) {
e.clientX || (e.clientX = e.center &amp;&amp; e.center.x);
e.clientY || (e.clientY = e.center &amp;&amp; e.center.y);
    var node = DOCUMENT.getElement(&#x27;#a-info&#x27;);
    node.append(&#x27;MOUSEDOWN: &#x27;+e.clientX+&#x27;, &#x27;+e.clientY+&#x27;&lt;br&gt;&#x27;);
}

if (Event._working &amp;&amp; (eventName===&#x27;panstart&#x27;)) {
e.clientX || (e.clientX = e.center &amp;&amp; e.center.x);
e.clientY || (e.clientY = e.center &amp;&amp; e.center.y);
    var node = DOCUMENT.getElement(&#x27;#a-info&#x27;);
    node.append(&#x27;PANSTART: &#x27;+e.clientX+&#x27;, &#x27;+e.clientY+&#x27;&lt;br&gt;&#x27;);
}

        if (eventName===CLICK) {
            eTarget = e.target;
            if ((eTarget.vnode &amp;&amp; (e.target.vnode.tag===&#x27;A&#x27;)) || eTarget.inside(&#x27;a&#x27;)) {
                eventName = ANCHOR_CLICK;
                e.clientX || (e.clientX = e.center &amp;&amp; e.center.x);
                e.clientY || (e.clientY = e.center &amp;&amp; e.center.y);
                // ALSO: determine the offset between the latest mousedown and the current mouseposition
                // if there is an offset, then the user is scrolling and doesn&#x27;t want to follow the link!
                if (Event._working) {
    var node = DOCUMENT.getElement(&#x27;#a-info&#x27;);
    node.append(&#x27;ANCHOR-CLICK: &#x27;+e.clientX+&#x27;, &#x27;+e.clientY+&#x27;&lt;br&gt;&#x27;);
                    e.preventDefault();
                    return;
                }
            }
            else {
                eventName = &#x27;tap&#x27;;
                e.center = {
                    x: e.clientX,
                    y: e.clientY
                };
                e.eventType = 4;
                e.pointerType = &#x27;mouse&#x27;;
                e.tapCount = 1;
            }
        }

        customEvent = &#x27;UI:&#x27;+eventName;

        subs = allSubscribers[customEvent];
        wildcard_named_subs = allSubscribers[&#x27;*:&#x27;+eventName];
        named_wildcard_subs = allSubscribers[&#x27;UI:*&#x27;];
        wildcard_wildcard_subs = allSubscribers[&#x27;*:*&#x27;];

        // Emit the dom-event though our eventsystem:
        // NOTE: emit() needs to be synchronous! otherwise we wouldn&#x27;t be able
        // to preventDefault in time
        //
        // e = eventobject from the DOM-event OR gesture-event
        // eventobject = eventobject from our Eventsystem, which get returned by calling &#x60;emit()&#x60;

        // now so the work:
        subscribers = _getSubscribers(e, true, subs, wildcard_named_subs, named_wildcard_subs, wildcard_wildcard_subs);
        eventobject = Event._emit(e.target, customEvent, e, subscribers, [], _preProcessor, false, true);

        // now check outside subscribers
        subsOutside = allSubscribers[customEvent+OUTSIDE];
        wildcard_named_subsOutside = allSubscribers[&#x27;*:&#x27;+eventName+OUTSIDE];
        subscribers = _getSubscribers(e, true, subsOutside, wildcard_named_subsOutside);
        eventobjectOutside = Event._emit(e.target, customEvent+OUTSIDE, e, subscribers, [], _preProcessor, false, true);

        // if eventobject was preventdefaulted or halted: take appropriate action on
        // the original dom-event. Note: only the original event can caused this, not the outsideevent
        // stopPropagation on the original eventobject has no impact on our eventsystem, but who know who else is watching...
        // be carefull though: not all gesture events have e.stopPropagation
        eventobject.status.halted &amp;&amp; e.stopPropagation &amp;&amp; e.stopPropagation();
        // now we might need to preventDefault the original event.
        // be carefull though: not all gesture events have e.preventDefault
        if ((eventobject.status.halted || eventobject.status.defaultPrevented || eventobject.status.defaultPreventedContinue) &amp;&amp; e.preventDefault) {
            e.preventDefault();
        }

        if (eventobject.status.ok) {
            // last step: invoke the aftersubscribers
            // we need to do this asynchronous: this way we pass them AFTER the DOM-event&#x27;s defaultFn
            // also make sure to paas-in the payload of the manipulated eventobject
            subscribers = _getSubscribers(e, false, subs, wildcard_named_subs, named_wildcard_subs, wildcard_wildcard_subs);
            (subscribers.length&gt;0) &amp;&amp; later(Event._emit.bind(Event, e.target, customEvent, eventobject, [], subscribers, _preProcessor, true), 10);

            // now check outside subscribers
            subscribers = _getSubscribers(e, false, subsOutside, wildcard_named_subsOutside);
            (subscribers.length&gt;0) &amp;&amp; later(Event._emit.bind(Event, e.target, customEvent+OUTSIDE, eventobjectOutside, [], subscribers, _preProcessor, true), 10);
        }
    };

    /*
     * Creates an array of subscribers in the right order, conform their position in the DOM.
     * Only subscribers that match the filter are involved.
     *
     * @method _getSubscribers
     * @param e {Object} eventobject
     * @param before {Boolean} whether it is a before- or after-subscriber
     * @param subs {Array} array with subscribers
     * @param wildcard_named_subs {Array} array with subscribers
     * @param named_wildcard_subs {Array} array with subscribers
     * @param wildcard_wildcard_subs {Array} array with subscribers
     * @private
     * @since 0.0.1
     */
    _getSubscribers = function(e, before, subs, wildcard_named_subs, named_wildcard_subs, wildcard_wildcard_subs) {
        var subscribers = [],
            beforeOrAfter = before ? &#x27;b&#x27; : &#x27;a&#x27;,
            saveConcat = function(extrasubs) {
                extrasubs &amp;&amp; extrasubs[beforeOrAfter] &amp;&amp; (subscribers=subscribers.concat(extrasubs[beforeOrAfter]));
            };
        saveConcat(subs);
        saveConcat(wildcard_named_subs);
        saveConcat(named_wildcard_subs);
        saveConcat(wildcard_wildcard_subs);
        if (subscribers.length&gt;0) {
            subscribers = function(array, testFunc) {
                // quickest way to filter an array: see http://jsperf.com/array-filter-performance/4
                var filtered = array.slice(0), i;
                for (i=array.length-1; i&gt;=0; i--) {
                    console.log(NAME, &#x27;filtercheck for subscriber&#x27;);
                    testFunc(array[i]) || filtered.splice(i, 1);
                }
                return filtered;
            }(subscribers, function(subscriber) {return (!subscriber.f || subscriber.f.call(subscriber.o, e));});
            if (subscribers.length&gt;0) {
// _findCurrentTargets(subscribers);
                // sorting, based upon the sortFn
                subscribers.sort(SORT);
            }
        }
        return subscribers;
    };

    /*
     * Sets e.target and e.sourceTarget for the single subscriber.
     * Needs to be done for evenry single subscriber, because with a single event, these values change for each subscriber
     *
     * @method _preProcessor
     * @param subscriber {Object} subscriber
     * @param subscriber.o {Object} context
     * @param subscriber.cb {Function} callbackFn
     * @param subscriber.f {Function|String} filter
     * @param e {Object} eventobject
     * @private
     * @since 0.0.1
     */
    _preProcessor = function(subscriber, e) {
        console.log(NAME, &#x27;_preProcessor&#x27;);
        // inside the aftersubscribers, we may need exit right away.
        // this would be the case whenever stopPropagation or stopImmediatePropagation was called
        // in case the subscribernode equals the node on which stopImmediatePropagation was called: return true
        var propagationStopped, immediatePropagationStopped,
            targetnode = (subscriber.t || subscriber.n);

        immediatePropagationStopped = e.status.immediatePropagationStopped;
        if (immediatePropagationStopped &amp;&amp; ((immediatePropagationStopped===targetnode) || !immediatePropagationStopped.contains(targetnode))) {
            console.log(NAME, &#x27;_preProcessor will return true because of immediatePropagationStopped&#x27;);
            return true;
        }
        // in case the subscribernode does not fall within or equals the node on which stopPropagation was called: return true
        propagationStopped = e.status.propagationStopped;
        if (propagationStopped &amp;&amp; (propagationStopped!==targetnode) &amp;&amp; !propagationStopped.contains(targetnode)) {
            console.log(NAME, &#x27;_preProcessor will return true because of propagationStopped&#x27;);
            return true;
        }

        e._s = subscriber._s;

        // now we might need to set e.target to the right node:
        // the filterfunction might have found the true domnode that should act as e.target
        // and set it at subscriber.t
        // also, we need to backup the original e.target: this one should be reset when
        // we encounter a subscriber with its own filterfunction instead of selector
        if (subscriber.t) {
            e.sourceTarget || (e.sourceTarget=e.target);
            e.target = subscriber.t;
        }
        else {
            e.sourceTarget &amp;&amp; (e.target=e.sourceTarget);
        }
        return false;
    };

    /*
     * Transports DOM-events to the Event-system. Catches events at their most early stage:
     * their capture-phase. When these events happen, a new customEvent is generated by our own
     * Eventsystem, by calling _evCallback(). This way we keep DOM-events and our Eventsystem completely separated.
     *
     * @method _setupDomListener
     * @param customEvent {String} the customEvent that is transported to the eventsystem
     * @param subscriber {Object} subscriber
     * @param subscriber.o {Object} context
     * @param subscriber.cb {Function} callbackFn
     * @param subscriber.f {Function|String} filter
     * @private
     * @since 0.0.1
     */
    _setupDomListener = function(customEvent, subscriber) {
        console.log(NAME, &#x27;_setupDomListener&#x27;);
        var eventSplitted = customEvent.split(&#x27;:&#x27;),
            emitterName = eventSplitted[0],
            eventName = eventSplitted[1],
            outsideEvent = REGEXP_UI_OUTSIDE.test(eventName);

        // be careful: anyone could also register an &#x60;outside&#x60;-event.
        // in those cases, the DOM-listener must be set up without &#x60;outside&#x60;
        outsideEvent &amp;&amp; (eventName=eventName.substring(0, eventName.length-7));

        // if eventName equals &#x60;mouseover&#x60; or &#x60;mouseleave&#x60; then we quit:
        // people should use &#x60;mouseover&#x60; and &#x60;mouseout&#x60;
        if ((eventName===&#x27;mouseenter&#x27;) || (eventName===&#x27;mouseleave&#x27;)) {
            console.warn(NAME, &#x27;Subscription to &#x27;+eventName+&#x27; not supported, use mouseover and mouseout: this eventsystem uses these non-noisy so they act as mouseenter and mouseleave&#x27;);
            return;
        }

        // only accept tap-events, yet later on we WILL need to listen for click-events
        (eventName===CLICK) &amp;&amp; (eventName=TAP);

        // now transform the subscriber&#x27;s filter from css-string into a filterfunction
        _selToFunc(emitterName+&#x27;:&#x27;+eventName+(outsideEvent ? OUTSIDE : &#x27;&#x27;), subscriber);

        // already registered? then return, also return if someone registered for UI:*
        if (DOMEvents[eventName] || (eventName===&#x27;*&#x27;)) {
            // cautious: one might have registered the event, but not yet the outsideevent.
            // in that case: save this setting:
            if (outsideEvent) {
                DOMEvents[eventName+OUTSIDE] = true;
                (eventName===TAP) &amp;&amp; (DOMEvents[CLICK+OUTSIDE]=true);
            }
            return;
        }

        DOMEvents[eventName] = true;
        if (outsideEvent) {
            DOMEvents[eventName+OUTSIDE] = true;
            ((eventName===TAP) || (eventName===ANCHOR_CLICK)) &amp;&amp; (DOMEvents[CLICK+OUTSIDE]=true);
        }
        // one exception: windowresize should listen to the window-object
        if (eventName===&#x27;resize&#x27;) {
            window.addEventListener(eventName, _evCallback);
        }
        else {
            ((eventName===RIGHTCLICK) || (eventName===CENTERCLICK)) &amp;&amp; (eventName=TAP);
            // important: set the third argument &#x60;true&#x60; so we listen to the capture-phase.
            DOCUMENT.addEventListener(eventName, _evCallback, true);
            // listen for both &#x60;tap&#x60; and &#x60;click&#x60; events to happen
            ((eventName===TAP) || (eventName===ANCHOR_CLICK)) &amp;&amp; DOCUMENT.addEventListener(CLICK, _evCallback, true);
        }
    };

    _setupEvents = function() {
        var lastFocussed;

        // make sure disabled buttons don&#x27;t work:
        Event.before([&#x27;tap&#x27;, &#x27;press&#x27;], function(e) {
            e.preventDefault();
        }, &#x27;.pure-button-disabled, button[disabled]&#x27;);

        // make sure that a focussed button which recieves an keypress also fires the &#x60;tap&#x60;-event
        // note: the &#x60;click&#x60;-event will always be fired by the browser
        Event.before(
            &#x27;keydown&#x27;,
            function(e) {
                e._buttonPressed = true;
                Event.emit(e.target, &#x27;UI:tap&#x27;, e);
            },
            function(e) {
                var keyCode = e.keyCode;
                return (e.target.getTagName()===&#x27;BUTTON&#x27;) &amp;&amp; ((keyCode===13) || (keyCode===32));
            }
        );

        // make sure that a focussed button which recieves an keypress also fires the &#x60;tap&#x60;-event
        // note: the &#x60;click&#x60;-event will always be fired by the browser
        Event.after(
            &#x27;tap&#x27;,
            function(e) {
                var buttonNode = e.target;
                if (e._buttonPressed) {
                    buttonNode.setClass(PURE_BUTTON_ACTIVE);
                    e._noRender = true;
                    // even if the node isn&#x27;t in the DOM, we can still try to manipulate it:
                    // the vdom makes sure no errors occur when the node is already removed
                    later(buttonNode.removeClass.bind(buttonNode, PURE_BUTTON_ACTIVE), TIME_BTN_PRESSED);
                }
            }
        );

        // fix activeElement on Mac
        Event.before(&#x27;focus&#x27;, function(e) {
            // will come here more often because of bubblechain
            // however, the last pass-through will set the deepest node
            lastFocussed = e.target;
        });


        // patching DOCUMENT.activeElement because it doesn&#x27;t work well in a Mac: https://developer.mozilla.org/en-US/docs/Web/API/document.activeElement
        // DOCUMENT._activeElement is used with the patch for DOCUMENT.activeElement its getter
        Event.after(&#x27;focus&#x27;, function() {
            DOCUMENT._activeElement = lastFocussed;
        });

        Event.before(&#x27;blur&#x27;, function() {
            DOCUMENT._activeElement = null;
        });

        // Note: window.document has no prototype
        Object.defineProperty(DOCUMENT, &#x27;activeElement&#x27;, {
            get: function() {
                return DOCUMENT._activeElement || DOCUMENT.body;
            }
        });

    };

    _setupMutationListener = function() {
        DOCUMENT.hasMutationSubs = true;
        if (!mutationEventsDefined) {
            Event.defineEvent(EV_REMOVED).unPreventable();
            Event.defineEvent(EV_INSERTED).unPreventable();
            Event.defineEvent(EV_CONTENT_CHANGE).unPreventable();
            Event.defineEvent(EV_ATTRIBUTE_REMOVED).unPreventable();
            Event.defineEvent(EV_ATTRIBUTE_CHANGED).unPreventable();
            Event.defineEvent(EV_ATTRIBUTE_INSERTED).unPreventable();
            mutationEventsDefined = true;
        }
    };

    /*
     *
     * @method _sortFunc
     * @param customEvent {String}
     * @private
     * @return {Function|undefined} sortable function
     * @since 0.0.1
     */
    _sortFunc = function(subscriberOne, subscriberTwo) {
        return (subscriberTwo.t || subscriberTwo.n).contains(subscriberOne.t || subscriberOne.n) ? -1 : 1;
    };

    /*
     *
     * @method _sortFunc
     * @param customEvent {String}
     * @private
     * @return {Function|undefined} sortable function
     * @since 0.0.1
     */
    _sortFuncReversed = function(subscriberOne, subscriberTwo) {
        return (subscriberOne.t || subscriberOne.n).contains(subscriberTwo.t || subscriberTwo.n) ? 1 : -1;
    };

    /*
     * Removes DOM-eventsubscribers from document when they are no longer needed.
     *
     * @method _teardownDomListener
     * @param customEvent {String} the customEvent that is transported to the eventsystem
     * @private
     * @since 0.0.2
     */
    _teardownDomListener = function(customEvent) {
        var customEventWithoutOutside = customEvent.endsWith(OUTSIDE) ? customEvent.substr(0, customEvent.length-7) : customEvent,
            eventSplitted = customEventWithoutOutside.split(&#x27;:&#x27;),
            eventName = eventSplitted[1],
            stillInUse;

        if ((customEventWithoutOutside===CLICK) || (customEventWithoutOutside===RIGHTCLICK) || (customEventWithoutOutside===CENTERCLICK)) {
            stillInUse = Event._subs[CLICK] ||
                         Event._subs[CLICK+OUTSIDE];
                         Event._subs[RIGHTCLICK] ||
                         Event._subs[RIGHTCLICK+OUTSIDE],
                         Event._subs[CENTERCLICK] ||
                         Event._subs[CENTERCLICK+OUTSIDE];
            eventName = CLICK;
        }
        else {
            stillInUse = Event._subs[customEventWithoutOutside] || Event._subs[customEventWithoutOutside+OUTSIDE];
        }
        if (!stillInUse) {
            console.log(NAME, &#x27;_teardownDomListener &#x27;+customEvent);
            // remove eventlistener from &#x60;document&#x60;
            // one exeption: windowresize should listen to the window-object
            if (eventName===&#x27;resize&#x27;) {
                window.removeEventListener(eventName, _evCallback);
            }
            else {
                // important: set the third argument &#x60;true&#x60; so we listen to the capture-phase.
                DOCUMENT.removeEventListener(eventName, _evCallback, true);
            }
            delete DOMEvents[eventName];
        }
    };

    _teardownMutationListener = function() {
        if (!Event._subs[EV_REMOVED] &amp;&amp;
            !Event._subs[EV_INSERTED] &amp;&amp;
            !Event._subs[EV_CONTENT_CHANGE] &amp;&amp;
            !Event._subs[EV_ATTRIBUTE_REMOVED] &amp;&amp;
            !Event._subs[EV_ATTRIBUTE_CHANGED] &amp;&amp;
            !Event._subs[EV_ATTRIBUTE_INSERTED]
        ) {
            DOCUMENT.hasMutationSubs = false;
        }
    };

    // Now a very tricky one:
    // Some browsers do an array.sort down-top instead of top-down.
    // In those cases we need another sortFn, for the position on an equal match should fall
    // behind instead of before (which is the case on top-down sort)
    [1,2].sort(function(a /*, b */) {
        SORT || (SORT=(a===2) ? _sortFuncReversed : _sortFunc);
    });

    // Now we do some initialization in order to make DOM-events work:

    Object.defineProperty(Event._defaultEventObj, &#x27;currentTarget&#x27;, {
        get: function() {
            var ev = this,
                e_target = ev.target;
            if (e_target &amp;&amp; ev._s) {
                if (e_target.matches(ev._s)) {
                    return e_target;
                }
                return e_target.inside(ev._s) || undefined;
            }
        }
    });

    // Notify when someone subscribes to an UI:* event
    // if so: then we might need to define a customEvent for it:
    // alse define the specific DOM-methods that can be called on the eventobject: &#x60;stopPropagation&#x60; and &#x60;stopImmediatePropagation&#x60;
    Event.notify(UI+&#x27;*&#x27;, _setupDomListener, Event)
         ._setEventObjProperty(&#x27;stopPropagation&#x27;, function() {this.status.ok || (this.status.propagationStopped = this.target);})
         ._setEventObjProperty(&#x27;stopImmediatePropagation&#x27;, function() {this.status.ok || (this.status.immediatePropagationStopped = this.target);});

    // Notify when someone subscribes to any event at all --&gt; we might need to transform the filterFn from a selector into a true fnction
    // this is already done automaticly by _setupDomListener fo UI:* events
    Event.notify(&#x27;*:*&#x27;, function(customEvent, subscriber) {
        var eventSplitted = customEvent.split(&#x27;:&#x27;),
            emitterName = eventSplitted[0];
        if ((emitterName!==&#x27;UI&#x27;) &amp;&amp; (typeof subscriber.f===&#x27;string&#x27;)) {
            // now transform the subscriber&#x27;s filter from css-string into a filterfunction
            _selToFunc(customEvent, subscriber);
        }
    }, Event);

    // Notify when someone detaches an UI:* event
    // if so: then we might need to detach the native listener on &#x60;document&#x60;
    Event.notifyDetach(UI+&#x27;*&#x27;, _teardownDomListener, Event);

    Event._sellist = [_domSelToFunc];

    _setupEvents();

    // making Element to be able to emit using event-emitter.
    // NOT only HTMLElements --&gt; SVGElements need to have this emitter to:
    (function(ElementPrototype) {
        ElementPrototype.merge(Event.Emitter(&#x27;UI&#x27;));

       /**
        * Gets one Element, specified by the css-selector. Either when alreasy available, or when it gets inserted in the dom.
        * To retrieve a single element by id,
        * you need to prepend the id-name with a &#x60;#&#x60;. When multiple Element&#x27;s match, the first is returned.
        *
        * Returns a Promise with the Element as variable.
        *
        * @method getElementOnAvailable
        * @for Element
        * @param cssSelector {String} css-selector to match
        * @param [inspectProtectedNodes=false] {Boolean} no deepsearch in protected Nodes or iTags --&gt; by default, these elements should be hidden
        * @return {Promise} with the Element that was search for as variable.
        * @since 0.0.1
        */
        ElementPrototype.getElementOnAvailable = function(cssSelector, inspectProtectedNodes) {
            var instance = this;
            // node not currently in the dom --&gt; setup a listener:
            return new window.Promise(function(resolve) {
                var node, listener;
                node = instance.getElement(cssSelector, inspectProtectedNodes);
                if (node) {
                    resolve(node);
                }
                else {
                    listener = Event.after(&#x27;nodeinsert&#x27;, function() {
                        // because it could be that &#x60;inspectProtectedNodes&#x60; prevents the node from return as a truthy value,
                        // we need to check again if the new node matches:
                        var newnode = instance.getElement(cssSelector, inspectProtectedNodes);
                        if (newnode) {
                            resolve(newnode);
                            listener.detach();
                        }
                    }, cssSelector);
                }
            });
        };

    }(window.Element.prototype));

    DOCUMENT.getElementOnAvailable = function(cssSelector, inspectProtectedNodes) {
        return DOCUMENT.documentElement.getElementOnAvailable(cssSelector, inspectProtectedNodes);
    };

    // Notify when someone subscribes to an UI:* event
    // if so: then we might need to define a customEvent for it:
    // alse define the specific DOM-methods that can be called on the eventobject: &#x60;stopPropagation&#x60; and &#x60;stopImmediatePropagation&#x60;
    Event.notify(MUTATION_EVENTS, _setupMutationListener, Event);

    // Notify when someone detaches an UI:* event
    // if so: then we might need to detach the native listener on &#x60;document&#x60;
    Event.notifyDetach(MUTATION_EVENTS, _teardownMutationListener, Event);

    // Note: window.document has no prototype
    DOCUMENT.suppressMutationEvents = function(suppress) {
        this._suppressMutationEvents = suppress;
    };

    // Event.noDeepDomEvt and Event._domCallback are the only method that is added to Event.
    // We need to do this, because &#x60;event-mobile&#x60; needs access to the same method.
    // We could have done without this method and instead listen for a custom-event to handle
    // Mobile events, however, that would lead into 2 eventcycli which isn&#x27;t performant.

   /**
    *
    * @method noDeepDomEvt
    * @param domEvent {String} the eventName that should be processed without deepsearch
    * @param e {Object} eventobject
    * @for Event
    * @chainable
    * @since 0.0.1
    */
    Event.noDeepDomEvt = function(domEvent) {
        domEvent.contains(&#x27;:&#x27;) || (domEvent=UI+domEvent);
        NO_DEEP_SEARCH[domEvent] = true;
        return this;
    };

   /**
    * Does the actual transportation from DOM-events into the Eventsystem. It also looks at the response of
    * the Eventsystem: on e.halt() or e.preventDefault(), the original DOM-event will be preventDefaulted.
    *
    * @method _domCallback
    * @param eventName {String} the customEvent that is transported to the eventsystem
    * @param e {Object} eventobject
    * @private
    * @since 0.0.1
    */
    Event._domCallback = function(e) {
        _evCallback(e);
    };

    // store module:
    window._ITSAmodules.EventDom = Event;
    return Event;
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
