<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/vdom/partials/extend-element.js - Itsa</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Itsa"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/DD.html">DD</a></li>
            
                <li><a href="../classes/document.html">document</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/FocusManager.html">FocusManager</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/NS-vdom.html">NS-vdom</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Plugins.html">Plugins</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/String.html">String</a></li>
            
                <li><a href="../classes/USERAGENT.html">USERAGENT</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vnode.html">vnode</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/attribute-extractor.html">attribute-extractor</a></li>
            
                <li><a href="../modules/drag.html">drag</a></li>
            
                <li><a href="../modules/drag-drop.html">drag-drop</a></li>
            
                <li><a href="../modules/element-array.html">element-array</a></li>
            
                <li><a href="../modules/element-plugin.html">element-plugin</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-hover.html">event-hover</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/event-mobile.html">event-mobile</a></li>
            
                <li><a href="../modules/extend-document.html">extend-document</a></li>
            
                <li><a href="../modules/extend-element.html">extend-element</a></li>
            
                <li><a href="../modules/focusmanager.html">focusmanager</a></li>
            
                <li><a href="../modules/html-parser.html">html-parser</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/itsa.build.html">itsa.build</a></li>
            
                <li><a href="../modules/js-ext.html">js-ext</a></li>
            
                <li><a href="../modules/lib_array.js.html">lib/array.js</a></li>
            
                <li><a href="../modules/lib_function.js.html">lib/function.js</a></li>
            
                <li><a href="../modules/lib_object.js.html">lib/object.js</a></li>
            
                <li><a href="../modules/lib_promise.s.html">lib/promise.s</a></li>
            
                <li><a href="../modules/lib_string.js.html">lib/string.js</a></li>
            
                <li><a href="../modules/node-parser.html">node-parser</a></li>
            
                <li><a href="../modules/node-win.html">node-win</a></li>
            
                <li><a href="../modules/useragent.html">useragent</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/vdom.html">vdom</a></li>
            
                <li><a href="../modules/vdom-ns.html">vdom-ns</a></li>
            
                <li><a href="../modules/vnode.html">vnode</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/vdom/partials/extend-element.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;

/**
 * Provides several methods that override native Element-methods to work with the vdom.
 *
 *
 * &lt;i&gt;Copyright (c) 2014 ITSA - https://github.com/itsa&lt;/i&gt;
 * &lt;br&gt;
 * New BSD License - http://choosealicense.com/licenses/bsd-3-clause/
 *
 * @module vdom
 * @submodule extend-element
 * @class Element
 * @since 0.0.1
*/


require(&#x27;../css/element.css&#x27;);
require(&#x27;js-ext/lib/object.js&#x27;);
require(&#x27;js-ext/lib/string.js&#x27;);
require(&#x27;js-ext/lib/promise.js&#x27;);
require(&#x27;polyfill&#x27;);

module.exports = function (window) {

    window._ITSAmodules || Object.protectedProp(window, &#x27;_ITSAmodules&#x27;, {});

    if (window._ITSAmodules.ExtendElement) {
        return; // ExtendElement was already created
    }

    // prevent double definition:
    window._ITSAmodules.ExtendElement = true;

    var NAME = &#x27;[extend-element]: &#x27;,
        ElementArray = require(&#x27;./element-array.js&#x27;)(window),
        domNodeToVNode = require(&#x27;./node-parser.js&#x27;)(window),
        htmlToVNodes = require(&#x27;./html-parser.js&#x27;)(window),
        vNodeProto = require(&#x27;./vnode.js&#x27;)(window),
        NS = require(&#x27;./vdom-ns.js&#x27;)(window),
        RUNNING_ON_NODE = (typeof global !== &#x27;undefined&#x27;) &amp;&amp; (global.window!==window),
        TRANSITION = &#x27;transition&#x27;,
        TRANSFORM = &#x27;transform&#x27;,
        BROWSERS_SUPPORT_PSEUDO_TRANS = false, // set true as soon as they do
        SUPPORTS_PSEUDO_TRANS = null, // is a life check --&gt; is irrelevant as long BROWSERS_SUPPORT_PSEUDO_TRANS === false
        VENDOR_CSS = require(&#x27;polyfill/extra/vendorCSS.js&#x27;)(window),
        generateVendorCSSProp = VENDOR_CSS.generator,
        VENDOR_CSS_PROPERTIES = VENDOR_CSS.cssProps,
        VENDOR_TRANSFORM_PROPERTY = generateVendorCSSProp(TRANSFORM),
        VENDOR_TRANSITION_PROPERTY = require(&#x27;polyfill/extra/transition.js&#x27;)(window), // DO NOT use TRANSITION-variable here --&gt; browserify cannot deal this
        EV_TRANSITION_END = require(&#x27;polyfill/extra/transitionend.js&#x27;)(window),
        _BEFORE = &#x27;:before&#x27;,
        _AFTER = &#x27;:before&#x27;,
        extractor = require(&#x27;./attribute-extractor.js&#x27;)(window),
        UTILS = require(&#x27;utils&#x27;),
        later = UTILS.laterSilent,
        async = UTILS.asyncSilent,
        idGenerator = UTILS.idGenerator,
        DOCUMENT = window.document,
        nodeids = NS.nodeids,
        arrayIndexOf = Array.prototype.indexOf,
        POSITION = &#x27;position&#x27;,
        ITSA_ = &#x27;itsa-&#x27;,
        BLOCK = ITSA_+&#x27;block&#x27;,
        BORDERBOX = ITSA_+&#x27;borderbox&#x27;,
        NO_TRANS = ITSA_+&#x27;notrans&#x27;,
        NO_TRANS2 = NO_TRANS+&#x27;2&#x27;, // needed to prevent removal of NO_TRANS when still needed &#x60;notrans&#x60;
        INVISIBLE = ITSA_+&#x27;invisible&#x27;,
        INVISIBLE_RELATIVE = INVISIBLE+&#x27;-relative&#x27;,
        HIDDEN = ITSA_+&#x27;hidden&#x27;,
        REGEXP_NODE_ID = /^#\S+$/,
        LEFT = &#x27;left&#x27;,
        TOP = &#x27;top&#x27;,
        BORDER = &#x27;border&#x27;,
        WIDTH = &#x27;width&#x27;,
        HEIGHT = &#x27;height&#x27;,
        STRING = &#x27;string&#x27;,
        CLASS = &#x27;class&#x27;,
        STYLE = &#x27;style&#x27;,
        OVERFLOW = &#x27;overflow&#x27;,
        SCROLL = &#x27;scroll&#x27;,
        BORDER_LEFT_WIDTH = BORDER+&#x27;-left-&#x27;+WIDTH,
        BORDER_RIGHT_WIDTH = BORDER+&#x27;-right-&#x27;+WIDTH,
        BORDER_TOP_WIDTH = BORDER+&#x27;-top-&#x27;+WIDTH,
        BORDER_BOTTOM_WIDTH = BORDER+&#x27;-bottom-&#x27;+WIDTH,
        NUMBER = &#x27;number&#x27;,
        PX = &#x27;px&#x27;,
        SET = &#x27;set&#x27;,
        TOGGLE = &#x27;toggle&#x27;,
        REPLACE = &#x27;replace&#x27;,
        REMOVE = &#x27;remove&#x27;,
        _STARTSTYLE = &#x27;_startStyle&#x27;,
        setupObserver,
        SIBLING_MATCH_CHARACTER = {
            &#x27;+&#x27;: true,
            &#x27;~&#x27;: true
        },
        NON_CLONABLE_STYLES = {
            absolute: true,
            hidden: true,
            block: true
        },
        CSS_PROPS_TO_CALCULATE = { // http://www.w3.org/TR/css3-transitions/#animatable-css
            backgroundColor: true,
            backgroundPositionX: true,
            backgroundPositionY: true,
            borderBottomColor: true,
            borderBottomWidth: true,
            borderLeftColor: true,
            borderLeftWidth: true,
            borderRightColor: true,
            borderRightWidth: true,
            borderTopColor: true,
            borderTopWidth: true,
            borderSpacing: true,
            bottom: true,
            clip: true,
            color: true,
            fontSize: true,
            fontWeight: true,
            height: true,
            left: true,
            letterSpacing: true,
            lineHeight: true,
            marginBottom: true,
            marginTop: true,
            marginLeft: true,
            marginRight: true,
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true,
            opacity: true,
            outlineColor: true,
            outlineWidth: true,
            paddingBottom: true,
            paddingTop: true,
            paddingLeft: true,
            paddingRight: true,
            right: true,
            textIndent: true,
            textShadow: true,
            verticalAlign: true,
            // visibility: true,  DO NOT use visibility!
            width: true,
            wordSpacing: true,
            zIndex: true
        },
        // CSS_PROPS_TO_CALCULATE.transform is set later on by the vendor specific transform-property
        htmlToVFragments = function(html) {
            var vnodes = htmlToVNodes(html, vNodeProto),
                len = vnodes.length,
                vnode, i, bkpAttrs, bkpVChildNodes;
            for (i=0; i&lt;len; i++) {
                vnode = vnodes[i];
                if (vnode.nodeType===1) {
                    // same tag --&gt; only update what is needed
                    bkpAttrs = vnode.attrs;
                    bkpVChildNodes = vnode.vChildNodes;

                    // reset, to force creation of inner domNodes:
                    vnode.attrs = {};
                    vnode.vChildNodes = [];

                    // next: sync the vnodes:
                    vnode._setAttrs(bkpAttrs);
                    vnode._setChildNodes(bkpVChildNodes);
                }
                else {
                    vnode.domNode.nodeValue = vnode.text;
                }
            }
            return {
                isFragment: true,
                vnodes: vnodes
            };
        },
        toCamelCase = function(input) {
            input || (input=&#x27;&#x27;);
            return input.replace(/-(.)/g, function(match, group) {
                return group.toUpperCase();
            });
        },
        fromCamelCase = function(input) {
            input || (input=&#x27;&#x27;);
            return input.replace(/[a-z]([A-Z])/g, function(match, group) {
                return match[0]+&#x27;-&#x27;+group.toLowerCase();
            });
        },
        getVendorCSS = function(cssProperties) {
            var uniqueProps = {},
                i, len, prop, safeProperty, uniqueSafeProperty;
            len = cssProperties.length;
            for (i=len-1; i&gt;=0; i--) {
                // set the right property, but also dedupe when there are multiple same vendor-properties
                prop = cssProperties[i];
                safeProperty = prop.property;
                if (safeProperty) {
                    safeProperty = fromCamelCase(safeProperty);
                    uniqueSafeProperty = safeProperty+&#x27;#&#x27;+prop.pseudo;
                    VENDOR_CSS_PROPERTIES[safeProperty] || (safeProperty=generateVendorCSSProp(safeProperty));
                    if (uniqueProps[uniqueSafeProperty]) {
                        cssProperties.splice(i, 1);
                    }
                    else {
                        uniqueProps[uniqueSafeProperty] = true;
                        prop.property = safeProperty;
                    }
                }
            }
            return cssProperties;
        },
        vendorSupportsPseudoTrans = function() {
            // DO NOT CHANGE THIS FUNCTION!
            // it does exactly what it should do:
            // Sarari seems to support speudo transmisions, however it calculates css-properties wrong when they are &#x27;undefined&#x27;
            // within a specific node, while the &#x27;non-pseudo&#x27; is defined.
            // This would lead into a wrong calculation (too many) of the number of expected transitionend-events
            // Thus, this feature is disabled in some specific browsers
            if (SUPPORTS_PSEUDO_TRANS) {
                return SUPPORTS_PSEUDO_TRANS;
            }
            var cssnode, node, nodeParent;
            DOCUMENT.body.prepend(&#x27;&lt;style id=&quot;vendorSupportsPseudoTrans_css&quot; type=&quot;text/css&quot;&gt;#vendorSupportsPseudoTransParent {background-color:#F00;} #vendorSupportsPseudoTrans {background-color:#00F;}&lt;/style&gt;&#x27;);
            DOCUMENT.body.prepend(&#x27;&lt;div id=&quot;vendorSupportsPseudoTransParent&quot;&gt;&lt;div id=&quot;vendorSupportsPseudoTrans&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;);
            node = DOCUMENT.getElement(&#x27;#vendorSupportsPseudoTrans&#x27;);
            nodeParent = DOCUMENT.getElement(&#x27;#vendorSupportsPseudoTransParent&#x27;);
            cssnode = DOCUMENT.getElement(&#x27;#vendorSupportsPseudoTrans_css&#x27;);
            SUPPORTS_PSEUDO_TRANS = node.getStyle(&#x27;background-color&#x27;)!==node.getStyle(&#x27;background-color&#x27;, &#x27;:before&#x27;);
            cssnode.remove();
            nodeParent.remove();
            return SUPPORTS_PSEUDO_TRANS;
        },
        getTransPromise = function(node, hasTransitionedStyle, removalPromise, afterTransEventsNeeded, transitionProperties, maxtranstime) {
            var promise, fallback;
            afterTransEventsNeeded || (afterTransEventsNeeded=1);
            if (hasTransitionedStyle) {
                promise = new window.Promise(function(fulfill) {
                    var afterTrans = function(e) {
                        var finishedProperty = e.propertyName,
                            index;
                        if (finishedProperty) {
                            // some browsers support this feature: now we can exactly determine what promise to fulfill
                            delete transitionProperties[finishedProperty];
                            // in case of shorthand properties (such as padding) allmost all browsers
                            // fire multiple detailed events (http://www.smashingmagazine.com/2013/04/26/css3-transitions-thank-god-specification/).
                            // therefore, we also must delete the shortcut property when a detailed property gets fired:
                            index = finishedProperty.indexOf(&#x27;-&#x27;);
                            if (index!==-1) {
                                finishedProperty = finishedProperty.substr(0, index);
                                delete transitionProperties[finishedProperty];
                            }
                            // now fulfill when empty:
                            if (transitionProperties.isEmpty()) {
                                fallback.cancel();
                                console.log(&#x27;Transition fulfilled&#x27;);
                                node.removeEventListener(EV_TRANSITION_END, afterTrans, true);
                                fulfill();
                            }
                        }
                        else {
                            // in cae the browser doesn&#x27;t support e.propertyName, we need to countdown:
                            if (--afterTransEventsNeeded&lt;=0) {
                                fallback.cancel();
                                node.removeEventListener(EV_TRANSITION_END, afterTrans, true);
                                console.log(&#x27;Transition fulfilled by counting nr. of endTransition events&#x27;);
                                fulfill();
                            }
                        }
                    };
                    if (EV_TRANSITION_END===undefined) {
                        // no transition supported
                        console.log(&#x27;No endTransition events supported: transition fulfilled&#x27;);
                        fulfill();
                    }
                    else {
                        node.addEventListener(EV_TRANSITION_END, afterTrans, true);
                        fallback = later(function(){
                            console.log(&#x27;Transition fulfilled by timer&#x27;);
                            fulfill();
                        }, maxtranstime*1000+50); // extra 50 ms, after all, it is a fallback, we don&#x27;t want it to take over the original end-transition-events
                    }
                });
                removalPromise &amp;&amp; (promise=window.Promise.finishAll([promise, removalPromise]));
            }
            else {
                promise = removalPromise || window.Promise.resolve();
            }
            return promise;
        },
        getClassTransPromise = function(node, method, className, extraData1, extraData2) {
            // first. check if the final node has a transitioned property.
            // If not, then return as fulfilled. If so, then check for all the transitioned properties,
            // if there is any who changes its calculated value. If not, then return as fulfilled. If so, then setup
            // the evenlistener
            var resolvedPromise = window.Promise.resolve(),
                currentInlineCSS = [],
                finalInlineCSS = [],
                finalNode, getsTransitioned, originalCSS, finalCSS, transPropertiesElement, transPropertiesBefore, transPropertiesAfter, bkpFreezedData1, endIntermediate,
                promise, finalCSS_before, finalCSS_after, transpromise, manipulated, getCurrentProperties, currentProperties, bkpNodeData, bkpFreezed, cleanup,
                originalCSS_before, originalCSS_after, searchTrans, generateInlineCSS, finalStyle, unFreeze, freezedExtraData1, startStyle, unfreezePromise,
                transprops, transpropsBefore, transpropsAfter, time1, time2;

            time1 = Date.now();
            bkpNodeData = idGenerator(&#x27;bkpNode&#x27;);
            bkpFreezed = idGenerator(&#x27;bkpFreezed&#x27;);
            bkpFreezedData1 = idGenerator(&#x27;bkpFreezedData1&#x27;);
            if ((method===TOGGLE) &amp;&amp; !extraData1) {
                // because -when toggling- the future current node-class might have been changed:
                freezedExtraData1 = !node.hasClass(className);
            }
            unFreeze = function(options) {
                var bkpFreezedStyle = node.getData(bkpFreezed),
                    finish = options &amp;&amp; options.finish,
                    cancel = options &amp;&amp; options.cancel,
                    transitioned = !finish;
                bkpFreezedData1 = node.getData(bkpFreezedData1);
                if (bkpFreezedStyle!==undefined) {
                    if (finish || cancel) {
                        node.setClass(NO_TRANS2);
                    }
                    else {
                        node.setData(_STARTSTYLE, bkpFreezedStyle);
                    }
                    if (!cancel) {
                        switch(method) {
                            case SET:
                                unfreezePromise = node.setClass(className, transitioned);
                            break;
                            case REPLACE:
                                unfreezePromise = node.replaceClass(extraData1, className, extraData2, transitioned);
                            break;
                            case REMOVE:
                                unfreezePromise = node.removeClass(className, transitioned);
                            break;
                            case TOGGLE:
                                unfreezePromise = node.toggleClass(className, (bkpFreezedData1===undefined) ? extraData1 : bkpFreezedData1, transitioned);
                            break;
                        }
                    }
                    else {
                        unfreezePromise = resolvedPromise;
                    }
                    async(function() {
                        node.removeData(bkpFreezed);
                        node.removeData(bkpFreezedData1);
                    });
                    if (finish || cancel) {
                        finalStyle = finalNode.getAttr(STYLE);
                        node.setAttr(STYLE, finalStyle);
                        later(function() { // not just async --&gt; it seems we need more time
                            node.removeClass(NO_TRANS2);
                        }, 50);
                        unfreezePromise = resolvedPromise;
                    }
                    return unfreezePromise;
                }
                return promise;
            };

            resolvedPromise.cancel = function() { /* NOOP for compatibility */ };
            resolvedPromise.freeze = function() { return window.Promise.resolve(0); /* compatibility */ };
            resolvedPromise.unfreeze = unFreeze;
            resolvedPromise.finish = function() { /* NOOP for compatibility */ };
            if (EV_TRANSITION_END===undefined) {
                return resolvedPromise;
            }
            cleanup = function() {
                // we manipulate the classes as they should be, before returning the original inline style:
                // all without Promise-return!
                if (!promise.cancelled &amp;&amp; !promise.frozen) {
                    switch(method) {
                        case SET:
                            node.setClass(className);
                        break;
                        case REPLACE:
                            node.replaceClass(extraData1, className, extraData2);
                        break;
                        case REMOVE:
                            node.removeClass(className);
                        break;
                        case TOGGLE:
                            node.toggleClass(className, extraData1);
                        break;
                    }
                }
                // last transitionrun: reset the inline css:
                finalStyle = finalNode.getAttr(STYLE);
                if (!promise.frozen) {
                    node.removeData(bkpFreezed);
                    node.removeData(bkpFreezedData1);
                    node.setClass(NO_TRANS2);
                    node.setAttr(STYLE, finalStyle);
                }
                else {
                    node.setData(bkpFreezed, finalStyle);
                }
                node.removeData(bkpNodeData);
                finalNode.remove();
                async(function() {
                    node.removeClass(NO_TRANS2);
                    promise.fulfill();
                });
            };
            endIntermediate = function(type) {
                if (!promise.isFulfilled) {
                    manipulated = true;
                    node.setData(bkpFreezedData1, freezedExtraData1);
                    currentProperties = getCurrentProperties(node, transprops);
                    node.setClass(NO_TRANS2);
                    node.setInlineStyles(currentProperties, false, true);
                    if (BROWSERS_SUPPORT_PSEUDO_TRANS) {
                        node.setInlineStyles(getCurrentProperties(node, transpropsBefore, &#x27;:before&#x27;), false, true);
                        node.setInlineStyles(getCurrentProperties(node, transpropsAfter, &#x27;:after&#x27;), false, true);
                    }
                    // also force to set the style on the node outside the vdom --&gt; by forcing this
                    // we won&#x27;t run into the situation where the vdom doesn&#x27;t change the dom because the style didn&#x27;;&#x27;t change:
                    node._setAttribute(STYLE, node.getAttr(STYLE));
                    Object.defineProperty(promise, &#x27;isFulfilled&#x27;, {
                        configurable: false,
                        enumerable: false,
                        writable: false,
                        value: true
                    });
                    Object.defineProperty(promise, type, {
                        configurable: false,
                        enumerable: false,
                        writable: false,
                        value: true
                    });
                    if (transpromise) {
                        transpromise.reject(); // prevent transitionpromise to set its own final values after finishing
                    }
                    else {
                        // in case &#x60;transpromise&#x60; wasn&#x27;t setup yet:
                        async(function() {
                            transpromise.reject(); // prevent transitionpromise to set its own final values after finishing
                        });
                    }
                }
                time2 || (time2=Date.now());
                return new window.Promise(function(resolve) {
                    async(function() {
                        resolve(time2-time1);
                    });
                });
            };
            searchTrans = function(CSS1, CSS2, transProperties) {
                var allTrans = !!transProperties.all,
                    searchObject = allTrans ? CSS_PROPS_TO_CALCULATE : transProperties,
                    transprops = {};

                searchObject.each(function(transProp, key) {
                    // transProp will always be a vendor-specific property already
                    key = toCamelCase(key);
                    if (CSS1[key]!==CSS2[key]) {
                        transprops[key] = true;
                    }
                });
                return (transprops.size()&gt;0) ? transprops : null;
            };
            generateInlineCSS = function(group, transProperties, CSS1, CSS2) {
                transProperties.each(function(value, key) {
                    var prop1 = {property: key, value: CSS1[key]},
                        prop2 = {property: key, value: CSS2[key]};
                    if (group) {
                        prop1.pseudo = group;
                        prop2.pseudo = group;
                    }
                    currentInlineCSS[currentInlineCSS.length] = prop1;
                    finalInlineCSS[finalInlineCSS.length] = prop2;
                });
            };

            getCurrentProperties = function(node, transProperties, group) {
                var props = [],
                    styles = window.getComputedStyle(node, group);
                transProperties.each(function(value, property) {
                    // if property is vendor-specific transition, or transform, than we reset it to the current vendor
                    props.push({
                        property: property,
                        value: styles[toCamelCase(property)],
                        pseudo: group
                    });
                });
                return props;
            };

            finalNode = node.cloneNode(true);
            finalNode.setClass(NO_TRANS2);
            finalNode.setClass(INVISIBLE);
            node.setData(bkpNodeData, finalNode);

            startStyle = node.getData(_STARTSTYLE);
            if (startStyle!==undefined) {
                finalNode.setAttr(STYLE, startStyle);
                node.removeData(_STARTSTYLE);
            }

            switch(method) {
                case SET:
                    finalNode.setClass(className);
                break;
                case REPLACE:
                    finalNode.replaceClass(extraData1, className, extraData2);
                break;
                case REMOVE:
                    finalNode.removeClass(className);
                break;
                case TOGGLE:
                    finalNode.toggleClass(className, extraData1);
                break;
            }
            // insert in the dom, to make its style calculatable:
            DOCUMENT.body.append(finalNode);

            // check the css-property &#x60;transition&#x60;
            finalNode.removeClass(NO_TRANS2);
            transPropertiesElement = finalNode.getStyle(TRANSITION);
            transPropertiesBefore = finalNode.getStyle(TRANSITION, _BEFORE);
            transPropertiesAfter = finalNode.getStyle(TRANSITION, _AFTER);
            finalNode.setClass(NO_TRANS2);
            getsTransitioned = false;
            if (!RUNNING_ON_NODE &amp;&amp; ((transPropertiesElement.size()&gt;0) || (transPropertiesBefore.size()&gt;0) || (transPropertiesAfter.size()&gt;0))) {
                // when code comes here, there are one or more properties that can be transitioned
                // check if their values differ from the original node
                originalCSS = window.getComputedStyle(node);
                originalCSS_before = window.getComputedStyle(node, _BEFORE);
                originalCSS_after = window.getComputedStyle(node, _AFTER);
                finalCSS = window.getComputedStyle(finalNode);
                finalCSS_before = window.getComputedStyle(finalNode, _BEFORE);
                finalCSS_after = window.getComputedStyle(finalNode, _AFTER);
/*jshint boss:true */
                if (transprops=searchTrans(originalCSS, finalCSS, transPropertiesElement)) {
/*jshint boss:false */
                    getsTransitioned = true;
                    generateInlineCSS(null, transprops, originalCSS, finalCSS);
                }
                if (BROWSERS_SUPPORT_PSEUDO_TRANS &amp;&amp; vendorSupportsPseudoTrans()) {
/*jshint boss:true */
                    if (transpropsBefore=searchTrans(originalCSS_before, finalCSS_before, transPropertiesBefore)) {
/*jshint boss:false */
                        getsTransitioned = true;
                        generateInlineCSS(_BEFORE, transpropsBefore, originalCSS_before, finalCSS_before);
                    }
/*jshint boss:true */
                    if (transpropsAfter=searchTrans(originalCSS_after, finalCSS_after, transPropertiesAfter)) {
/*jshint boss:false */
                        getsTransitioned = true;
                        generateInlineCSS(_AFTER, transpropsAfter, originalCSS_after, finalCSS_after);
                    }
                }
            }
            if (getsTransitioned) {
                // to force the transitioned items to work, we will set their calculated inline values for both at the start as well
                // as on the end of the transition.
                // set the original css inline:
                promise = window.Promise.manage();
                promise.finally(function() {
                    time2 || (time2=Date.now());
                });
                node.setClass(NO_TRANS2);
                node.setInlineStyles(currentInlineCSS, false, true);
                async(function() {
                    if (!manipulated) {
                        node.removeClass(NO_TRANS2);
                        transpromise = node.setInlineStyles(finalInlineCSS, true, true);
                        transpromise.finally(function() {
                            // async &#x60;setAttr&#x60; --&gt; only fulfill when the DOM has been updated
                            async(function() {
                                cleanup();
                            });
                        });
                    }
                });

                promise.cancel = function() {
                    return endIntermediate(&#x27;cancelled&#x27;);
                };

                promise.freeze = function() {
                    return endIntermediate(&#x27;frozen&#x27;);
                };

                promise.finish = function() {
                    return endIntermediate(&#x27;finished&#x27;);
                };

                promise.unfreeze = unFreeze;

                return promise;
            }
            else {
                switch(method) {
                    case SET:
                        node.setClass(className);
                    break;
                    case REPLACE:
                        node.replaceClass(extraData1, className, extraData2);
                    break;
                    case REMOVE:
                        node.removeClass(className);
                    break;
                    case TOGGLE:
                        node.toggleClass(className, extraData1);
                    break;
                }
                node.removeData(bkpNodeData);
                finalNode.remove();
            }

            return resolvedPromise;
        },
        classListProto = {
            add: function(className) {
                // we do not use the property className, but setAttribute, because setAttribute can be hacked by other modules like &#x60;vdom&#x60;
                // note: &#x60;this&#x60; is the returned object which is NOT the Elementinstance
                var thisobject = this,
                    element = thisobject.element,
                    doSet = function(cl) {
                        var clName = element.vnode.attrs[CLASS] || &#x27;&#x27;;
                        // we do not use the property className, but setAttribute, because setAttribute can be hacked by other modules like &#x60;vdom&#x60;
                        thisobject.contains(cl) || (element.setAttribute(CLASS, clName+((clName.length&gt;0) ? &#x27; &#x27; : &#x27;&#x27;) + cl));
                    };
                if (typeof className === STRING) {
                    doSet(className);
                }
                else if (Array.isArray(className)) {
                    className.forEach(doSet);
                }
            },
            remove: function(className) {
                var element = this.element,
                    doRemove = function(cl) {
                        var clName = element.vnode.attrs[CLASS] || &#x27;&#x27;,
                            regexp = new RegExp(&#x27;(?:^|\\s+)&#x27; + cl + &#x27;(?:\\s+|$)&#x27;, &#x27;g&#x27;);
                        // we do not use the property className, but setAttribute, because setAttribute can be hacked by other modules like &#x60;vdom&#x60;
                        // note: &#x60;this&#x60; is the returned object which is NOT the Elementinstance
                        element.setAttribute(CLASS, clName.replace(regexp, &#x27; &#x27;).trim());
                    };
                if (typeof className === STRING) {
                    doRemove(className);
                }
                else if (Array.isArray(className)) {
                    className.forEach(doRemove);
                }
                (element.vnode.attrs[CLASS]===&#x27;&#x27;) &amp;&amp; element.removeAttr(CLASS);
            },
            toggle: function(className, forceState) {
                // we do not use the property className, but setAttribute, because setAttribute can be hacked by other modules like &#x60;vdom&#x60;
                // note: &#x60;this&#x60; is the returned object which is NOT the Elementinstance
                var thisobject = this,
                    doToggle = function(cl) {
                        if (typeof forceState === &#x27;boolean&#x27;) {
                            forceState ? thisobject.add(cl) : thisobject.remove(cl);
                        }
                        else {
                            thisobject.contains(cl) ? thisobject.remove(cl) : thisobject.add(cl);
                        }
                    };
                if (typeof className === STRING) {
                    doToggle(className);
                }
                else if (Array.isArray(className)) {
                    className.forEach(doToggle);
                }
            },
            contains: function(className) {
                // we do not use the property className, but setAttribute, because setAttribute can be hacked by other modules like &#x60;vdom&#x60;
                // note: &#x60;this&#x60; is the returned object which is NOT the Elementinstance.
                // May be an Array of classNames, which all needs to be present.
                return this.element.vnode.hasClass(className);
            },
            item: function(index) {
                var items = this.element.vnode.attrs[&#x27;class&#x27;].split(&#x27; &#x27;);
                return items[index];
            },
            _init: function(element) {
                this.element = element;
            }
        },
        treeWalkerProto = {
            _init: function(element, whatToShow, filter) {
                var instance = this;
                if (typeof filter !== &#x27;function&#x27;) {
                    // check if it is a NodeFilter-object
                    filter &amp;&amp; filter.acceptNode &amp;&amp; (filter=filter.acceptNode);
                }
                (typeof filter===&#x27;function&#x27;) || (filter=null);
                instance.vNodePointer = element.vnode;
                instance._root = element;
                whatToShow || (whatToShow=-1); // -1 equals NodeFilter.SHOW_ALL
                (whatToShow===-1) &amp;&amp; (whatToShow=133);
                instance._whatToShow = whatToShow; // making it accessable for the getter &#x60;whatToShow&#x60;
                instance._filter = filter; // making it accessable for the getter &#x60;filter&#x60;
            },
            _match: function(vnode, forcedVisible) {
                var whatToShow = this._whatToShow,
                    filter = this._filter,
                    showElement = ((whatToShow &amp; 1)!==0),
                    showComment = ((whatToShow &amp; 128)!==0),
                    showText = ((whatToShow &amp; 4)!==0),
                    typeMatch = (showElement &amp;&amp; (vnode.nodeType===1)) || (showComment &amp;&amp; (vnode.nodeType===8)) || (showText &amp;&amp; (vnode.nodeType===3)),
                    visibleMatch = !forcedVisible || (window.getComputedStyle(vnode.domNode).display!==&#x27;none&#x27;),
                    funcMatch = filter ? filter(vnode.domNode) : true;
                return typeMatch &amp;&amp; visibleMatch &amp;&amp; funcMatch;
            },
            firstChild: function() {
                var instance = this,
                    foundVNode = instance.vNodePointer.vFirstChild;
                while (foundVNode &amp;&amp; !instance._match(foundVNode)) {
                    foundVNode = foundVNode.vNext;
                }
                foundVNode &amp;&amp; (instance.vNodePointer=foundVNode);
                return foundVNode &amp;&amp; foundVNode.domNode;
            },
            lastChild: function() {
                var instance = this,
                    foundVNode = instance.vNodePointer.vLastChild;
                while (foundVNode &amp;&amp; !instance._match(foundVNode)) {
                    foundVNode = foundVNode.vPrevious;
                }
                foundVNode &amp;&amp; (instance.vNodePointer=foundVNode);
                return foundVNode &amp;&amp; foundVNode.domNode;
            },
            nextNode: function() {
                var instance = this,
                    foundVNode = instance.vNodePointer.vNext;
                while (foundVNode &amp;&amp; !instance._match(foundVNode, true)) {
                    foundVNode = foundVNode.vNext;
                }
                foundVNode &amp;&amp; (instance.vNodePointer=foundVNode);
                return foundVNode &amp;&amp; foundVNode.domNode;
            },
            nextSibling: function() {
                var instance = this,
                    foundVNode = instance.vNodePointer.vNext;
                while (foundVNode &amp;&amp; !instance._match(foundVNode)) {
                    foundVNode = foundVNode.vNext;
                }
                foundVNode &amp;&amp; (instance.vNodePointer=foundVNode);
                return foundVNode &amp;&amp; foundVNode.domNode;
            },
            parentNode: function() {
                var instance = this,
                    foundVNode = instance.vNodePointer.vParent;
                (foundVNode!==instance._root) &amp;&amp; (instance.vNodePointer=foundVNode);
                return foundVNode &amp;&amp; foundVNode.domNode;
            },
            previousNode: function() {
                var instance = this,
                    foundVNode = instance.vNodePointer.vPrevious;
                while (foundVNode &amp;&amp; !instance._match(foundVNode, true)) {
                    foundVNode = foundVNode.vPrevious;
                }
                foundVNode &amp;&amp; (instance.vNodePointer=foundVNode);
                return foundVNode &amp;&amp; foundVNode.domNode;
            },
            previousSibling: function() {
                var instance = this,
                    foundVNode = instance.vNodePointer.vPrevious;
                while (foundVNode &amp;&amp; !instance._match(foundVNode)) {
                    foundVNode = foundVNode.vPrevious;
                }
                foundVNode &amp;&amp; (instance.vNodePointer=foundVNode);
                return foundVNode &amp;&amp; foundVNode.domNode;
            }
        };

    require(&#x27;window-ext&#x27;)(window);

    Object.defineProperties(treeWalkerProto, {
        &#x27;currentNode&#x27;: {
            get: function() {
                return this.vNodePointer.domNode;
            }
        },
        &#x27;filter&#x27;: {
            get: function() {
                return this._filter;
            }
        },
        &#x27;root&#x27;: {
            get: function() {
                return this._root;
            }
        },
        &#x27;whatToShow&#x27;: {
            get: function() {
                return this._whatToShow;
            }
        }
    });

    // NOTE: &#x60;vnode&#x60; should be a property of Node, NOT Element
    /**
     * Reference to the vnode-object that represents the Node
     *
     * (will autogenerate a vnode, should it not exists)
     *
     * @for Node
     * @property vnode
     * @type vnode
     * @since 0.0.1
     */
    Object.defineProperty(window.Node.prototype, &#x27;vnode&#x27;, {
       get: function() {
            var instance = this,
                vnode = instance._vnode,
                parentNode, parentVNode, index;
            if (!vnode) {
                vnode = instance._vnode = domNodeToVNode(instance);
                parentNode = instance.parentNode;
                 // parentNode.vnode will be an existing vnode, because it runs through the same getter
                // it will only be &#x60;null&#x60; if &#x60;html&#x60; is not virtualised
                parentVNode = parentNode &amp;&amp; parentNode.vnode;
                if (parentVNode) {
                    // set the vnode at the right position of its children:
                    index = arrayIndexOf.call(parentNode.childNodes, instance);
                    vnode._moveToParent(parentVNode, index);
                }
            }
            return vnode;
        },
        set: function() {} // NOOP but needs to be there, otherwise we could clone any domNodes
    });

    CSS_PROPS_TO_CALCULATE[VENDOR_TRANSFORM_PROPERTY] = true;
    CSS_PROPS_TO_CALCULATE[generateVendorCSSProp(TRANSFORM+&#x27;-origin&#x27;)] = true;
    CSS_PROPS_TO_CALCULATE[generateVendorCSSProp(&#x27;perspective&#x27;)] = true;

    (function(ElementPrototype) {

        /**
        * Determines the number of transitionend-events there will occur
        * @method _getEvtTransEndCount
        * @private
        * @since 0.0.1
        */
        ElementPrototype._getEvtTransEndCount = function(cssProperties) {
            var transitions = this.getStyle(TRANSITION),
                timing = {},
                duration, delay, time;
            transitions.each(function(transition) {
                if (!cssProperties || (cssProperties[transition.property])) {
                    duration = transition.duration || 0;
                    delay = transition.delay || 0;
                    time = (duration+delay);
                    timing[time] = true;
                }
            });
            return timing.size();
        };

        /**
        * Returns cascaded &quot;transition&quot; style of all transition-properties. &#x60;Cascaded&#x60; means: the actual present style,
        * the way it is visible (calculated through the DOM-tree).
        *
        * Note1: When &quot;transition&quot; is set inline, ONLY inline transtition is active!
        * Thus, if parentNode has &quot;transition: width 2s&quot; and inline has &quot;transition: height 3s&quot;, then the transition
        * will be &quot;transition: height 3s&quot; --&gt; returning &quot;undefined&quot; for transitionProperty=width.
        * Note2: in case of &quot;transition: all&quot; --&gt; these values will be returned for every &quot;transitionProperty&quot; (even when querying &quot;width&quot;)
        *
        * @method _getTransitionAll
        * @param transitionProperty {String} transform property that is queried, f.e. &quot;width&quot;, or &quot;all&quot;
        * @param [pseudo] {String} to query pseudo-element, fe: &#x60;:before&#x60; or &#x60;:first-line&#x60;
        * @return {Object} the transition-object, with the properties:
        * &lt;ul&gt;
        *     &lt;li&gt;duration {Number}&lt;/li&gt;
        *     &lt;li&gt;timingFunction {String}&lt;/li&gt;
        *     &lt;li&gt;delay {Number}&lt;/li&gt;
        * &lt;/ul&gt;
        * @private
        * @since 0.0.1
        */
        ElementPrototype._getTransitionAll = function(pseudo) {
            var instance = this,
                transProperty, transDuration, transTimingFunction, transDelay, transPropertySplitted, property,
                transitions, transDurationSplitted, transTimingFunctionSplitted, transDelaySplitted, i, len, duration;
            // first look at inline transition:
            transitions = instance.getInlineTransition(null, pseudo);
            if (transitions) {
                return transitions;
            }
            // no inline transitions over here --&gt; calculate using getStyle
            transitions = {};
            transProperty = instance.getStyle(VENDOR_TRANSITION_PROPERTY+&#x27;Property&#x27;, pseudo);
            transDuration = instance.getStyle(VENDOR_TRANSITION_PROPERTY+&#x27;Duration&#x27;, pseudo);
            transTimingFunction = instance.getStyle(VENDOR_TRANSITION_PROPERTY+&#x27;TimingFunction&#x27;, pseudo);
            transDelay = instance.getStyle(VENDOR_TRANSITION_PROPERTY+&#x27;Delay&#x27;, pseudo);
            if (transProperty) {
                transPropertySplitted = transProperty &amp;&amp; transProperty.split(&#x27;,&#x27;);
                transDurationSplitted = transDuration.split(&#x27;,&#x27;);
                transTimingFunctionSplitted = transTimingFunction.split(&#x27;,&#x27;);
                transDelaySplitted = transDelay.split(&#x27;,&#x27;);
                len = transPropertySplitted.length;
                for (i=0; i&lt;len; i++) {
                    property = transPropertySplitted[i];
                    duration = transTimingFunctionSplitted[i];
                    if ((property!==&#x27;none&#x27;) &amp;&amp; (duration!==&#x27;0s&#x27;)) {
                        if (property!==&#x27;all&#x27;) {
                            property = VENDOR_CSS_PROPERTIES[property] || generateVendorCSSProp(property);
                        }
                        transitions[property] = {
                            duration: parseFloat(transDurationSplitted[i]),
                            timingFunction: duration,
                            delay: parseFloat(transDelaySplitted[i])
                        };
                    }
                }
            }
            return transitions;
        };

       /**
        * Appends an Element or an Element&#x27;s string-representation at the end of Element&#x27;s innerHTML, or before the &#x60;refElement&#x60;.
        *
        * @for Element
        * @method append
        * @param content {Element|ElementArray|String} content to append
        * @param [escape] {Boolean} whether to insert &#x60;escaped&#x60; content, leading it into only text inserted
        * @param [refElement] {Element} reference Element where the content should be appended
        * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
        * @return {Element} the created Element (or the last when multiple)
        * @since 0.0.1
        */
        ElementPrototype.append = function(content, escape, refElement, silent) {
            var instance = this,
                vnode = instance.vnode,
                i, len, item, createdElement, vnodes, vRefElement,
            doAppend = function(oneItem) {
                escape &amp;&amp; (oneItem.nodeType===1) &amp;&amp; (oneItem=DOCUMENT.createTextNode(oneItem.getOuterHTML()));
                createdElement = refElement ? vnode._insertBefore(oneItem.vnode, refElement.vnode) : vnode._appendChild(oneItem.vnode);
            };
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            vnode._noSync()._normalizable(false);
            if (refElement &amp;&amp; (vnode.vChildNodes.indexOf(refElement.vnode)!==-1)) {
                vRefElement = refElement.vnode.vNext;
                refElement = vRefElement &amp;&amp; vRefElement.domNode;
            }
            (typeof content===STRING) &amp;&amp; (content=htmlToVFragments(content));
            if (content.isFragment) {
                vnodes = content.vnodes;
                len = vnodes.length;
                for (i=0; i&lt;len; i++) {
                    doAppend(vnodes[i].domNode);
                }
            }
            else if (Array.isArray(content)) {
                len = content.length;
                for (i=0; i&lt;len; i++) {
                    item = content[i];
                    doAppend(item);
                }
            }
            else {
                doAppend(content);
            }
            vnode._normalizable(true)._normalize();
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(false);
            return createdElement;
        };

        /**
         * Adds a node to the end of the list of childNodes of a specified parent node.
         *
         * @method appendChild
         * @param content {Element|ElementArray|String} content to append
         * @param [escape] {Boolean} whether to insert &#x60;escaped&#x60; content, leading it into only text inserted
         * @return {Element} the Element that was appended
         */
        ElementPrototype._appendChild = ElementPrototype.appendChild;
        ElementPrototype.appendChild = function(domNode, escape) {
            return this.append(domNode, escape);
        };

       /**
        * Returns a duplicate of the node. Use cloneNode(true) for a &#x60;deep&#x60; clone.
        *
        * @method cloneNode
        * @param [deep] {Boolean} whether to perform a &#x60;deep&#x60; clone: with all descendants
        * @return {Element} a clone of this Element
        * @since 0.0.1
        */
        ElementPrototype._cloneNode = ElementPrototype.cloneNode;
        ElementPrototype.cloneNode = function(deep) {
            var instance = this,
                vnode = instance.vnode,
                cloned = instance._cloneNode(deep),
                cloneData = function(srcVNode, targetVNode) {
                    if (srcVNode._data) {
                        Object.protectedProp(targetVNode, &#x27;_data&#x27;, {});
                        targetVNode._data.merge(srcVNode._data);
                    }
                },
                cloneDeepData = function(srcVNode, targetVNode) {
                    var srcVChildren = srcVNode.vChildren,
                        targetVChildren = targetVNode.vChildren,
                        len = srcVChildren.length,
                        i, childSrcVNode, childTargetVNode;
                    for (i=0; i&lt;len; i++) {
                        childSrcVNode = srcVChildren[i];
                        childTargetVNode = targetVChildren[i];
                        cloneData(childSrcVNode, childTargetVNode);
                        childSrcVNode.hasVChildren() &amp;&amp; cloneDeepData(childSrcVNode, childTargetVNode);
                    }
                };
            cloned.vnode = domNodeToVNode(cloned);
            cloneData(vnode, cloned.vnode);
            // if deep, then we need to merge _data of all deeper nodes
            deep &amp;&amp; vnode.hasVChildren() &amp;&amp; cloneDeepData(vnode, cloned.vnode);
            return cloned;
        };

        /**
         * Compares the position of the current node against another node in any other document.
         *
         * Returnvalues are a composition of the following bitwise values:
         * &lt;ul&gt;
         *     &lt;li&gt;Node.DOCUMENT_POSITION_DISCONNECTED === 1 (one of the Elements is not part of the dom)&lt;/li&gt;
         *     &lt;li&gt;Node.DOCUMENT_POSITION_PRECEDING === 2 (this Element comes before otherElement)&lt;/li&gt;
         *     &lt;li&gt;Node.DOCUMENT_POSITION_FOLLOWING === 4 (this Element comes after otherElement)&lt;/li&gt;
         *     &lt;li&gt;Node.DOCUMENT_POSITION_CONTAINS === 8 (otherElement trully contains -not equals- this Element)&lt;/li&gt;
         *     &lt;li&gt;Node.DOCUMENT_POSITION_CONTAINED_BY === 16 (Element trully contains -not equals- otherElement)&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * @method compareDocumentPosition
         * @param otherElement {Element}
         * @return {Number} A bitmask, use it this way: if (thisNode.compareDocumentPosition(otherNode) &amp; Node.DOCUMENT_POSITION_FOLLOWING) {// otherNode is following thisNode}
         */
        ElementPrototype.compareDocumentPosition = function(otherElement) {
            // see http://ejohn.org/blog/comparing-document-position/
            var instance = this,
                parent, index1, index2, vChildNodes;
            if (instance===otherElement) {
                return 0;
            }
            if (!DOCUMENT.contains(instance) || !DOCUMENT.contains(otherElement)) {
                return 1;
            }
            else if (instance.contains(otherElement)) {
                return 20;
            }
            else if (otherElement.contains(instance)) {
                return 10;
            }
            parent = instance.getParent();
            vChildNodes = parent.vnode.vChildNodes;
            index1 = vChildNodes.indexOf(instance.vnode);
            index2 = vChildNodes.indexOf(otherElement.vnode);
            if (index1&lt;index2) {
                return 2;
            }
            else {
                return 4;
            }
        };

        /**
         * Indicating whether this Element contains OR equals otherElement.
         *
         * @method contains
         * @param otherElement {Element}
         * @return {Boolean} whether this Element contains OR equals otherElement.
         */
        ElementPrototype.contains = function(otherElement) {
            if (otherElement===this) {
                return true;
            }
            return this.vnode.contains(otherElement.vnode);
        };

        /**
         * Returns a newly created TreeWalker object with this Element as root.
         *
         * The TreeWalker is life presentation of the dom. It gets updated when the dom changes.
         *
         * @method createTreeWalker
         * @param root {Element} The root node at which to begin the NodeIterator&#x27;s traversal.
         * @param [whatToShow] {Number} Filter specification constants from the NodeFilter DOM interface, indicating which nodes to iterate over.
         * You can use or sum one of the next properties:
         * &lt;ul&gt;
         *   &lt;li&gt;window.NodeFilter.SHOW_ALL === -1&lt;/li&gt;
         *   &lt;li&gt;window.NodeFilter.SHOW_ELEMENT === 1&lt;/li&gt;
         *   &lt;li&gt;window.NodeFilter.SHOW_COMMENT === 128&lt;/li&gt;
         *   &lt;li&gt;window.NodeFilter.SHOW_TEXT === 4&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * A treewalker has the next methods:
         * &lt;ul&gt;
         *   &lt;li&gt;treewalker.firstChild()&lt;/li&gt;
         *   &lt;li&gt;treewalker.lastChild()&lt;/li&gt;
         *   &lt;li&gt;treewalker.nextNode()&lt;/li&gt;
         *   &lt;li&gt;treewalker.nextSibling()&lt;/li&gt;
         *   &lt;li&gt;treewalker.parentNode()&lt;/li&gt;
         *   &lt;li&gt;treewalker.previousNode()&lt;/li&gt;
         *   &lt;li&gt;treewalker.previousSibling()&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * A treewalker has the next properties:
         * &lt;ul&gt;
         *   &lt;li&gt;treewalker.currentNode&lt;/li&gt;
         *   &lt;li&gt;treewalker.filter&lt;/li&gt;
         *   &lt;li&gt;treewalker.root&lt;/li&gt;
         *   &lt;li&gt;treewalker.whatToShow&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * @param [filter] {NodeFilter|function} An object implementing the NodeFilter interface or a function. See https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter
         * @return {TreeWalker}
         * @since 0.0.1
         */
        ElementPrototype.createTreeWalker = function(whatToShow, filter) {
            var treeWalker = Object.create(treeWalkerProto);
            treeWalker._init(this, whatToShow, filter);
            return treeWalker;
        };

       /**
        * Sets the inline-style of the Element exactly to the specified &#x60;value&#x60;, overruling previous values.
        * Making the Element&#x27;s inline-style look like: style=&quot;value&quot;.
        *
        * This is meant for a quick one-time setup. For individually inline style-properties to be set, you can use &#x60;setInlineStyle()&#x60;.
        *
        * @method defineInlineStyle
        * @param value {String} the style string to be set
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.defineInlineStyle = function(value) {
            return this.setAttr(STYLE, value);
        };

       /**
        * Empties the content of the Element.
        * Alias for thisNode.vTextContent = &#x27;&#x27;;
        *
        * @method empty
        * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.empty = function(silent) {
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            this.vnode.empty();
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(false);
        };

        /**
         * Reference to the first of sibbling vNode&#x27;s, where the related dom-node is an Element(nodeType===1).
         *
         * @method first
         * @param [cssSelector] {String} to return the first Element that matches the css-selector
         * @return {Element}
         * @since 0.0.1
         */
        ElementPrototype.first = function(cssSelector) {
            return this.vnode.vParent.firstOfVChildren(cssSelector).domNode;
        };

        /**
         * Reference to the first child-Element, where the related dom-node an Element (nodeType===1).
         *
         * @method firstOfChildren
         * @param [cssSelector] {String} to return the first Element that matches the css-selector
         * @return {Element}
         * @since 0.0.1
         */
        ElementPrototype.firstOfChildren = function(cssSelector) {
            var foundVNode = this.vnode.firstOfVChildren(cssSelector);
            return foundVNode &amp;&amp; foundVNode.domNode;
        };

       /**
        * Forces the Element to be inside an ancestor-Element that has the &#x60;overfow=&quot;scroll&quot; set.
        *
        * @method forceIntoNodeView
        * @param [ancestor] {Element} the Element where it should be forced into its view.
        *        Only use this when you know the ancestor and this ancestor has an &#x60;overflow=&quot;scroll&quot;&#x60; property
        *        when not set, this method will seek through the doc-tree upwards for the first Element that does match this criteria.
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.forceIntoNodeView = function(ancestor) {
            // TODO: transitioned: http://wibblystuff.blogspot.nl/2014/04/in-page-smooth-scroll-using-css3.html
            console.log(NAME, &#x27;forceIntoNodeView&#x27;);
            var instance = this,
                parentOverflowNode = this.getParent(),
                match, left, width, right, height, top, bottom, scrollLeft, scrollTop, parentOverflowNodeX, parentOverflowNodeY,
                parentOverflowNodeStartTop, parentOverflowNodeStartLeft, parentOverflowNodeStopRight, parentOverflowNodeStopBottom, newX, newY;
            if (parentOverflowNode) {
                if (ancestor) {
                    parentOverflowNode = ancestor;
                }
                else {
                    while (parentOverflowNode &amp;&amp; (parentOverflowNode!==DOCUMENT) &amp;&amp; !(match=((parentOverflowNode.getStyle(OVERFLOW)===SCROLL) || (parentOverflowNode.getStyle(OVERFLOW+&#x27;-y&#x27;)===SCROLL)))) {
                        parentOverflowNode = parentOverflowNode.getParent();
                    }
                }
                if (parentOverflowNode &amp;&amp; (parentOverflowNode!==DOCUMENT)) {
                    left = instance.left;
                    width = instance.offsetWidth;
                    right = left + width;
                    height = instance.offsetHeight;
                    top = instance.top;
                    bottom = top + height;
                    scrollLeft = parentOverflowNode.scrollLeft;
                    scrollTop = parentOverflowNode.scrollTop;
                    parentOverflowNodeX = parentOverflowNode.left;
                    parentOverflowNodeY = parentOverflowNode.top;
                    parentOverflowNodeStartTop = parentOverflowNodeY+parseInt(parentOverflowNode.getStyle(BORDER_TOP_WIDTH), 10);
                    parentOverflowNodeStartLeft = parentOverflowNodeX+parseInt(parentOverflowNode.getStyle(BORDER_LEFT_WIDTH), 10);
                    parentOverflowNodeStopRight = parentOverflowNodeX+parentOverflowNode.offsetWidth-parseInt(parentOverflowNode.getStyle(BORDER_RIGHT_WIDTH), 10);
                    parentOverflowNodeStopBottom = parentOverflowNodeY+parentOverflowNode.offsetHeight-parseInt(parentOverflowNode.getStyle(BORDER_BOTTOM_WIDTH), 10);

                    if (left&lt;parentOverflowNodeStartLeft) {
                        newX = Math.max(0, scrollLeft+left-parentOverflowNodeStartLeft);
                    }
                    else if (right&gt;parentOverflowNodeStopRight) {
                        newX = scrollLeft + right - parentOverflowNodeStopRight;
                    }

                    if (top&lt;parentOverflowNodeStartTop) {
                        newY = Math.max(0, scrollTop+top-parentOverflowNodeStartTop);
                    }
                    else if (bottom&gt;parentOverflowNodeStopBottom) {
                        newY = scrollTop + bottom - parentOverflowNodeStopBottom;
                    }

                    if ((newX!==undefined) || (newY!==undefined)) {
                        parentOverflowNode.scrollTo((newX!==undefined) ? newX : scrollLeft,(newY!==undefined) ? newY : scrollTop);
                    }
                }
            }
            return instance;
        };

       /**
        * Forces the Element to be inside the window-view. Differs from &#x60;scrollIntoView()&#x60; in a way
        * that &#x60;forceIntoView()&#x60; doesn&#x27;t change the position when it&#x27;s inside the view, whereas
        * &#x60;scrollIntoView()&#x60; sets it on top of the view.
        *
        * @method forceIntoView
        * @param [notransition=false] {Boolean} set true if you are sure positioning is without transition.
        *        this isn&#x27;t required, but it speeds up positioning. Only use when no transition is used:
        *        when there is a transition, setting this argument &#x60;true&#x60; would miscalculate the position.
        * @param [rectangle] {Object} Set this if you have already calculated the window-rectangle (used for preformance within drag-drop)
        * @param [rectangle.x] {Number} scrollLeft of window
        * @param [rectangle.y] {Number} scrollTop of window
        * @param [rectangle.w] {Number} width of window
        * @param [rectangle.h] {Number} height of window
        * @chainable
        * @since 0.0.2
        */
        ElementPrototype.forceIntoView = function(notransition, rectangle) {
            // TODO: &#x27;notransition&#x27; can be calculated with this.getTransition(left) this.getTransition(left) and this.getTransform(translateX) and this.getTransform(translateY)
            // TODO: transitioned: http://wibblystuff.blogspot.nl/2014/04/in-page-smooth-scroll-using-css3.html
            console.log(NAME, &#x27;forceIntoView&#x27;);
            var instance = this,
                left = instance.left,
                width = instance.offsetWidth,
                right = left + width,
                height = instance.offsetHeight,
                top = instance.top,
                bottom = top + height,
                windowLeft, windowTop, windowRight, windowBottom, newX, newY;
            if (rectangle) {
                windowLeft = rectangle.x;
                windowTop = rectangle.y;
                windowRight = rectangle.w;
                windowBottom = rectangle.h;
            }
            else {
                windowLeft = window.getScrollLeft();
                windowTop = window.getScrollTop();
                windowRight = windowLeft + window.getWidth();
                windowBottom = windowTop + window.getHeight();
            }

            if (left&lt;windowLeft) {
                newX = Math.max(0, left);
            }
            else if (right&gt;windowRight) {
                newX = windowLeft + right - windowRight;
            }
            if (top&lt;windowTop) {
                newY = Math.max(0, top);
            }
            else if (bottom&gt;windowBottom) {
                newY = windowTop + bottom - windowBottom;
            }

            if ((newX!==undefined) || (newY!==undefined)) {
                window.scrollTo((newX!==undefined) ? newX : windowLeft, (newY!==undefined) ? newY : windowTop);
            }
            return instance;
        };

        /**
         * Gets an ElementArray of Elements that lie within this Element and match the css-selector.
         *
         * @method getAll
         * @param cssSelector {String} css-selector to match
         * @return {ElementArray} ElementArray of Elements that match the css-selector
         * @since 0.0.1
         */
        ElementPrototype.getAll = function(cssSelector) {
            return this.querySelectorAll(cssSelector);
        };

       /**
        * Gets an attribute of the Element.
        *
        * Alias for getAttribute().
        *
        * @method getAttr
        * @param attributeName {String}
        * @return {String|null} value of the attribute
        * @since 0.0.1
        */
        ElementPrototype.getAttr = function(attributeName) {
            return this.vnode.attrs[attributeName] || null;
        };

        /**
         * Returns all attributes as defined as an key/value object.
         *
         * @method getAttrs
         * @param attributeName {String}
         * @return {Object} all attributes as on Object
         * @since 0.0.1
         */
        ElementPrototype.getAttrs = function() {
            return this.vnode.attrs;
        };

       /**
        * Gets an attribute of the Element.
        *
        * Same as getAttr().
        *
        * @method getAttribute
        * @param attributeName {String}
        * @return {String|null} value of the attribute
        * @since 0.0.1
        */
        ElementPrototype._getAttribute = ElementPrototype.getAttribute;
        ElementPrototype.getAttribute = function(attributeName) {
            return this.vnode.attrs[attributeName] || null;
        };

        /**
         * Returns a live collection of the Element-childNodes.
         *
         * @method getChildren
         * @return {ElementArray}
         * @since 0.0.1
         */
        ElementPrototype.getChildren = function() {
            var vChildren = this.vnode.vChildren,
                len = vChildren.length,
                children = ElementArray.createArray(),
                i;
            for (i=0; i&lt;len; i++) {
                children[children.length] = vChildren[i].domNode;
            }
            return children;
        };

        /**
         * Returns a token list of the class attribute of the element.
         * See: https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList
         *
         * @method getClassList
         * @return DOMTokenList
         * @since 0.0.1
         */
        ElementPrototype.getClassList = function() {
            var instance = this,
                vnode = instance.vnode;
            if (!vnode._classList) {
                vnode._classList = Object.create(classListProto);
                vnode._classList._init(instance);
            }
            return vnode._classList;
        };

       /**
        * Returns data set specified by &#x60;key&#x60;. If not set, &#x60;undefined&#x60; will be returned.
        * The data is efficiently stored on the vnode.
        *
        * @method getData
        * @param key {string} name of the key
        * @return {Any|undefined} data set specified by &#x60;key&#x60;
        * @since 0.0.1
        */
        ElementPrototype.getData = function(key) {
            var vnode = this.vnode;
            return vnode._data &amp;&amp; vnode._data[key];
        };

       /**
        * Gets one Element, specified by the css-selector. To retrieve a single element by id,
        * you need to prepend the id-name with a &#x60;#&#x60;. When multiple Element&#x27;s match, the first is returned.
        *
        * @method getElement
        * @param cssSelector {String} css-selector to match
        * @return {Element|null} the Element that was search for
        * @since 0.0.1
        */
        ElementPrototype.getElement = function(cssSelector) {
            return ((cssSelector[0]===&#x27;#&#x27;) &amp;&amp; (cssSelector.indexOf(&#x27; &#x27;)===-1)) ? this.getElementById(cssSelector.substr(1)) : this.querySelector(cssSelector);
        };

        /**
         * Returns the Element matching the specified id, which should should be a descendant of this Element.
         *
         * @method getElementById
         * @param id {String} id of the Element
         * @return {Element|null}
         *
         */
        ElementPrototype.getElementById = function(id) {
            var element = nodeids[id];
            if (element &amp;&amp; !this.contains(element)) {
                // outside itself
                return null;
            }
            return element || null;
        };

        /**
         * Gets innerHTML of the dom-node.
         * Goes through the vdom, so it&#x27;s superfast.
         *
         * Use this method instead of &#x60;innerHTML&#x60;
         *
         * @method getHTML
         * @return {String}
         * @since 0.0.1
         */
        ElementPrototype.getHTML = function() {
            return this.vnode.innerHTML;
        };

       /**
        * Returns the Elments &#x60;id&#x60;
        *
        * @method getId
        * @return {String|undefined} Elements &#x60;id&#x60;
        * @since 0.0.1
        */
        ElementPrototype.getId = function() {
            return this.vnode.id;
        };

       /**
        * Returns inline style of the specified property. &#x60;Inline&#x60; means: what is set directly on the Element,
        * this doesn&#x27;t mean necesairy how it is looked like: when no css is set inline, the Element might still have
        * an appearance because of other CSS-rules.
        *
        * In most cases, you would be interesting in using &#x60;getStyle()&#x60; instead.
        *
        * Note: no need to camelCase cssProperty: both &#x60;margin-left&#x60; as well as &#x60;marginLeft&#x60; are fine
        *
        * @method getInlineStyle
        * @param cssProperty {String} the css-property to look for
        * @param [pseudo] {String} to look inside a pseudo-style
        * @return {String|undefined} css-style
        * @since 0.0.1
        */
        ElementPrototype.getInlineStyle = function(cssProperty, pseudo) {
            var styles = this.vnode.styles,
                groupStyle = styles &amp;&amp; styles[pseudo || &#x27;element&#x27;],
                value;
            if (groupStyle) {
                value = groupStyle[fromCamelCase(cssProperty)];
                value &amp;&amp; (cssProperty===VENDOR_TRANSITION_PROPERTY) &amp;&amp; (value=extractor.serializeTransition(value));
            }
            return value;
        };

       /**
        * Returns inline transition-css-property. &#x60;Inline&#x60; means: what is set directly on the Element,
        * When &#x60;transition&#x60; is set inline, no &#x60;parent&#x60; transition-rules apply.
        *
        *
        * @method getInlineTransition
        * @param [transitionProperty] {String} the css-property to look for
        * @param [pseudo] {String} to look inside a pseudo-style
        * @return {Object} the transition-object, with the properties:
        * &lt;ul&gt;
        *     &lt;li&gt;duration {Number}&lt;/li&gt;
        *     &lt;li&gt;timingFunction {String}&lt;/li&gt;
        *     &lt;li&gt;delay {Number}&lt;/li&gt;
        * &lt;/ul&gt;
        * @since 0.0.1
        */
        ElementPrototype.getInlineTransition = function(transitionProperty, pseudo) {
            var styles = this.vnode.styles,
                groupStyle = styles &amp;&amp; styles[pseudo || &#x27;element&#x27;],
                transitionStyles = groupStyle &amp;&amp; groupStyle[VENDOR_TRANSITION_PROPERTY];
            if (transitionStyles) {
                return transitionProperty ? transitionStyles[fromCamelCase(transitionProperty)] : transitionStyles;
            }
        };

        /**
         * Gets the outerHTML of the dom-node.
         * Goes through the vdom, so it&#x27;s superfast.
         *
         * Use this method instead of &#x60;outerHTML&#x60;
         *
         * @method getOuterHTML
         * @return {String}
         * @since 0.0.1
         */
        ElementPrototype.getOuterHTML = function() {
            return this.vnode.outerHTML;
        };

        /**
         * Returns the Element&#x27;s parent Element.
         *
         * @method getParent
         * @return {Element}
         */
        ElementPrototype.getParent = function() {
            var vParent = this.vnode.vParent;
            return vParent &amp;&amp; vParent.domNode;
        };

       /**
        * Returns cascaded style of the specified property. &#x60;Cascaded&#x60; means: the actual present style,
        * the way it is visible (calculated through the DOM-tree).
        *
        * &lt;ul&gt;
        *     &lt;li&gt;Note1: values are absolute: percentages and points are converted to absolute values, sizes are in pixels, colors in rgb/rgba-format.&lt;/li&gt;
        *     &lt;li&gt;Note2: you cannot query shotcut-properties: use &#x60;margin-left&#x60; instead of &#x60;margin&#x60;.&lt;/li&gt;
        *     &lt;li&gt;Note3: no need to camelCase cssProperty: both &#x60;margin-left&#x60; as well as &#x60;marginLeft&#x60; are fine.&lt;/li&gt;
        *     &lt;li&gt;Note4: you can query &#x60;transition&#x60;, &#x60;transform&#x60;, &#x60;perspective&#x60; and &#x60;transform-origin&#x60; instead of their vendor-specific properties.&lt;/li&gt;
        *     &lt;li&gt;Note5: &#x60;transition&#x60; or &#x60;transform&#x60; return an Object instead of a String.&lt;/li&gt;
        * &lt;/ul&gt;
        *
        * @method getCascadeStyle
        * @param cssProperty {String} property that is queried
        * @param [pseudo] {String} to query pseudo-element, fe: &#x60;:before&#x60; or &#x60;:first-line&#x60;
        * @return {String|Object} value for the css-property: this is an Object for the properties &#x60;transition&#x60; or &#x60;transform&#x60;
        * @since 0.0.1
        */
        ElementPrototype.getStyle = function(cssProperty, pseudo) {
            // Cautious: when reading the property &#x60;transform&#x60;, getComputedStyle should
            // read the calculated value, but some browsers (webkit) only calculate the style on the current element
            // In those cases, we need a patch and look up the tree ourselves
            //  Also: we will return separate value, NOT matrices
            var instance = this;
            if (cssProperty===VENDOR_TRANSITION_PROPERTY) {
                return instance._getTransitionAll(pseudo);
            }
            VENDOR_CSS_PROPERTIES[cssProperty] || (cssProperty=generateVendorCSSProp(cssProperty));
            return window.getComputedStyle(instance, pseudo)[toCamelCase(cssProperty)];
        };

        /**
        * Returns cascaded &quot;transition&quot; style of the specified trandform-property. &#x60;Cascaded&#x60; means: the actual present style,
        * the way it is visible (calculated through the DOM-tree).
        *
        * Note1: When &quot;transition&quot; is set inline, ONLY inline transtition is active!
        * Thus, if parentNode has &quot;transition: width 2s&quot; and inline has &quot;transition: height 3s&quot;, then the transition
        * will be &quot;transition: height 3s&quot; --&gt; returning &quot;undefined&quot; for transitionProperty=width.
        * Note2: in case of &quot;transition: all&quot; --&gt; these values will be returned for every &quot;transitionProperty&quot; (even when querying &quot;width&quot;)
        *
        * @method getTransition
        * @param transitionProperty {String} transform property that is queried, f.e. &quot;width&quot;, or &quot;all&quot;
        * @param [pseudo] {String} to query pseudo-element, fe: &#x60;:before&#x60; or &#x60;:first-line&#x60;
        * @return {Object} the transition-object, with the properties:
        * &lt;ul&gt;
        *     &lt;li&gt;duration {Number}&lt;/li&gt;
        *     &lt;li&gt;timingFunction {String}&lt;/li&gt;
        *     &lt;li&gt;delay {Number}&lt;/li&gt;
        * &lt;/ul&gt;
        * @since 0.0.1
        */
        ElementPrototype.getTransition = function(transitionProperty, pseudo) {
            var instance = this,
                transProperty, transDuration, transTimingFunction, transDelay, transPropertySplitted,
                transition, transDurationSplitted, transTimingFunctionSplitted, transDelaySplitted, index;
            if (instance.hasInlineStyle(VENDOR_TRANSITION_PROPERTY, pseudo)) {
                transition = instance.getInlineTransition(transitionProperty, pseudo);
                // if not found, then search for &quot;all&quot;:
                transition || (transition=instance.getInlineTransition(&#x27;all&#x27;, pseudo));
                if (transition) {
                    // getTransition always returns all the properties:
                    transition.timingFunction || (transition.timingFunction=&#x27;ease&#x27;);
                    transition.delay || (transition.delay=0);
                }
                return transition;
            }
            transProperty = instance.getStyle(VENDOR_TRANSITION_PROPERTY+&#x27;Property&#x27;, pseudo);
            transDuration = instance.getStyle(VENDOR_TRANSITION_PROPERTY+&#x27;Duration&#x27;, pseudo);
            transTimingFunction = instance.getStyle(VENDOR_TRANSITION_PROPERTY+&#x27;TimingFunction&#x27;, pseudo);
            transDelay = instance.getStyle(VENDOR_TRANSITION_PROPERTY+&#x27;Delay&#x27;, pseudo);
            transPropertySplitted = transProperty &amp;&amp; transProperty.split(&#x27;,&#x27;);
            if (transProperty) {
                if (transPropertySplitted.length&gt;1) {
                    // multiple definitions
                    index = transPropertySplitted.indexOf(transitionProperty);
                    // the array is in a form like this: &#x27;width, height, opacity&#x27; --&gt; therefore, we might need to look at a whitespace
                    if (index===-1) {
                        index = transPropertySplitted.indexOf(&#x27; &#x27;+transitionProperty);
                        // if not found, then search for &quot;all&quot;:
                        if (index===-1) {
                            index = transPropertySplitted.indexOf(&#x27;all&#x27;);
                            (index===-1) &amp;&amp; (index=transPropertySplitted.indexOf(&#x27; &#x27;+&#x27;all&#x27;));
                        }
                    }
                    if (index!==-1) {
                        transDurationSplitted = transDuration.split(&#x27;,&#x27;);
                        transTimingFunctionSplitted = transTimingFunction.split(&#x27;,&#x27;);
                        transDelaySplitted = transDelay.split(&#x27;,&#x27;);
                        transition = {
                            duration: parseFloat(transDurationSplitted[index]),
                            timingFunction: transTimingFunctionSplitted[index].trimLeft(),
                            delay: parseFloat(transDelaySplitted)
                        };
                    }
                }
                else {
                    // one definition
                    if ((transProperty===transitionProperty) || (transProperty===&#x27;all&#x27;)) {
                        transition = {
                            duration: parseFloat(transDuration),
                            timingFunction: transTimingFunction,
                            delay: parseFloat(transDelay)
                        };
                    }
                }
                transition &amp;&amp; (transition.duration===0) &amp;&amp; (transition=undefined);
                return transition;
            }
        };

       /**
        * Elements tag-name in uppercase (same as nodeName).
        *
        * @method getTagName
        * @return {String}
        * @since 0.0.1
        */
        ElementPrototype.getTagName = function() {
            return this.vnode.tag;
        };

        /**
         * Gets the innerContent of the Element as plain text.
         * Goes through the vdom, so it&#x27;s superfast.
         *
         * Use this method instead of &#x60;textContent&#x60;
         *
         * @method getText
         * @return String
         * @since 0.0.1
         */
        ElementPrototype.getText = function() {
            return this.vnode.textContent;
        };

       /**
        * Gets the value of the following Elements:
        *
        * &lt;ul&gt;
        *     &lt;li&gt;input&lt;/li&gt;
        *     &lt;li&gt;textarea&lt;/li&gt;
        *     &lt;li&gt;select&lt;/li&gt;
        *     &lt;li&gt;any container that is &#x60;contenteditable&#x60;&lt;/li&gt;
        * &lt;/ul&gt;
        *
        * @method getValue
        * @return {String}
        * @since 0.0.1
        */
        ElementPrototype.getValue = function() {
            // cautious: input and textarea must be accessed by their propertyname:
            // input.getAttribute(&#x27;value&#x27;) would return the default-value instead of actual
            // and textarea.getAttribute(&#x27;value&#x27;) doesn&#x27;t exist
            var instance = this,
                contenteditable = instance.vnode.attrs.contenteditable,
                editable = contenteditable &amp;&amp; (contenteditable!==&#x27;false&#x27;);
            return editable ? instance.getHTML() : instance.value;
        };

       /**
        * Whether the Element has the attribute set.
        *
        * Alias for hasAttribute().
        *
        * @method hasAttr
        * @param attributeName {String}
        * @return {Boolean} Whether the Element has the attribute set.
        * @since 0.0.1
        */
        ElementPrototype.hasAttr = function(attributeName) {
            return !!this.vnode.attrs[attributeName];
        };

       /**
        * Whether the Element has the attribute set.
        *
        * Same as hasAttr().
        *
        * @method hasAttribute
        * @param attributeName {String}
        * @return {Boolean} Whether the Element has the attribute set.
        * @since 0.0.1
        */
        ElementPrototype.hasAttribute = function(attributeName) {
            return !!this.vnode.attrs[attributeName];
        };

        /**
         * Indicating if the current element has any attributes or not.
         *
         * @method hasAttributes
         * @return {Boolean} Whether the current element has any attributes or not.
         */
        ElementPrototype.hasAttributes = function() {
            var attrs = this.vnode.attrs;
            return attrs ? (attrs.size() &gt; 0) : false;
        };

       /**
        * Indicating if the Element has any children (childNodes with nodeType of 1).
        *
        * @method hasChildren
        * @return {Boolean} whether the Element has children
        * @since 0.0.1
        */
        ElementPrototype.hasChildren = function() {
            return this.vnode.hasVChildren();
        };

       /**
        * Checks whether the className is present on the Element.
        *
        * @method hasClass
        * @param className {String|Array} the className to check for. May be an Array of classNames, which all needs to be present.
        * @return {Boolean} whether the className (or classNames) is present on the Element
        * @since 0.0.1
        */
        ElementPrototype.hasClass = function(className) {
            return this.getClassList().contains(className);
        };

       /**
        * If the Element has data set specified by &#x60;key&#x60;. The data could be set with &#x60;setData()&#x60;.
        *
        * @method hasData
        * @param key {string} name of the key
        * @return {Boolean}
        * @since 0.0.1
        */
        ElementPrototype.hasData = function(key) {
            var vnode = this.vnode;
            return !!(vnode._data &amp;&amp; (vnode._data[key]!==undefined));
        };

       /**
        * Indicates whether Element currently has the focus.
        *
        * @method hasFocus
        * @return {Boolean}
        * @since 0.0.1
        */
        ElementPrototype.hasFocus = function() {
            return (DOCUMENT.activeElement===this);
        };

       /**
        * Indicates whether the current focussed Element lies inside this Element (on a descendant Element).
        *
        * @method hasFocusInside
        * @return {Boolean}
        * @since 0.0.1
        */
        ElementPrototype.hasFocusInside = function() {
            var activeElement = DOCUMENT.activeElement;
            return ((DOCUMENT.activeElement!==this) &amp;&amp; this.contains(activeElement));
        };

       /**
        * Returns whether the inline style of the specified property is present. &#x60;Inline&#x60; means: what is set directly on the Element.
        *
        * Note: no need to camelCase cssProperty: both &#x60;margin-left&#x60; as well as &#x60;marginLeft&#x60; are fine
        *
        * @method hasInlineStyle
        * @param cssProperty {String} the css-property to look for
        * @param [pseudo] {String} to look inside a pseudo-style
        * @return {Boolean} whether the inlinestyle was present
        * @since 0.0.1
        */
        ElementPrototype.hasInlineStyle = function(cssProperty, pseudo) {
            return !!this.getInlineStyle(cssProperty, pseudo);
        };

       /**
        * Returns whether the specified inline transform-css-property is present. &#x60;Inline&#x60; means: what is set directly on the Element.
        *
        * See more about tranform-properties: https://developer.mozilla.org/en-US/docs/Web/CSS/transform
        *
        * @method hasInlineTransition
        * @param transitionProperty {String} the css-property to look for
        * @param [pseudo] {String} to look inside a pseudo-style
        * @return {Boolean} whether the inline transform-css-property was present
        * @since 0.0.1
        */
        ElementPrototype.hasInlineTransition = function(transitionProperty, pseudo) {
            return !!this.getInlineTransition(transitionProperty, pseudo);
        };

        /**
        * Returns whether the specified transform-property is active.
        *
        * Note1: When &quot;transition&quot; is set inline, ONLY inline transtition is active!
        * Thus, if parentNode has &quot;transition: width 2s&quot; and inline has &quot;transition: height 3s&quot;,
        * then hasTransition(&#x27;width&#x27;) will return false.
        * Note2: in case of &quot;transition: all&quot; --&gt; hasTransition() will always &#x60;true&#x60; for every transitionProperty.
        *
        * @method hasTransition
        * @param transitionProperty {String} the css-property to look for
        * @param [pseudo] {String} to look inside a pseudo-style
        * @return {Boolean} whether the inlinestyle was present
        * @since 0.0.1
        */
        ElementPrototype.hasTransition = function(transitionProperty, pseudo) {
            return !!this.getTransition(transitionProperty, pseudo);
        };

       /**
        * Hides a node by making it floated and removing it out of the visible screen.
        * Hides immediately without &#x60;fade&#x60;, or will fade when fade is specified.
        *
        * @method hide
        * @param [fade] {Number} sec to fade (you may use &#x60;0.1&#x60;)
        * @return {this|Promise} fulfilled when the element is ready hiding, or rejected when showed up again (using node.show) before fully hided.
        * @since 0.0.1
        */
        ElementPrototype.hide = function(duration) {
            // when it doesn&#x27;t have, it doesn;t harm to leave the transitionclass on: it would work anyway
            // nevertheless we will remove it with a timeout
            var instance = this,
                showPromise = instance.getData(&#x27;_showNodeBusy&#x27;),
                hidePromise = instance.getData(&#x27;_hideNodeBusy&#x27;),
                originalOpacity, hasOriginalOpacity, promise, freezedOpacity, fromOpacity;

            originalOpacity = instance.getData(&#x27;_showNodeOpacity&#x27;);
            if (!originalOpacity &amp;&amp; !showPromise &amp;&amp; !hidePromise) {
                originalOpacity = instance.getInlineStyle(&#x27;opacity&#x27;);
                instance.setData(&#x27;_showNodeOpacity&#x27;, originalOpacity);
            }
            hasOriginalOpacity = !!originalOpacity;

            showPromise &amp;&amp; showPromise.freeze();
            hidePromise &amp;&amp; hidePromise.freeze();

            if (duration) {
                if (showPromise || hidePromise) {
                    freezedOpacity = instance.getInlineStyle(&#x27;opacity&#x27;);
                    fromOpacity = originalOpacity || 1;
                    duration = (fromOpacity&gt;0) ? Math.min(1, (freezedOpacity/fromOpacity))*duration : 0;
                }
                promise = instance.transition({property: &#x27;opacity&#x27;, value: 0, duration: duration});
                instance.setData(&#x27;_hideNodeBusy&#x27;, promise);
                promise.finally(
                    function() {
                        if (!promise.cancelled &amp;&amp; !promise.frozen) {
                            instance.setClass(HIDDEN);
                            originalOpacity ? instance.setInlineStyle(&#x27;opacity&#x27;, originalOpacity) : instance.removeInlineStyle(&#x27;opacity&#x27;);
                        }
                        instance.removeData(&#x27;_hideNodeBusy&#x27;);
                    }
                );
                return promise;
            }
            else {
                async(function() {
                    instance.setClass(HIDDEN);
                    hasOriginalOpacity ? instance.setInlineStyle(&#x27;opacity&#x27;, originalOpacity) : instance.removeInlineStyle(&#x27;opacity&#x27;);
                });
                return instance;
            }
        };

       /**
        * Indicates whether the Element currently is part if the DOM.
        *
        * @method inDOM
        * @return {Boolean} whether the Element currently is part if the DOM.
        * @since 0.0.1
        */
        ElementPrototype.inDOM = function() {
            if (this.vnode.removedFromDOM) {
                return false;
            }
            return DOCUMENT.contains(this);
        };

       /**
         * Checks whether the Element lies within the specified selector (which can be a CSS-selector or a Element)
         *
         * @example
         * var divnode = childnode.inside(&#x27;div.red&#x27;);
         *
         * @example
         * var divnode = childnode.inside(containerNode);
         *
         * @method inside
         * @param selector {Element|String} the selector, specified by a Element or a css-selector
         * @return {Element|false} the nearest Element that matches the selector, or &#x60;false&#x60; when not found
         * @since 0.0.1
         */
        ElementPrototype.inside = function(selector) {
            var instance = this,
                vParent;
            if (typeof selector===STRING) {
                vParent = instance.vnode.vParent;
                while (vParent &amp;&amp; !vParent.matchesSelector(selector)) {
                    vParent = vParent.vParent;
                }
                return vParent ? vParent.domNode : false;
            }
            else {
                // selector should be an Element
                return ((selector!==instance) &amp;&amp; selector.contains(instance)) ? selector : false;
            }
        };

       /**
         * Checks whether a point specified with x,y is within the Element&#x27;s region.
         *
         * @method insidePos
         * @param x {Number} x-value for new position (coordinates are page-based)
         * @param y {Number} y-value for new position (coordinates are page-based)
         * @return {Boolean} whether there is a match
         * @since 0.0.1
         */
        ElementPrototype.insidePos = function(x, y) {
            var instance = this,
                left = instance.left,
                top = instance.top,
                right = left + instance.offsetWidth,
                bottom = top + instance.offsetHeight;
            return (x&gt;=left) &amp;&amp; (x&lt;=right) &amp;&amp; (y&gt;=top) &amp;&amp; (y&lt;=bottom);
        };

        /**
         * Inserts &#x60;domNode&#x60; before &#x60;refDomNode&#x60;.
         *
         * @method insertBefore
         * @param domNode {Node|Element|ElementArray|String} content to insert
         * @param refDomNode {Element} The Element before which newElement is inserted.
         * @param [escape] {Boolean} whether to insert &#x60;escaped&#x60; content, leading it into only text inserted
         * @return {Node} the Element being inserted (equals domNode)
         */
        ElementPrototype._insertBefore = ElementPrototype.insertBefore;
        ElementPrototype.insertBefore = function(domNode, refDomNode, escape) {
            return this.prepend(domNode, escape, refDomNode);
        };

        /**
         * Reference to the last of sibbling vNode&#x27;s, where the related dom-node is an Element(nodeType===1).
         *
         * @method last
         * @param [cssSelector] {String} to return the last Element that matches the css-selector
         * @return {Element}
         * @since 0.0.1
         */
        ElementPrototype.last = function(cssSelector) {
            var vParent = this.vnode.vParent;
            return vParent &amp;&amp; vParent.lastOfVChildren(cssSelector).domNode;
        };

        /**
         * Reference to the last child-Element, where the related dom-node an Element (nodeType===1).
         *
         * @method lastOfChildren
         * @param [cssSelector] {String} to return the last Element that matches the css-selector
         * @return {Element}
         * @since 0.0.1
         */
        ElementPrototype.lastOfChildren = function(cssSelector) {
            var foundVNode = this.vnode.lastOfVChildren(cssSelector);
            return foundVNode &amp;&amp; foundVNode.domNode;
        };

        /**
         * Indicates if the element would be selected by the specified selector string.
         * Alias for matchesSelector()
         *
         * @method matches
         * @param [cssSelector] {String} the css-selector to check for
         * @return {Boolean}
         * @since 0.0.1
         */
        ElementPrototype.matches = function(selectors) {
            return this.vnode.matchesSelector(selectors);
        };

        /**
         * Indicates if the element would be selected by the specified selector string.
         * Alias for matches()
         *
         * @method matchesSelector
         * @param [cssSelector] {String} the css-selector to check for
         * @return {Boolean}
         * @since 0.0.1
         */
        ElementPrototype.matchesSelector = function(selectors) {
            return this.vnode.matchesSelector(selectors);
        };

        /**
         * Reference to the next of sibbling Element, where the related dom-node is an Element(nodeType===1).
         *
         * @method next
         * @param [cssSelector] {String} css-selector to be used as a filter
         * @return {Element|null}
         * @type Element
         * @since 0.0.1
         */
        ElementPrototype.next = function(cssSelector) {
            var vnode = this.vnode,
                found, vNextElement, firstCharacter, i, len;
            if (!cssSelector) {
                vNextElement = vnode.vNextElement;
                return vNextElement &amp;&amp; vNextElement.domNode;
            }
            else {
                i = -1;
                len = cssSelector.length;
                while (!firstCharacter &amp;&amp; (++i&lt;len)) {
                    firstCharacter = cssSelector[i];
                    (firstCharacter===&#x27; &#x27;) &amp;&amp; (firstCharacter=null);
                }
                if (firstCharacter===&#x27;&gt;&#x27;) {
                    return null;
                }
            }
            vNextElement = vnode;
            do {
                vNextElement = vNextElement.vNextElement;
                found = vNextElement &amp;&amp; vNextElement.matchesSelector(cssSelector);
            } while(vNextElement &amp;&amp; !found);
            return found ? vNextElement.domNode : null;
        };

       /**
        * Prepends a Element or text at the start of Element&#x27;s innerHTML, or before the &#x60;refElement&#x60;.
        *
        * @method prepend
        * @param content {Element|Element|ElementArray|String} content to prepend
        * @param [escape] {Boolean} whether to insert &#x60;escaped&#x60; content, leading it into only text inserted
        * @param [refElement] {Element} reference Element where the content should be prepended
        * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
        * @return {Element} the created Element (or the last when multiple)
        * @since 0.0.1
        */
        ElementPrototype.prepend = function(content, escape, refElement, silent) {
            var instance = this,
                vnode = instance.vnode,
                i, len, item, createdElement, vnodes, vChildNodes, vRefElement,
            doPrepend = function(oneItem) {
                escape &amp;&amp; (oneItem.nodeType===1) &amp;&amp; (oneItem=DOCUMENT.createTextNode(oneItem.getOuterHTML()));
                createdElement = refElement ? vnode._insertBefore(oneItem.vnode, refElement.vnode) : vnode._appendChild(oneItem.vnode);
                // CAUTIOUS: when using TextNodes, they might get merged (vnode._normalize does this), which leads into disappearance of refElement:
                refElement = createdElement;
            };
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            vnode._noSync()._normalizable(false);
            if (!refElement) {
                vChildNodes = vnode.vChildNodes;
                vRefElement = vChildNodes &amp;&amp; vChildNodes[0];
                refElement = vRefElement &amp;&amp; vRefElement.domNode;
            }
            (typeof content===STRING) &amp;&amp; (content=htmlToVFragments(content));
            if (content.isFragment) {
                vnodes = content.vnodes;
                len = vnodes.length;
                // to manage TextNodes which might get merged, we loop downwards:
                for (i=len-1; i&gt;=0; i--) {
                    doPrepend(vnodes[i].domNode);
                }
            }
            else if (Array.isArray(content)) {
                len = content.length;
                // to manage TextNodes which might get merged, we loop downwards:
                for (i=len-1; i&gt;=0; i--) {
                    item = content[i];
                    doPrepend(item);
                }
            }
            else {
                doPrepend(content);
            }
            vnode._normalizable(true)._normalize();
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(false);
            return createdElement;
        };

        /**
         * Reference to the previous of sibbling Element, where the related dom-node is an Element(nodeType===1).
         *
         * @method previous
         * @param [cssSelector] {String} css-selector to be used as a filter
         * @return {Element|null}
         * @type Element
         * @since 0.0.1
         */
        ElementPrototype.previous = function(cssSelector) {
            var vnode = this.vnode,
                found, vPreviousElement, firstCharacter, i, len;
            if (!cssSelector) {
                vPreviousElement = vnode.vPreviousElement;
                return vPreviousElement &amp;&amp; vPreviousElement.domNode;
            }
            else {
                i = -1;
                len = cssSelector.length;
                while (!firstCharacter &amp;&amp; (++i&lt;len)) {
                    firstCharacter = cssSelector[i];
                    (firstCharacter===&#x27; &#x27;) &amp;&amp; (firstCharacter=null);
                }
                if (firstCharacter===&#x27;&gt;&#x27;) {
                    return null;
                }
            }
            vPreviousElement = vnode;
            do {
                vPreviousElement = vPreviousElement.vPreviousElement;
                found = vPreviousElement &amp;&amp; vPreviousElement.matchesSelector(cssSelector);
            } while(vPreviousElement &amp;&amp; !found);
            return found ? vPreviousElement.domNode : null;
        };

        /**
         * Returns the first Element within the Element, that matches the CSS-selectors. You can pass one, or multiple CSS-selectors. When passed multiple,
         * they need to be separated by a &#x60;comma&#x60;.
         *
         * @method querySelector
         * @param selectors {String} CSS-selector(s) that should match
         * @return {Element}
         */
        ElementPrototype.querySelector = function(selectors) {
            var found,
                i = -1,
                len = selectors.length,
                firstCharacter, startvnode,
                thisvnode = this.vnode,
                inspectChildren = function(vnode) {
                    var vChildren = vnode.vChildren,
                        len2 = vChildren ? vChildren.length : 0,
                        j, vChildNode;
                    for (j=0; (j&lt;len2) &amp;&amp; !found; j++) {
                        vChildNode = vChildren[j];
                        vChildNode.matchesSelector(selectors, thisvnode) &amp;&amp; (found=vChildNode.domNode);
                        found || inspectChildren(vChildNode);
                    }
                };
            while (!firstCharacter &amp;&amp; (++i&lt;len)) {
                firstCharacter = selectors[i];
                (firstCharacter===&#x27; &#x27;) &amp;&amp; (firstCharacter=null);
            }
            startvnode = SIBLING_MATCH_CHARACTER[firstCharacter] ? thisvnode.vParent : thisvnode;
            startvnode &amp;&amp; inspectChildren(startvnode);
            return found;
        };

        /**
         * Returns an ElementArray of all Elements within the Element, that match the CSS-selectors. You can pass one, or multiple CSS-selectors. When passed multiple,
         * they need to be separated by a &#x60;comma&#x60;.
         *
         * querySelectorAll is a snapshot of the dom at the time this method was called. It is not updated when changes of the dom are made afterwards.
         *
         * @method querySelectorAll
         * @param selectors {String} CSS-selector(s) that should match
         * @return {ElementArray} non-life Array (snapshot) with Elements
         */
        ElementPrototype.querySelectorAll = function(selectors) {
            var found = ElementArray.createArray(),
                i = -1,
                len = selectors.length,
                firstCharacter, startvnode,
                thisvnode = this.vnode,
                inspectChildren = function(vnode) {
                    var vChildren = vnode.vChildren,
                        len2 = vChildren ? vChildren.length : 0,
                        j, vChildNode;
                    for (j=0; j&lt;len2; j++) {
                        vChildNode = vChildren[j];
                        vChildNode.matchesSelector(selectors, thisvnode) &amp;&amp; (found[found.length]=vChildNode.domNode);
                        inspectChildren(vChildNode);
                    }
                };
            while (!firstCharacter &amp;&amp; (++i&lt;len)) {
                firstCharacter = selectors[i];
                (firstCharacter===&#x27; &#x27;) &amp;&amp; (firstCharacter=null);
            }
            startvnode = SIBLING_MATCH_CHARACTER[firstCharacter] ? thisvnode.vParent : thisvnode;
            startvnode &amp;&amp; inspectChildren(startvnode);
            return found;
        };

       /**
         * Checks whether the Element has its rectangle inside the outbound-Element.
         * This is no check of the DOM-tree, but purely based upon coordinates.
         *
         * @method rectangleInside
         * @param outboundElement {Element} the Element where this element should lie inside
         * @return {Boolean} whether the Element lies inside the outboundElement
         * @since 0.0.1
         */
        ElementPrototype.rectangleInside = function(outboundElement) {
            var instance = this,
                outerRect = outboundElement.getBoundingClientRect(),
                innerRect = instance.getBoundingClientRect();
            return (outerRect.left&lt;=innerRect.left) &amp;&amp;
                   (outerRect.top&lt;=innerRect.top) &amp;&amp;
                   ((outerRect.left+outboundElement.offsetWidth)&gt;=(innerRect.left+instance.offsetWidth)) &amp;&amp;
                   ((outerRect.top+outboundElement.offsetHeight)&gt;=(innerRect.top+instance.offsetHeight));
        };

       /**
        * Removes the Element from the DOM.
        * Alias for thisNode.parentNode.removeChild(thisNode);
        *
        * @method remove
        * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
        * @return {Node} the DOM-node that was removed. You could re-insert it at a later time.
        * @since 0.0.1
        */
        ElementPrototype.remove = function(silent) {
            var instance = this,
                vnode = instance.vnode,
                vParent = vnode.vParent;
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            vParent &amp;&amp; vParent._removeChild(vnode);
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(false);
            return instance;
        };

       /**
        * Removes the attribute from the Element.
        *
        * Alias for removeAttribute() BUT is chainable instead (removeAttribute is not).
        *
        * @method removeAttr
        * @param attributeName {String}
        * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.removeAttr = function(attributeName, silent) {
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            this.removeAttribute(attributeName);
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(false);
            return this;
        };

       /**
         * Removes multiple attributes on the Element.
         * The argument should be one ore more AttributeNames.
         *
         * @example
         * instance.removeAttrs([&#x27;tabIndex&#x27;, &#x27;style&#x27;]);
         *
         * @method removeAttrs
         * @param attributeData {Array|String}
         * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
         * @chainable
         * @since 0.0.1
        */
        ElementPrototype.removeAttrs = function(attributeData, silent) {
            var instance = this;
            Array.isArray(attributeData) || (attributeData=[attributeData]);
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            attributeData.forEach(function(item) {
                instance.removeAttribute(item);
            });
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(false);
            return instance;
        };

       /**
        * Removes the attribute from the Element.
        *
        * Use removeAttr() to be able to chain.
        *
        * @method removeAttr
        * @param attributeName {String}
        * @since 0.0.1
        */
        ElementPrototype._removeAttribute = ElementPrototype.removeAttribute;
        ElementPrototype.removeAttribute = function(attributeName) {
            this.vnode._removeAttr(attributeName);
        };

        /**
        * Removes the Element&#x27;s child-Node from the DOM.
        *
        * @method removeChild
        * @param domNode {Node} the child-Node to remove
        * @return {Node} the DOM-node that was removed. You could re-insert it at a later time.
        */
        ElementPrototype._removeChild = ElementPrototype.removeChild;
        ElementPrototype.removeChild = function(domNode) {
            var instance = this;
            instance.vnode._removeChild(domNode.vnode);
            return instance;
        };

       /**
        * Removes a className from the Element.
        *
        * @method removeClass
        * @param className {String|Array} the className that should be removed. May be an Array of classNames.
        * @param [returnPromise] {Boolean} whether to return a Promise instead of &#x60;this&#x60;, which might be useful in case of
        *        transition-properties. The promise will fullfil when the transition is ready, or immediately when no transitioned.
        * @param [transitionFix] set this to &#x60;true&#x60; if you experience transition-problems due to wrong calculated css (mostly because of the &#x60;auto&#x60; value)
        *        Setting this parameter, will calculate the true css of the transitioned properties and set this temporarely inline, to fix the issue.
        *        Don&#x27;t use it when not needed, it has a slightly performancehit.
        *        No need to set when &#x60;returnPromise&#x60; is set --&gt; returnPromise always handles the transitionFix.
        * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
        * @return {Promise|this} In case &#x60;returnPromise&#x60; is set, a Promise returns with the next handles:
        *        &lt;ul&gt;
        *            &lt;li&gt;cancel() {Promise}&lt;/li&gt;
        *            &lt;li&gt;freeze() {Promise}&lt;/li&gt;
        *            &lt;li&gt;unfreeze()&lt;/li&gt;
        *            &lt;li&gt;finish() {Promise}&lt;/li&gt;
        *        &lt;/ul&gt;
        *        These handles resolve with the &#x60;elapsed-time&#x60; as first argument of the callbackFn
        * @since 0.0.1
        */
        ElementPrototype.removeClass = function(className, returnPromise, transitionFix, silent) {
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            var instance = this,
                transPromise = (returnPromise || transitionFix) &amp;&amp; getClassTransPromise(instance, REMOVE, className),
                returnValue = returnPromise ? transPromise : instance;
            transPromise || instance.getClassList().remove(className);
            if (silent &amp;&amp; DOCUMENT.suppressMutationEvents) {
                if (returnValue===instance) {
                    DOCUMENT.suppressMutationEvents(false);
                }
                else {
                    returnValue.finally(function() {
                        DOCUMENT.suppressMutationEvents(false);
                    });
                }
            }
            return returnValue;
        };

       /**
        * Removes data specified by &#x60;key&#x60; that was set by using &#x60;setData()&#x60;.
        * When no arguments are passed, all node-data (key-value pairs) will be removed.
        *
        * @method removeData
        * @param [key] {string} name of the key, when not set, all data is removed
        * @param [deep] {Boolean} whether to set the data to all descendants recursively
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.removeData = function(key, deep) {
            var instance = this,
                vnode = instance.vnode;
            if (vnode._data) {
                if (key) {
                    delete vnode._data[key];
                }
                else {
                    // we cannot just redefine _data, for it is set as readonly
                    vnode._cleanData();
                    if (deep) {
                        instance.getChildren().forEach(function(element) {
                            element.removeData(key, true);
                        });
                    }
                }
            }
            return instance;
        };

       /**
        * Removes the Elment&#x27;s &#x60;id&#x60;.
        *
        * @method removeId
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.removeId = function() {
            return this.removeAttr(&#x27;id&#x27;);
        };

       /**
        * Removes a css-property (inline) out of the Element.
        * No need to use camelCase.
        *
        * @method removeInlineStyle
        * @param cssProperty {String} the css-property to remove
        * @param [pseudo] {String} to look inside a pseudo-style
        * @param [returnPromise] {Boolean} whether to return a Promise instead of &#x60;this&#x60;, which might be useful in case of
        *        transition-properties. The promise will fullfil when the transition is ready, or immediately when no transitioned.
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.removeInlineStyle = function(cssProperty, pseudo, returnPromise) {
            return this.removeInlineStyles({property: cssProperty, pseudo: pseudo}, returnPromise);
        };

       /**
        * Removes multiple css-properties (inline) out of the Element. You need to supply an Array of Objects, with the properties:
        *        &lt;ul&gt;
        *            &lt;li&gt;property  {String}&lt;/li&gt;
        *            &lt;li&gt;pseudo  {String}&lt;/li&gt;
        *        &lt;ul&gt;
        * No need to use camelCase.
        *
        * @method removeInlineStyles
        * @param cssProperties {Array|Object} Array of objects, Strings (or 1 Object/String).
        *       When String, then speduo is considered as undefined. When &#x60;Objects&#x60;, they need the properties:
        *        &lt;ul&gt;
        *            &lt;li&gt;property  {String}&lt;/li&gt;
        *            &lt;li&gt;pseudo  {String}&lt;/li&gt;
        *        &lt;ul&gt;
        * @param [returnPromise] {Boolean} whether to return a Promise instead of &#x60;this&#x60;, which might be useful in case of
        *        transition-properties. The promise will fullfil when the transition is ready, or immediately when no transitioned.
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.removeInlineStyles = function(cssProperties, returnPromise) {
            // There will be 3 sets of styles:
            // &#x60;fromStyles&#x60; --&gt; the current styles, only exactly calculated -without &#x60;auto&#x60;- (that is, for the transitioned properties)
            // &#x60;toStylesExact&#x60; --&gt; the new styles, exactly calculated -without &#x60;auto&#x60;- (that is, for the transitioned properties)
            // &#x60;vnodeStyles&#x60; --&gt; the new styles as how they should be in the end (f.i. with &#x60;auto&#x60;)
            var instance = this,
                vnode = instance.vnode,
                removed = [],
                transCount = 0,
                transitionProperties = {},
                maxtranstime = 0,
                needSync, prop, styles, i, len, item, hasTransitionedStyle, promise, vnodeStyles,
                pseudo, group, clonedElement, fromStyles, toStylesExact, value, transproperty, transtime;

            Array.isArray(cssProperties) || (cssProperties=[cssProperties]);
            cssProperties = getVendorCSS(cssProperties);
            len = cssProperties.length;
            vnodeStyles = vnode.styles;
            for (i=0; i&lt;len; i++) {
                item = cssProperties[i];
                if (typeof item===&#x27;string&#x27;) {
                    item = cssProperties[i] = {
                        property: item
                    };
                }
                pseudo = item.pseudo;
                group = pseudo || &#x27;element&#x27;;
                styles = vnodeStyles[group];
                if (styles) {
                    prop = item.property;
                    // if property is vendor-specific transition, or transform, than we reset it to the current vendor
                    if (styles[prop]) {
                        fromStyles || (fromStyles=vnodeStyles.deepClone());
                        needSync = true;
                        if ((prop!==VENDOR_TRANSITION_PROPERTY) &amp;&amp; instance.hasTransition(prop, pseudo)) {
                            // store the calculated value:
                            fromStyles[group] || (fromStyles[group]={});
                            (prop===VENDOR_TRANSFORM_PROPERTY) || (fromStyles[group][prop]=instance.getStyle(prop, group));
                            hasTransitionedStyle = true;
                            removed[removed.length] = {
                                group: group,
                                property: prop,
                                pseudo: pseudo
                            };
                        }
                        delete styles[prop];
                        (styles.size()===0) &amp;&amp; (delete vnode.styles[pseudo || &#x27;element&#x27;]);
                    }
                }
            }

            RUNNING_ON_NODE &amp;&amp; (hasTransitionedStyle=false);
            if (hasTransitionedStyle) {
                // fix the current style with what is actual calculated:
                vnode.styles = fromStyles; // exactly styles, so we can transition well
                instance.setClass(NO_TRANS);
                instance.setAttr(STYLE, vnode.serializeStyles());
                async(function() {
                    // needs to be done in the next eventcyle, otherwise webkit-browsers miscalculate the syle (with transition on)
                    instance.removeClass(NO_TRANS);
                });

                // now calculate the final value
                clonedElement = instance.cloneNode(true);
                toStylesExact = vnodeStyles.deepClone();
                clonedElement.vnode.styles = toStylesExact;
                clonedElement.setAttr(STYLE, clonedElement.vnode.serializeStyles());
                clonedElement.setClass(INVISIBLE);
                DOCUMENT.body.append(clonedElement);
                // clonedElement has &#x60;vnodeStyles&#x60;, but we change them into &#x60;toStylesExact&#x60;

                len = removed.length;
                for (i=0; i&lt;len; i++) {
                    item = removed[i];
                    prop = item.property;
                    group = item.pseudo || &#x27;element&#x27;;
                    if (!NON_CLONABLE_STYLES[prop]) {
                        value = (prop===VENDOR_TRANSFORM_PROPERTY) ? clonedElement.getInlineStyle(prop, item.pseudo) : clonedElement.getStyle(prop, item.pseudo);
                        if (value) {
                            toStylesExact[group] || (toStylesExact[group]={});
                            toStylesExact[group][prop] = value;
                        }
                    }
                    // look if we really have a change in the value:

                    if (toStylesExact[group] &amp;&amp; (toStylesExact[group][prop]!==fromStyles[group][prop])) {
                        transproperty = instance.getTransition(prop, (group===&#x27;element&#x27;) ? null : group);
                        transtime = transproperty.delay+transproperty.duration;
                        maxtranstime = Math.max(maxtranstime, transtime);
                        if (transtime&gt;0) {
                            transCount++;
                            // TODO: transitionProperties supposes that we DO NOT have pseudo transitions!
                            // as soon we do, we need to split this object for each &#x27;group&#x27;
                            transitionProperties[prop] = true;
                        }
                    }
                }
                hasTransitionedStyle = (transCount&gt;0);
                clonedElement.remove();
            }
            if (needSync) {
                if (returnPromise || hasTransitionedStyle) {
                    promise = window.Promise.manage();
                    // need to call &#x60;setAttr&#x60; in a next event-cycle, otherwise the eventlistener made
                    // by &#x60;getTransPromise gets blocked.
                    async(function() {
                        if (hasTransitionedStyle) {
                            // reset
                            vnode.styles = toStylesExact;
                            promise.then(function() {
                                vnode.styles = vnodeStyles; // finally values, not exactly calculated, but as is passed through
                                instance.setClass(NO_TRANS);
                                instance.setAttr(STYLE, vnode.serializeStyles());
                            }).finally(function() {
                                async(function() {
                                    instance.removeClass(NO_TRANS);
                                    // webkit browsers seems to need to recalculate their set width:
                                    instance.getBoundingClientRect();
                                });
                            });
                        }
                        else {
                            vnode.styles = vnodeStyles; // finally values, not exactly calculated, but as is passed through
                        }
                        getTransPromise(instance, hasTransitionedStyle, null, transCount, transitionProperties, maxtranstime).then(
                            promise.fulfill
                        ).catch(promise.reject);
                        instance.setAttr(STYLE, vnode.serializeStyles());
                    });
                }
                else {
                    vnode.styles = vnodeStyles; // finally values, not exactly calculated, but as is passed through
                    instance.setAttr(STYLE, vnode.serializeStyles());
                    // webkit browsers seems to need to recalculate their set width:
                    instance.getBoundingClientRect();
                }
            }
            // else
            return returnPromise ? (promise || window.Promise.resolve()) : instance;
        };

       /**
        * Removes a subtype &#x60;transform&#x60;-css-property of (inline) out of the Element.
        * This way you can sefely remove partial &#x60;transform&#x60;-properties while remaining the
        * other inline &#x60;transform&#x60; css=properties.
        *
        * See more about tranform-properties: https://developer.mozilla.org/en-US/docs/Web/CSS/transform
        *
        * @method removeInlineTransition
        * @param transitionProperty {String} the css-transform property to remove
        * @param [pseudo] {String} to look inside a pseudo-style
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.removeInlineTransition = function(transitionProperty, pseudo) {
            return this.removeInlineTransitions({property: transitionProperty, pseudo: pseudo});
        };

       /**
        * Removes multiple subtype &#x60;transform&#x60;-css-property of (inline) out of the Element.
        * This way you can sefely remove partial &#x60;transform&#x60;-properties while remaining the
        * other inline &#x60;transform&#x60; css=properties.
        * You need to supply an Array of Objects, with the properties:
        *        &lt;ul&gt;
        *            &lt;li&gt;property  {String}&lt;/li&gt;
        *            &lt;li&gt;pseudo  {String}&lt;/li&gt;
        *        &lt;ul&gt;
        *
        * See more about tranform-properties: https://developer.mozilla.org/en-US/docs/Web/CSS/transform
        *
        * @method removeInlineTransitions
        * @param transitionProperties {Array|Object} the css-transform properties to remove
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.removeInlineTransitions = function(transitionProperties) {
            var instance = this,
                vnode = instance.vnode,
                styles = vnode.styles,
                groupStyle, transitionStyles, i, len, item, needSync, transitionProperty, pseudo;

            if (styles) {
                Array.isArray(transitionProperties) || (transitionProperties=[transitionProperties]);
                transitionProperties = getVendorCSS(transitionProperties);
                len = transitionProperties.length;
                for (i=0; i&lt;len; i++) {
                    item = transitionProperties[i];
                    pseudo = item.pseudo;
                    groupStyle = styles &amp;&amp; styles[pseudo || &#x27;element&#x27;];
                    transitionStyles = groupStyle &amp;&amp; groupStyle[VENDOR_TRANSITION_PROPERTY];
                    if (transitionStyles) {
                        transitionProperty = item.property;
                        if (transitionStyles[transitionProperty]) {
                            delete transitionStyles[transitionProperty];
                            (transitionStyles.size()===0) &amp;&amp; (delete groupStyle[VENDOR_TRANSITION_PROPERTY]);
                            (styles.size()===0) &amp;&amp; (delete vnode.styles[pseudo || &#x27;element&#x27;]);
                            needSync = true;
                        }
                    }
                }
            }
            needSync &amp;&amp; instance.setAttr(STYLE, vnode.serializeStyles());
            return instance;
        };

       /**
        * Replaces the Element with a new Element.
        *
        * @method replace
        * @param content {Element|Element|ElementArray|String} content to replace
        * @param [escape] {Boolean} whether to insert &#x60;escaped&#x60; content, leading it into only text inserted
        * @return {Element} the created Element (or the last when multiple)
        * @since 0.0.1
        */
        ElementPrototype.replace = function(newElement, escape) {
            var instance = this,
                vnode = instance.vnode,
                previousVNode = vnode.vPrevious,
                vParent = vnode.vParent,
                createdElement;
            createdElement = previousVNode ? vParent.domNode.append(newElement, escape, previousVNode.domNode) : vParent.domNode.prepend(newElement, escape);
            instance.setClass(HIDDEN);
            instance.remove();
            return createdElement;
        };

        /**
        * Replaces the Element&#x27;s child-Element with a new Element.
        *
        * @method replaceChild
        * @param newElement {Element} the new Element
        * @param oldVChild {Element} the Element to be replaced
        * @param [escape] {Boolean} whether to insert &#x60;escaped&#x60; content, leading it into only text inserted
        * @return {Element} the Element that was removed (equals oldVChild)
        * @since 0.0.1
        */
        ElementPrototype._replaceChild = ElementPrototype.replaceChild;
        ElementPrototype.replaceChild = function(newDomNode, oldDomNode, escape) {
            return oldDomNode.replace(newDomNode, escape);
        };

       /**
        * Replaces the className of the Element with a new className.
        * If the previous className is not available, the new className is set nevertheless.
        *
        * @method replaceClass
        * @param prevClassName {String} the className to be replaced
        * @param newClassName {String} the className to be set
        * @param [force ] {Boolean} whether the new className should be set, even is the previous className isn&#x27;t there
        * @param [returnPromise] {Boolean} whether to return a Promise instead of &#x60;this&#x60;, which might be useful in case of
        *        transition-properties. The promise will fullfil when the transition is ready, or immediately when no transitioned.
        * @param [transitionFix] set this to &#x60;true&#x60; if you experience transition-problems due to wrong calculated css (mostly because of the &#x60;auto&#x60; value)
        *        Setting this parameter, will calculate the true css of the transitioned properties and set this temporarely inline, to fix the issue.
        *        Don&#x27;t use it when not needed, it has a slightly performancehit.
        *        No need to set when &#x60;returnPromise&#x60; is set --&gt; returnPromise always handles the transitionFix.
        * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
        * @return {Promise|this} In case &#x60;returnPromise&#x60; is set, a Promise returns with the next handles:
        *        &lt;ul&gt;
        *            &lt;li&gt;cancel() {Promise}&lt;/li&gt;
        *            &lt;li&gt;freeze() {Promise}&lt;/li&gt;
        *            &lt;li&gt;unfreeze()&lt;/li&gt;
        *            &lt;li&gt;finish() {Promise}&lt;/li&gt;
        *        &lt;/ul&gt;
        *        These handles resolve with the &#x60;elapsed-time&#x60; as first argument of the callbackFn
        * @since 0.0.1
        */
        ElementPrototype.replaceClass = function(prevClassName, newClassName, force, returnPromise, transitionFix, silent) {
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            var instance = this,
                transPromise = (returnPromise || transitionFix) &amp;&amp; getClassTransPromise(instance, REPLACE, newClassName, prevClassName, force),
                returnValue;
            if (force || instance.hasClass(prevClassName)) {
                returnValue = returnPromise ? transPromise : instance;
                transPromise || instance.removeClass(prevClassName).setClass(newClassName);
                return returnValue;
            }
            if (silent &amp;&amp; DOCUMENT.suppressMutationEvents) {
                if (returnValue===instance) {
                    DOCUMENT.suppressMutationEvents(false);
                }
                else {
                    returnValue.finally(function() {
                        DOCUMENT.suppressMutationEvents(false);
                    });
                }
            }
            return returnPromise ? window.Promise.resolve() : instance;
        };

        /**
         * Scrolls the content of the Element into the specified scrollposition.
         * Only available when the Element has overflow.
         *
         * @method scrollTo
         * @param x {Number} left-offset in pixels
         * @param y {Number} top-offset in pixels
         * @chainable
         * @since 0.0.1
        */
        ElementPrototype.scrollTo = function(x, y) {
            var instance = this;
            instance.scrollLeft = x;
            instance.scrollTop = y;
            return instance;
        };

       /**
         * Sets the attribute on the Element with the specified value.
         *
         * Alias for setAttribute(), BUT differs in a way that setAttr is chainable, setAttribute is not.
         *
         * @method setAttr
         * @param attributeName {String}
         * @param value {Any} the value that belongs to &#x60;key&#x60;
         * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
         * @chainable
         * @since 0.0.1
        */
        ElementPrototype.setAttr = function(attributeName, value, silent) {
            var instance = this;
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            instance.setAttribute(attributeName, value);
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(false);
            return instance;
        };

       /**
         * Sets the attribute on the Element with the specified value.
         *
         * Alias for setAttr(), BUT differs in a way that setAttr is chainable, setAttribute is not.
         *
         * @method setAttribute
         * @param attributeName {String}
         * @param value {String} the value for the attributeName
        */
        ElementPrototype._setAttribute = ElementPrototype.setAttribute;
        ElementPrototype.setAttribute = function(attributeName, value) {
            var instance = this,
                vnode = instance.vnode;
            (value===&#x27;&#x27;) &amp;&amp; (value=null);
            ((value!==null) &amp;&amp; (value!==undefined)) ? vnode._setAttr(attributeName, value) : vnode._removeAttr(attributeName);
        };

       /**
         * Sets multiple attributes on the Element with the specified value.
         * The argument should be one ore more Objects with the properties: &#x60;name&#x60; and &#x60;value&#x60;
         *
         * @example
         * instance.setAttrs([
         *                      {name: &#x27;tabIndex&#x27;, value: &#x27;0&#x27;},
         *                      {name: &#x27;style&#x27;, value: &#x27;color: #000;&#x27;}
         *                  ]);
         *
         * @method setAttrs
         * @param attributeData {Array|Object}
         * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
         * @chainable
         * @since 0.0.1
        */
        ElementPrototype.setAttrs = function(attributeData, silent) {
            var instance = this;
            Array.isArray(attributeData) || (attributeData=[attributeData]);
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            attributeData.forEach(function(item) {
                instance.setAttribute(item.name, item.value);
            });
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(false);
            return instance;
        };

       /**
        * Adds a class to the Element. If the class already exists it won&#x27;t be duplicated.
        *
        * @method setClass
        * @param className {String|Array} className to be added, may be an array of classNames
        * @param [returnPromise] {Boolean} whether to return a Promise instead of &#x60;this&#x60;, which might be useful in case of
        *        transition-properties. The promise will fullfil when the transition is ready, or immediately when no transitioned.
        * @param [transitionFix] set this to &#x60;true&#x60; if you experience transition-problems due to wrong calculated css (mostly because of the &#x60;auto&#x60; value)
        *        Setting this parameter, will calculate the true css of the transitioned properties and set this temporarely inline, to fix the issue.
        *        Don&#x27;t use it when not needed, it has a slightly performancehit.
        *        No need to set when &#x60;returnPromise&#x60; is set --&gt; returnPromise always handles the transitionFix.
        * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
        * @return {Promise|this} In case &#x60;returnPromise&#x60; is set, a Promise returns with the next handles:
        *        &lt;ul&gt;
        *            &lt;li&gt;cancel() {Promise}&lt;/li&gt;
        *            &lt;li&gt;freeze() {Promise}&lt;/li&gt;
        *            &lt;li&gt;unfreeze()&lt;/li&gt;
        *            &lt;li&gt;finish() {Promise}&lt;/li&gt;
        *        &lt;/ul&gt;
        *        These handles resolve with the &#x60;elapsed-time&#x60; as first argument of the callbackFn
        * @since 0.0.1
        */
        ElementPrototype.setClass = function(className, returnPromise, transitionFix, silent) {
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            var instance = this,
                transPromise = (returnPromise || transitionFix) &amp;&amp; getClassTransPromise(instance, SET, className),
                returnValue = returnPromise ? transPromise : instance;
            transPromise || instance.getClassList().add(className);
            if (silent &amp;&amp; DOCUMENT.suppressMutationEvents) {
                if (returnValue===instance) {
                    DOCUMENT.suppressMutationEvents(false);
                }
                else {
                    returnValue.finally(function() {
                        DOCUMENT.suppressMutationEvents(false);
                    });
                }
            }
            return returnValue;
        };

        /**
         * Stores arbitary &#x60;data&#x60; at the Element (actually at vnode). This has nothing to do with node-attributes whatsoever,
         * it is just a way to bind any data to the specific Element so it can be retrieved later on with &#x60;getData()&#x60;.
         *
         * @method setData
         * @param key {string} name of the key
         * @param value {Any} the value that belongs to &#x60;key&#x60;
         * @param [deep] {Boolean} whether to set the data to all descendants recursively
         * @chainable
         * @since 0.0.1
        */
        ElementPrototype.setData = function(key, value, deep) {
            var instance = this,
                vnode = instance.vnode;
            if (value!==undefined) {
                vnode._data || Object.protectedProp(vnode, &#x27;_data&#x27;, {});
                vnode._data[key] = value;
                if (deep) {
                    instance.getChildren().forEach(function(element) {
                        element.setData(key, value, true);
                    });
                }
            }
            return instance;
        };

        /**
         * Sets the innerHTML of both the vnode as well as the representing dom-node.
         * Goes through the vdom, so it&#x27;s superfast.
         *
         * Use this method instead of &#x60;innerHTML&#x60;
         *
         * Syncs with the DOM.
         *
         * @method setHTML
         * @param val {String} the new value to be set
         * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
         * @chainable
         * @since 0.0.1
         */
        ElementPrototype.setHTML = function(val, silent) {
            var instance = this;
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            instance.vnode.innerHTML = val;
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(false);
            return instance;
        };

       /**
        * Sets the Elments &#x60;id&#x60;
        *
        * @method setId
        * @param val {String} Elements new &#x60;id&#x60;
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.setId = function(val) {
            return this.setAttr(&#x27;id&#x27;, val);
        };

       /**
        * Sets a css-property (inline) for the Element.
        *
        * Note1: Do not use vendor-specific properties, but general (like &#x60;transform&#x60; instead of &#x60;-webkit-transform&#x60;)
        *        This method will use the appropriate css-property.
        * Note2: no need to camelCase cssProperty: both &#x60;margin-left&#x60; as well as &#x60;marginLeft&#x60; are fine
        *
        * @method setInlineStyle
        * @param cssProperty {String} the css-property to be set
        * @param value {String} the css-value
        * @param [pseudo] {String} to look inside a pseudo-style
        * @param [returnPromise] {Boolean} whether to return a Promise instead of &#x60;this&#x60;, which might be useful in case of
        *        transition-properties. The promise will fullfil when the transition is ready, or immediately when no transitioned.
        * @return {Promise|this}
        * @since 0.0.1
        */
        ElementPrototype.setInlineStyle = function(cssProperty, value, pseudo, returnPromise) {
            if (typeof pseudo===&#x27;boolean&#x27;) {
                returnPromise = pseudo;
                pseudo = null;
            }
            return this.setInlineStyles([{property: cssProperty, value: value, pseudo: pseudo}], returnPromise);
        };

       /**
        * Sets multiple css-properties (inline) for the Element at once.
        *
        * Note1: Do not use vendor-specific properties, but general (like &#x60;transform&#x60; instead of &#x60;-webkit-transform&#x60;)
        *        This method will use the appropriate css-property.
        * Note2: no need to camelCase cssProperty: both &#x60;margin-left&#x60; as well as &#x60;marginLeft&#x60; are fine
        *
        * @method setInlineStyles
        * @param cssProperties {Array|Object} the css-properties to be set, specified as an Array of Objects, or 1 Object.
        *        The objects should have the next properties:
        *        &lt;ul&gt;
        *            &lt;li&gt;property  {String}&lt;/li&gt;
        *            &lt;li&gt;value  {String}&lt;/li&gt;
        *            &lt;li&gt;pseudo  {String} (optional) --&gt; not: not supported yet in browsers&lt;/li&gt;
        *        &lt;/ul&gt;
        * @param [returnPromise] {Boolean} whether to return a Promise instead of &#x60;this&#x60;, which might be useful in case of
        *        transition-properties. The promise will fullfil when the transition is ready, or immediately when no transitioned.
        * @return {Promise|this}
        * @since 0.0.1
        */
        ElementPrototype.setInlineStyles = function(cssProperties, returnPromise) {
            // There will be 3 sets of styles:
            // &#x60;fromStyles&#x60; --&gt; the current styles, only exactly calculated -without &#x60;auto&#x60;- (that is, for the transitioned properties)
            // &#x60;toStylesExact&#x60; --&gt; the new styles, exactly calculated -without &#x60;auto&#x60;- (that is, for the transitioned properties)
            // &#x60;vnodeStyles&#x60; --&gt; the new styles as how they should be in the end (f.i. with &#x60;auto&#x60;)
            var instance = this,
                vnode = instance.vnode,
                transitionedProps = [],
                transCount = 0,
                maxtranstime = 0,
                transitionProperties = {},
                // third argument is a hidden feature --&gt; used by getClassTransPromise()
                avoidBackup = arguments[2],
                styles, group, i, len, item, promise, hasTransitionedStyle, property, hasChanged, transtime,
                pseudo, fromStyles, value, vnodeStyles, toStylesExact, clonedElement, transproperty;

            // if there is a class-transition going on (initiated by getClassTransPromise),
            // the we might need to update the internal bkpNode:
            if (!avoidBackup &amp;&amp; vnode._data) {
                // there might be more bkpNodes, so we need to loop through the data:
                vnode._data.each(function(bkpNode, key) {
                    if (key.startsWith(&#x27;bkpNode&#x27;)) {
                        bkpNode.setInlineStyles(cssProperties, null, true);
                    }
                });
            }

            Array.isArray(cssProperties) || (cssProperties=[cssProperties]);
            cssProperties = getVendorCSS(cssProperties);
            len = cssProperties.length;
            vnode.styles || (vnode.styles={});
            vnodeStyles = vnode.styles;
            // Both &#x60;from&#x60; and &#x60;to&#x60; ALWAYS need to be set to their calculated value --&gt; this makes transition
            // work with &#x60;auto&#x60;, or when the page isn&#x27;t completely loaded
            // First: backup the actual style:
            fromStyles = vnodeStyles.deepClone();
            for (i=0; i&lt;len; i++) {
                item = cssProperties[i];
                pseudo = item.pseudo;
                group = pseudo || &#x27;element&#x27;;
                vnodeStyles[group] || (vnodeStyles[group]={});
                styles = vnodeStyles[group];
                property = fromCamelCase(item.property);
                value = item.value;

                (property===VENDOR_TRANSITION_PROPERTY) &amp;&amp; (value=extractor.toTransitionObject(value));
                if (value===undefined) {
                    delete styles[property];
                }
                else {
                    styles[property] = value;
                }
                if ((property!==VENDOR_TRANSITION_PROPERTY) &amp;&amp; instance.hasTransition(property, pseudo)) {
                    fromStyles[group] || (fromStyles[group]={});
                    (property===VENDOR_TRANSFORM_PROPERTY) || (fromStyles[group][property]=instance.getStyle(property, pseudo));
                    if (fromStyles[group][property]!==value) {
                        transproperty = instance.getTransition(property, (group===&#x27;element&#x27;) ? null : group);
                        transtime = transproperty.delay+transproperty.duration;
                        maxtranstime = Math.max(maxtranstime, transtime);
                        if (transtime&gt;0) {
                            hasTransitionedStyle = true;
                            transCount++;
                            // TODO: transitionProperties supposes that we DO NOT have pseudo transitions!
                            // as soon we do, we need to split this object for each &#x27;group&#x27;
                            transitionProperties[property] = true;
                            transitionedProps[transitionedProps.length] = {
                                group: group,
                                property: property,
                                value: value,
                                pseudo: pseudo
                            };
                        }
                    }
                }
            }
            RUNNING_ON_NODE &amp;&amp; (hasTransitionedStyle=false);
            if (hasTransitionedStyle) {
                // we forced set the exact initial css inline --&gt; this is the only way to make a right transition
                // under all circumstances
                toStylesExact = vnodeStyles.deepClone();
                clonedElement = instance.cloneNode(true); // cloned with &#x60;vnodeStyles&#x60;
                clonedElement.vnode.styles = toStylesExact;
                // fix the current style with what is actual calculated:
                vnode.styles = fromStyles; // exactly styles, so we can transition well
                instance.setClass(NO_TRANS);
                instance.setAttr(STYLE, vnode.serializeStyles());
                async(function() {
                    // needs to be done in the next eventcyle, otherwise webkit-browsers miscalculate the syle (with transition on)
                    instance.removeClass(NO_TRANS);
                });

                // clonedElement has &#x60;vnodeStyles&#x60;, but we change them into &#x60;toStylesExact&#x60;
                clonedElement.setClass(INVISIBLE);
                clonedElement.setAttr(STYLE, clonedElement.vnode.serializeStyles());
                DOCUMENT.body.append(clonedElement);

                // now calculate the &#x60;transition&#x60; styles and store them in the css-property of &#x60;toStylesExact&#x60;:
                len = transitionedProps.length;
                hasChanged = false;
                for (i=0; i&lt;len; i++) {
                    item = transitionedProps[i];
                    property = item.property;
                    group = item.pseudo || &#x27;element&#x27;;
                    if (!NON_CLONABLE_STYLES[property]) {
                        value = (property===VENDOR_TRANSFORM_PROPERTY) ? clonedElement.getInlineStyle(property, item.pseudo) : clonedElement.getStyle(property, item.pseudo);
                        if (value) {
                            toStylesExact[group] || (toStylesExact[group]={});
                            toStylesExact[group][property] = value;
                        }
                    }
                    // look if we really have a change in the value:
                    if (!hasChanged &amp;&amp; toStylesExact[group]) {
                        hasChanged = (toStylesExact[group][property]!==fromStyles[group][property]);
                    }
                }
                clonedElement.remove();
                hasTransitionedStyle = hasChanged;
            }
            RUNNING_ON_NODE &amp;&amp; (hasTransitionedStyle=false);
            if (returnPromise || hasTransitionedStyle) {
                promise = window.Promise.manage();
                // need to call &#x60;setAttr&#x60; in a next event-cycle, otherwise the eventlistener made
                // by &#x60;getTransPromise gets blocked.
                async(function() {
                    if (hasTransitionedStyle) {
                        // reset
                        vnode.styles = toStylesExact;
                        promise.then(function() {

                            vnode.styles = vnodeStyles; // finally values, not exactly calculated, but as is passed through
                            instance.setClass(NO_TRANS);
                            instance.setAttr(STYLE, vnode.serializeStyles());
                        }).finally(function() {
                            async(function() {
                                // needs to be done in the next eventcyle, otherwise webkit-browsers miscalculate the syle (with transition on)
                                instance.removeClass(NO_TRANS);
                                // webkit browsers seems to need to recalculate their set width:
                                instance.getBoundingClientRect();
                            });
                        });
                    }
                    else {
                        vnode.styles = vnodeStyles; // finally values, not exactly calculated, but as is passed through
                    }
                    getTransPromise(instance, hasTransitionedStyle, null, transCount, transitionProperties, maxtranstime).then(
                        function() {
                            promise.fulfill();
                        }
                    ).catch(promise.reject);
                    instance.setAttr(STYLE, vnode.serializeStyles());
                });
                return returnPromise ? promise : instance;
            }
            // else
            vnode.styles = vnodeStyles; // finally values, not exactly calculated, but as is passed through
            instance.setAttr(STYLE, vnode.serializeStyles());
            // webkit browsers seems to need to recalculate their set width:
            instance.getBoundingClientRect();
            return instance;
        };

       /**
        * Sets a transform-css-property (inline) for the Element.
        *
        * See more about transitions: https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Using_CSS_transitions
        *
        * @method setStyle
        * @param setInlineTransition {String} the css-property to be set, f.e. &#x60;translateX&#x60;
        * @param duration {Number} the duration in seconds (may be a broken number, like &#x60;0.5&#x60;)
        * @param [timingFunction] {String} See https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function
        * @param delay {Number} the delay in seconds (may be a broken number, like &#x60;0.5&#x60;)
        * @param [pseudo] {String} to look inside a pseudo-style
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.setInlineTransition = function(transitionProperty, duration, timingFunction, delay, pseudo) {
            // transition-example: transition: width 2s, height 2s, transform 2s;
            return this.setInlineTransitions({property: transitionProperty, duration: duration, timingFunction: timingFunction, delay: delay, pseudo: pseudo});
        };

       /**
        * Sets a transform-css-property (inline) for the Element.
        *
        * See more about transitions: https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Using_CSS_transitions
        *
        * @method setStyle
        * @param transitionProperties {Array} the css-transition-properties to be set, specified as an Array of Objects.
        *        The objects should have the next properties:
        *        &lt;ul&gt;
        *            &lt;li&gt;property  {String}&lt;/li&gt;
        *            &lt;li&gt;duration  {Number}&lt;/li&gt;
        *            &lt;li&gt;timingFunction  {String} (optional)&lt;/li&gt;
        *            &lt;li&gt;delay  {Number} (optional)&lt;/li&gt;
        *            &lt;li&gt;pseudo  {String} (optional)&lt;/li&gt;
        *        &lt;/ul&gt;
        * @param [pseudo] {String} to look inside a pseudo-style
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.setInlineTransitions = function(transitionProperties) {
            // transition-example: transition: width 2s, height 2s, transform 2s;
            var instance = this,
                vnode = instance.vnode,
                transitionStyles, transitionProperty, group, trans, i, len, item;
            Array.isArray(transitionProperties) || (transitionProperties=[transitionProperties]);
            transitionProperties = getVendorCSS(transitionProperties);
            len = transitionProperties.length;
            vnode.styles || (vnode.styles={});
            for (i=0; i&lt;len; i++) {
                item = transitionProperties[i];
                if (item.property) {
                    group = item.pseudo || &#x27;element&#x27;;
                    vnode.styles[group] || (vnode.styles[group]={});
                    vnode.styles[group][VENDOR_TRANSITION_PROPERTY] || (vnode.styles[group][VENDOR_TRANSITION_PROPERTY]={});
                    transitionStyles = vnode.styles[group][VENDOR_TRANSITION_PROPERTY];
                    transitionProperty = fromCamelCase(item.property);
                    trans = transitionStyles[transitionProperty] = {
                        duration: item.duration
                    };
                    item.timingFunction &amp;&amp; (trans.timingFunction=item.timingFunction);
                    item.delay &amp;&amp; (trans.delay=item.delay);
                }
            }
            instance.setAttr(STYLE, vnode.serializeStyles());
            return instance;
        };

        /**
         * Gets or sets the outerHTML of both the Element as well as the representing dom-node.
         * Goes through the vdom, so it&#x27;s superfast.
         *
         * Use this property instead of &#x60;outerHTML&#x60;
         *
         * Syncs with the DOM.
         *
         * @method setOuterHTML
         * @param val {String} the new value to be set
         * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
         * @chainable
         * @since 0.0.1
         */
        ElementPrototype.setOuterHTML = function(val, silent) {
            var instance = this;
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            instance.vnode.outerHTML = val;
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(false);
            return instance;
        };

        /**
         * Sets the innerContent of the Element as plain text.
         * Goes through the vdom, so it&#x27;s superfast.
         *
         * Use this method instead of &#x60;textContent&#x60;
         *
         * Syncs with the DOM.
         *
         * @method setText
         * @param val {String} the textContent to be set
         * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
         * @chainable
         * @since 0.0.1
         */
        ElementPrototype.setText = function(val, silent) {
            var instance = this;
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            instance.vnode.textContent = val;
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(false);
            return instance;
        };

       /**
        * Sets the value of the following Elements:
        *
        * &lt;ul&gt;
        *     &lt;li&gt;input&lt;/li&gt;
        *     &lt;li&gt;textarea&lt;/li&gt;
        *     &lt;li&gt;select&lt;/li&gt;
        *     &lt;li&gt;any container that is &#x60;contenteditable&#x60;&lt;/li&gt;
        * &lt;/ul&gt;
        *
        * Will emit a &#x60;valuechange&#x60;-event when a new value is set and ITSA&#x27;s &#x60;event&#x60;-module is active.
        *
        * @method setValue
        * @param val {String} thenew value to be set
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.setValue = function(val) {
            var instance = this,
                prevVal = instance.value,
                contenteditable = instance.vnode.attrs.contenteditable,
            // cautious: input and textarea must be accessed by their propertyname:
            // input.getAttribute(&#x27;value&#x27;) would return the defualt-value instead of actusl
            // and textarea.getAttribute(&#x27;value&#x27;) doesn&#x27;t exist
                editable = contenteditable &amp;&amp; (contenteditable!==&#x27;false&#x27;),
                tag, i, option, len, vChildren;
            if (editable) {
                instance.setHTML(val);
            }
            else {
                tag = instance.getTagName();
                if ((tag===&#x27;INPUT&#x27;) || (tag===&#x27;TEXTAREA&#x27;)) {
                    instance.value = val;
                }
                else if (tag===&#x27;SELECT&#x27;) {
                    vChildren = instance.vnode.vChildren;
                    len = vChildren.length;
                    for (i=0; i&lt;len; i++) {
                        option = vChildren[i];
                        if (option.attrs.value === val) {
                            instance.selectedIndex = i;
                            break;
                        }
                    }
                }
            }
            // if &#x60;document._emitVC&#x60; is available, then invoke it to emit the &#x60;valuechange&#x60;-event
            /**
            * @event valuechange
            * @param e.value {String} new value
            * @param e.sourceTarget {Element} Element whare the valuechange occured
            */
            DOCUMENT._emitVC &amp;&amp; (prevVal!==val) &amp;&amp; DOCUMENT._emitVC(instance, val);
            return instance;
        };

       /**
         * Set the position of an html element in page coordinates.
         * The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         *
         * If the Element has the attribute &#x60;xy-constrian&#x60; set, then its position cannot exceed any matching container it lies within.
         *
         * @method setXY
         * @param x {Number} x-value for new position (coordinates are page-based)
         * @param y {Number} y-value for new position (coordinates are page-based)
         * @param [constrain] {&#x27;window&#x27;, Element, Object, String}
         * &lt;ul&gt;
         *     &lt;li&gt;&lt;b&gt;&#x27;window&#x27;&lt;/b&gt; to constrain to the visible window&lt;/li&gt;
         *     &lt;li&gt;&lt;b&gt;Element&lt;/b&gt; to constrain to a specified Element&lt;/li&gt;
         *     &lt;li&gt;&lt;b&gt;Object&lt;/b&gt; to constrain to an object with the properties: {x, y, w, h} where x and y are absolute pixels of the document
         *            (like calculated with getX() and getY()).&lt;/li&gt;
         *     &lt;li&gt;&lt;b&gt;String&lt;/b&gt; to constrain to a specified css-selector, which should be an ancestor&lt;/li&gt;
         * &lt;/ul&gt;
         * @param [notransition=false] {Boolean} set true if you are sure positioning is without transition.
         *        this isn&#x27;t required, but it speeds up positioning. Only use when no transition is used:
         *        when there is a transition, setting this argument &#x60;true&#x60; would miscalculate the position.
         *        The return-value will be &#x60;this&#x60; in case &#x60;notransition&#x60;===true, making setXY to be chainable.
         * @return {Promise|this}
         * @since 0.0.1
         */
        ElementPrototype.setXY = function(x, y, constrain, notransition) {
            console.log(NAME, &#x27;setXY &#x27;+x+&#x27;,&#x27;+y);
            var instance = this,
                dif, match, constrainNode, byExactId, parent, clone, promise,
                containerTop, containerRight, containerLeft, containerBottom, requestedX, requestedY,
                transObject, xtrans, ytrans, inlinePosition, globalPosition, invisibleClass;

            // default position to relative: check first inlinestyle because this goes quicker
            inlinePosition = instance.getInlineStyle(POSITION);
            inlinePosition || (globalPosition=instance.getStyle(POSITION));
            if ((inlinePosition===&#x27;static&#x27;) || (inlinePosition===&#x27;fixed&#x27;) || (globalPosition===&#x27;static&#x27;) || (globalPosition===&#x27;fixed&#x27;)) {
                inlinePosition = &#x27;relative&#x27;;
                instance.setInlineStyle(POSITION, inlinePosition);
            }
            invisibleClass = (inlinePosition===&#x27;absolute&#x27;) ? INVISIBLE : INVISIBLE_RELATIVE;
            // make sure it has sizes and can be positioned
            instance.setClass([invisibleClass, BORDERBOX]);
            (instance.getInlineStyle(&#x27;display&#x27;)===&#x27;none&#x27;) &amp;&amp; instance.setClass(BLOCK);
            constrain || (constrain=instance.getAttr(&#x27;constrain-selector&#x27;));
            if (constrain) {
                if (constrain===&#x27;window&#x27;) {
                    containerLeft = window.getScrollLeft();
                    containerTop = window.getScrollTop();
                    containerRight = containerLeft + window.getWidth();
                    containerBottom = containerTop + window.getHeight();
                }
                else {
                    if (typeof constrain === STRING) {
                        match = false;
                        constrainNode = instance.getParent();
                        byExactId = REGEXP_NODE_ID.test(constrain);
                        while (constrainNode.matchesSelector &amp;&amp; !match) {
                            match = byExactId ? (constrainNode.id===constrain.substr(1)) : constrainNode.matchesSelector(constrain);
                            // if there is a match, then make sure x and y fall within the region
                            match || (constrainNode=constrainNode.getParent());
                        }
                        // if Element found, then bound it to &#x60;constrain&#x60; as if the argument &#x60;constrain&#x60; was an Element
                        match &amp;&amp; (constrain=constrainNode);
                    }
                    if (constrain.matchesSelector) {
                        // Element --&gt; we need to search the rectangle
                        containerLeft = constrain.left + parseInt(constrain.getStyle(BORDER_LEFT_WIDTH), 10);
                        containerTop = constrain.top + parseInt(constrain.getStyle(BORDER_TOP_WIDTH), 10);
                        containerRight = containerLeft + constrain.scrollWidth;
                        containerBottom = containerTop + constrain.scrollHeight;
                    }
                    else {
                        containerLeft = constrain.x;
                        containerTop = constrain.y;
                        containerRight = constrain.x + constrain.w;
                        containerBottom = constrain.y + constrain.h;
                    }
                }
                if (typeof containerLeft === NUMBER) {
                    // found constrain, always redefine x and y
                    x = requestedX = (typeof x===NUMBER) ? x : instance.left;
                    if (requestedX&lt;containerLeft) {
                        x = containerLeft;
                    }
                    else {
                        if ((requestedX+instance.offsetWidth)&gt;containerRight) {
                            x = requestedX = containerRight - instance.offsetWidth;
                        }
                        // now we might need to reset to the left again:
                        (requestedX&lt;containerLeft) &amp;&amp; (x=containerLeft);
                    }
                    y = requestedY = (typeof y===NUMBER) ? y : instance.top;
                    if (requestedY&lt;containerTop) {
                        y = containerTop;
                    }
                    else {
                        if ((requestedY+instance.offsetHeight)&gt;containerBottom) {
                            y = requestedY = containerBottom - instance.offsetHeight;
                        }
                        // now we might need to reset to the top again:
                        (requestedY&lt;containerTop) &amp;&amp; (y=containerTop);
                    }
                }
            }
            xtrans = (typeof x === NUMBER);
            ytrans = (typeof y === NUMBER);
            if (xtrans || ytrans) {
                // check if there is a transition:
                if (notransition) {
                    instance.setClass([NO_TRANS2, invisibleClass]);
                    transObject = [];
                    xtrans &amp;&amp; (transObject[0]={property: LEFT, value: x + PX});
                    ytrans &amp;&amp; (transObject[xtrans ? 1 : 0]={property: TOP, value: y + PX});
                    instance.setInlineStyles(transObject);
                    // reset transObject and maybe it will be filled when there is a difference
                    // between the set value and the true value (which could appear due to different &#x60;position&#x60; properties)
                    transObject = [];
                    if (xtrans) {
                        dif = (instance.left-x);
                        (dif!==0) &amp;&amp; (transObject[0]={property: LEFT, value: (x - dif) + PX});
                    }
                    if (ytrans) {
                        dif = (instance.top-y);
                        (dif!==0) &amp;&amp; (transObject[transObject.length]={property: TOP, value: (y - dif) + PX});
                    }
                    (transObject.length&gt;0) &amp;&amp; instance.setInlineStyles(transObject);
                    instance.removeClass([NO_TRANS2, invisibleClass]);
                }
                else {
                    // we will clone the node, make it invisible and without transitions and look what its correction should be
                    clone = instance.cloneNode();
                    clone.setClass([NO_TRANS2, invisibleClass]);
                    parent = instance.getParent() || DOCUMENT.body;
                    parent.prepend(clone, null, instance);

                    transObject = [];
                    xtrans &amp;&amp; (transObject[0]={property: LEFT, value: x + PX});
                    ytrans &amp;&amp; (transObject[xtrans ? 1 : 0]={property: TOP, value: y + PX});

                    clone.setInlineStyles(transObject);

                    // reset transObject and fill it with the final true values
                    transObject = [];
                    xtrans &amp;&amp; (transObject[0]={property: LEFT, value: (2*x-clone.left) + PX});
                    ytrans &amp;&amp; (transObject[xtrans ? 1 : 0]={property: TOP, value: (2*y-clone.top) + PX});
                    clone.remove();
                    promise = instance.setInlineStyles(transObject, true);
                }
            }
            else if (!notransition) {
                promise = window.Promise.resolve();
            }
            instance.removeClass([BLOCK, BORDERBOX, invisibleClass]);
            return promise || instance;
        };

       /**
        * Shows a previously hidden node.
        * Shows immediately without &#x60;fade&#x60;, or will fade-in when fade is specified.
        *
        * @method show
        * @param [fade] {Number} sec to fade-in (you may use &#x60;0.1&#x60;)
        * @return {this|Promise} fulfilled when the element is ready showing up, or rejected when hidden again (using node.hide) before fully showed.
        * @since 0.0.1
        */
        ElementPrototype.show = function(duration, forceFull) {
            var instance = this,
                showPromise = instance.getData(&#x27;_showNodeBusy&#x27;),
                hidePromise = instance.getData(&#x27;_hideNodeBusy&#x27;),
                originalOpacity, hasOriginalOpacity, promise, freezedOpacity, finalValue;

            originalOpacity = instance.getData(&#x27;_showNodeOpacity&#x27;);
            if (!originalOpacity &amp;&amp; !showPromise &amp;&amp; !hidePromise) {
                originalOpacity = instance.getInlineStyle(&#x27;opacity&#x27;);
                instance.setData(&#x27;_showNodeOpacity&#x27;, originalOpacity);
            }
            hasOriginalOpacity = !!originalOpacity;

            showPromise &amp;&amp; showPromise.freeze();
            hidePromise &amp;&amp; hidePromise.freeze();

            if (duration) {

                instance.setInlineStyle(&#x27;opacity&#x27;, (instance.hasClass(HIDDEN) ? 0 : instance.getStyle(&#x27;opacity&#x27;)));
                instance.removeClass(HIDDEN);

                finalValue = (forceFull || !hasOriginalOpacity) ? 1 : originalOpacity;
                if (showPromise || hidePromise) {
                    freezedOpacity = instance.getInlineStyle(&#x27;opacity&#x27;);
                    duration = (finalValue&gt;0) ? Math.min(1, (freezedOpacity/finalValue))*duration : 0;
                }

                promise = instance.transition({property: &#x27;opacity&#x27;, value: finalValue, duration: duration});
                instance.setData(&#x27;_showNodeBusy&#x27;, promise);

                promise.finally(function() {
                    if (!promise.cancelled &amp;&amp; !promise.frozen) {
                        hasOriginalOpacity || instance.removeInlineStyle(&#x27;opacity&#x27;);
                        if (!forceFull || !hasOriginalOpacity) {
                            instance.removeData(&#x27;_showNodeOpacity&#x27;);
                        }
                    }
                    instance.removeData(&#x27;_showNodeBusy&#x27;);
                });
                return promise;
            }
            else {
                async(function() {
                    (hasOriginalOpacity &amp;&amp; !forceFull) ? instance.setInlineStyle(&#x27;opacity&#x27;, originalOpacity) : instance.removeInlineStyle(&#x27;opacity&#x27;);
                    instance.removeClass(HIDDEN);
                });
                return instance;
            }
        };

       /**
        * Transitions one ore more properties of the Element.
        *
        * @method toggleClass
        * @param to {Array} the css-properties to be set, specified as an Array of Objects.
        *        The objects should have the next properties:
        *        &lt;ul&gt;
        *            &lt;li&gt;property  {String}&lt;/li&gt;
        *            &lt;li&gt;value  {String}&lt;/li&gt;
        *            &lt;li&gt;duration  {Number} (optional)&lt;/li&gt;
        *            &lt;li&gt;timingFunction  {String} (optional)&lt;/li&gt;
        *            &lt;li&gt;delay  {String} (optional)&lt;/li&gt;
        *            &lt;li&gt;pseudo  {String} (optional) --&gt; not: not supported yet in browsers&lt;/li&gt;
        *        &lt;/ul&gt;
        * @param [from] {Array} starting the css-properties to be set, specified as an Array of Objects.
        *        If disguarded, then the current style is used as startingpoint. You may specify a subset of the &#x60;to&#x60;-properties.
        *        The objects should have the next properties:
        *        &lt;ul&gt;
        *            &lt;li&gt;property  {String}&lt;/li&gt;
        *            &lt;li&gt;value  {String}&lt;/li&gt;
        *            &lt;li&gt;duration  {Number} (optional)&lt;/li&gt;
        *            &lt;li&gt;timingFunction  {String} (optional)&lt;/li&gt;
        *            &lt;li&gt;delay  {String} (optional)&lt;/li&gt;
        *            &lt;li&gt;pseudo  {String} (optional) --&gt; not: not supported yet in browsers&lt;/li&gt;
        *        &lt;/ul&gt;
        * @return {Promise} The promise has the handles:
        *        &lt;ul&gt;
        *            &lt;li&gt;cancel() {Promise}&lt;/li&gt;
        *            &lt;li&gt;freeze() {Promise}&lt;/li&gt;
        *            &lt;li&gt;unfreeze()&lt;/li&gt;
        *            &lt;li&gt;finish() {Promise}&lt;/li&gt;
        *        &lt;/ul&gt;
        *        These handles resolve with the &#x60;elapsed-time&#x60; as first argument of the callbackFn
        * @since 0.0.1
        */
        ElementPrototype.transition = function(to, from) {
            var instance = this,
                currentInlineTransition, transitions, transitionRun, transitionError, promise, resolveHandle, initialStyle, time1,
                initialProperties, cleanup, getCurrentProperties, manipulated, getNoTransProp, transpromise, endIntermediate, time2;

            to || (to={});
            Array.isArray(to) || (to=[to]);
            to = getVendorCSS(to);
            time1 = Date.now();
            cleanup = function() {
                currentInlineTransition = instance.getData(&#x27;_bkpTransition&#x27;);
                currentInlineTransition ? instance.setInlineStyle(TRANSITION, currentInlineTransition) : instance.removeInlineStyle(TRANSITION);
                instance.removeData(&#x27;_bkpTransition&#x27;);
                instance.removeData(&#x27;_readyOnRun&#x27;);
                Object.defineProperty(promise, &#x27;isFulfilled&#x27;, {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: true
                });
            };
            getCurrentProperties = function() {
                var props = [],
                    currentStyle = window.getComputedStyle(instance),
                    currentStyleBefore = window.getComputedStyle(instance, &#x27;:before&#x27;),
                    currentStyleAfter = window.getComputedStyle(instance, &#x27;:after&#x27;);
                to.each(function(value) {
                    var styles = (value.pseudo===&#x27;:before&#x27;) ? currentStyleBefore : ((value.pseudo===&#x27;:after&#x27;) ? currentStyleAfter : currentStyle),
                        property = value.property;
                    // if property is vendor-specific transition, or transform, than we reset it to the current vendor
                    props.push({
                        property: property,
                        value: styles[toCamelCase(property)]
                    });
                });
                return props;
            };
            getNoTransProp = function() {
                var props = [];
                transitions.forEach(function(item) {
                    props.push({
                        property: item.property,
                        duration: 0,
                        delay: 0
                    });
                });
                return props;
            };

            endIntermediate = function(type) {
                if (!promise.isFulfilled) {
                    manipulated = true;
                    instance.setInlineTransitions(getNoTransProp());
                    instance.setInlineStyles((type===&#x27;cancelled&#x27;) ? initialProperties : getCurrentProperties());
                    // also force to set the style on the node outside the vdom --&gt; by forcing this
                    // we won&#x27;t run into the situation where the vdom doesn&#x27;t change the dom because the style didn&#x27;;&#x27;t change:
                    instance._setAttribute(STYLE, instance.getAttr(STYLE));
                    switch (type) {
                        case &#x27;cancelled&#x27;:
                            // now cleanup inline style that wasn&#x27;t there initially,
                            async(function() {
                                instance.setClass(NO_TRANS2);
                                instance.setAttr(STYLE, initialStyle);
                                instance.removeClass(NO_TRANS2);
                            });
                            cleanup();
                        break;
                        case &#x27;frozen&#x27;:
                            async(function() {
                                cleanup();
                            });
                        break;
                        case &#x27;finished&#x27;:
                            instance.setInlineStyles(to);
                            async(function() {
                                cleanup();
                            });
                        break;
                    }
                    Object.defineProperty(promise, type, {
                        configurable: false,
                        enumerable: false,
                        writable: false,
                        value: true
                    });
                    transpromise.reject(); // prevent transitionpromise to set its own final values after finishing
                    resolveHandle();
                }
                time2 || (time2=Date.now());
                return new window.Promise(function(resolve) {
                    async(function() {
                        resolve(time2-time1);
                    });
                });
            };
            promise = new window.Promise(function(resolve, reject) {
                async(function() {
                    resolveHandle = resolve;
                    transitionRun = idGenerator(&#x27;nodeTransition&#x27;);
                    // only make ready on the last run
                    instance.setData(&#x27;_readyOnRun&#x27;, transitionRun);

                    if (from) {
                        instance.setClass(NO_TRANS2);
                        instance.setInlineStyles(from);
                        instance.removeClass(NO_TRANS2);
                    }
                    initialProperties = getCurrentProperties();
                    initialStyle = instance.getAttr(STYLE);

                    currentInlineTransition = instance.getData(&#x27;_bkpTransition&#x27;);
                    if (currentInlineTransition===undefined) {
                        currentInlineTransition = instance.getInlineStyle(TRANSITION) || null;
                        // &#x60;null&#x60; can be set as node-data, &#x60;undefined&#x60; connot
                        instance.setData(&#x27;_bkpTransition&#x27;, currentInlineTransition);
                    }

                    // we could use the &#x60;to&#x60; object and pass into &#x60;setInlineTransitions&#x60; directly,
                    // however, in case &#x60;duration&#x60; is not specified, we will define them to 1 sec.
                    transitions = Array.isArray(to) ? to.deepClone() : [to.shallowClone()];

                    // CAUTIOUS: the sum of &#x60;duration&#x60;+&#x60;delay&#x60; determines when the transition will be ready.
                    // This leads into separate transitions, we must prevent the promise to fulfill on the
                    // first tranition to be ready.
                    // Thus: we need to split every (&#x60;duration&#x60;+&#x60;delay&#x60;) group and give them each a separate setInlineStyle()-promise!
                    transitions.forEach(function(item) {
                        item.duration || (item.duration=1);
                        item.delay || (item.delay=0);
                    });

                    instance.setInlineTransitions(transitions);
                    transpromise = instance.setInlineStyles(to, true);
                    transpromise.catch(
                        function(err) {
                            transitionError = err;
                            return true; // fulfill the chain
                        }
                    ).finally(
                        function() {
                            // to prevent &#x60;transitionend&#x60; events biting each other when chaining &#x60;transition&#x60;,
                            // and reset the inline transition in time,
                            // we need to resolve the Promise after the eventstack:
                            async(function() {
                                if (!manipulated &amp;&amp; (instance.getData(&#x27;_readyOnRun&#x27;)===transitionRun)) {
                                    cleanup();
                                    // because cleanup does an async action (setInlineStyles), we will append the eventstack:
                                    async(function() {
                                        if (transitionError) {
                                            reject(transitionError);
                                        }
                                        else {
                                            time2 || (time2=Date.now());
                                            resolve(time2-time1);
                                        }
                                    });
                                }
                            });
                        }
                    );
                });
            });

            promise.cancel = function() {
                return endIntermediate(&#x27;cancelled&#x27;);
            };

            promise.freeze = function() {
                return endIntermediate(&#x27;frozen&#x27;);
            };

            promise.finish = function() {
                return endIntermediate(&#x27;finished&#x27;);
            };

            return promise;
        };

       /**
        * Toggles the className of the Element.
        *
        * @method toggleClass
        * @param className {String|Array} className that should be toggled, may be an array of classNames
        * @param forceState {Boolean} to force toggling into this specific state
        * @param [returnPromise] {Boolean} whether to return a Promise instead of &#x60;this&#x60;, which might be useful in case of
        *        transition-properties. The promise will fullfil when the transition is ready, or immediately when no transitioned.
        * @param [transitionFix] set this to &#x60;true&#x60; if you experience transition-problems due to wrong calculated css (mostly because of the &#x60;auto&#x60; value)
        *        Setting this parameter, will calculate the true css of the transitioned properties and set this temporarely inline, to fix the issue.
        *        Don&#x27;t use it when not needed, it has a slightly performancehit.
        *        No need to set when &#x60;returnPromise&#x60; is set --&gt; returnPromise always handles the transitionFix.
        * @param [silent=false] {Boolean} prevent node-mutation events by the Event-module to emit
        * @return {Promise|this} In case &#x60;returnPromise&#x60; is set, a Promise returns with the next handles:
        *        &lt;ul&gt;
        *            &lt;li&gt;cancel() {Promise}&lt;/li&gt;
        *            &lt;li&gt;freeze() {Promise}&lt;/li&gt;
        *            &lt;li&gt;unfreeze()&lt;/li&gt;
        *            &lt;li&gt;finish() {Promise}&lt;/li&gt;
        *        &lt;/ul&gt;
        *        These handles resolve with the &#x60;elapsed-time&#x60; as first argument of the callbackFn
        * @since 0.0.1
        */
        ElementPrototype.toggleClass = function(className, forceState, returnPromise, transitionFix, silent) {
            silent &amp;&amp; DOCUMENT.suppressMutationEvents &amp;&amp; DOCUMENT.suppressMutationEvents(true);
            var instance = this,
                transPromise = (returnPromise || transitionFix) &amp;&amp; getClassTransPromise(instance, TOGGLE, className, forceState),
                returnValue = returnPromise ? transPromise : instance;
            transPromise || instance.getClassList().toggle(className, forceState);
            if (silent &amp;&amp; DOCUMENT.suppressMutationEvents) {
                if (returnValue===instance) {
                    DOCUMENT.suppressMutationEvents(false);
                }
                else {
                    returnValue.finally(function() {
                        DOCUMENT.suppressMutationEvents(false);
                    });
                }
            }
            return returnValue;
        };

        Object.defineProperties(ElementPrototype, {

           /**
            * Gets or set the height of the element in pixels. Included are padding and border, not any margins.
            * By setting the argument &#x60;overflow&#x60; you get the total height, included the invisible overflow.
            *
            * The getter is calculating through &#x60;offsetHeight&#x60;, the setter will set inline css-style for the height.
            *
            * Values are numbers without unity.
            *
            * @property height
            * @type {Number}
            * @since 0.0.1
            */
            height: {
                get: function() {
                    return this.offsetHeight;
                },
                set: function(val) {
                    var instance = this,
                        dif;
                    instance.setClass(INVISIBLE);
                    instance.setInlineStyle(HEIGHT, val + PX);
                    dif = (instance.offsetHeight-val);
                    (dif!==0) &amp;&amp; (instance.setInlineStyle(HEIGHT, (val - dif) + PX));
                    instance.removeClass(INVISIBLE);
                }
            },

           /**
            * Gets the x-position (in the DOCUMENT) of the element in pixels.
            * DOCUMENT-related: regardless of the window&#x27;s scroll-position.
            *
            * @property left
            * @since 0.0.1
            */
            left: {
                get: function() {
                    return Math.round(this.getBoundingClientRect().left + window.getScrollLeft());
                },
                set: function(pixelsLeft) {
                    return this.setXY(pixelsLeft, null, null, true);
                }
            },

           /**
            * Gets the y-position (in the DOCUMENT) of the element in pixels.
            * DOCUMENT-related: regardless of the window&#x27;s scroll-position.
            *
            * @property top
            * @since 0.0.1
            */
            top: {
                get: function() {
                    return Math.round(this.getBoundingClientRect().top + window.getScrollTop());
                },
                set: function(pixelsTop) {
                    return this.setXY(null, pixelsTop, null, true);
                }
            },

           /**
            * Gets or set the width of the element in pixels. Included are padding and border, not any margins.
            * By setting the argument &#x60;overflow&#x60; you get the total width, included the invisible overflow.
            *
            * The getter is calculating through &#x60;offsetHeight&#x60;, the setter will set inline css-style for the width.
            *
            * Values are numbers without unity.
            *
            * @property width
            * @type {Number}
            * @since 0.0.1
            */
            width: {
                get: function() {
                    return this.offsetWidth;
                },
                set: function(val) {
                    var instance = this,
                        dif;
                    instance.setClass(INVISIBLE);
                    instance.setInlineStyle(WIDTH, val + PX);
                    dif = (instance.offsetWidth-val);
                    (dif!==0) &amp;&amp; (instance.setInlineStyle(WIDTH, (val - dif) + PX));
                    instance.removeClass(INVISIBLE);
                }
            }

        });

    }(window.Element.prototype));

    setupObserver = function() {
        // configuration of the observer:
        var observerConfig = {
                attributes: true,
                subtree: true,
                characterData: true,
                childList : true
            };
        (new window.MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {

                var node = mutation.target,
                    vnode = node.vnode,
                    type = mutation.type,
                    attribute = mutation.attributeName,
                    addedChildNodes = mutation.addedNodes,
                    removedChildNodes = mutation.removedNodes,
                    i, len, childDomNode, childVNode, index, vchildnode;
                if (vnode &amp;&amp; !vnode._nosync) {
                    if (type===&#x27;attributes&#x27;) {
                        vnode.reloadAttr(attribute);
                    }
                    else if (type===&#x27;characterData&#x27;) {
                        vnode.text = node.nodeValue;
                    }
                    else {
                        // remove the childNodes that are no longer there:
                        len = removedChildNodes.length;
                        for (i=len-1; i&gt;=0; i--) {
                            childVNode = removedChildNodes[i].vnode;
                            childVNode &amp;&amp; childVNode._destroy();
                        }
                       // add the new childNodes:
                        len = addedChildNodes.length;
                        for (i=0; i&lt;len; i++) {
                            childDomNode = addedChildNodes[i];
                            // find its index in the true DOM:
                            index = node.childNodes.indexOf(childDomNode);
                            // create the vnode:
                            vchildnode = domNodeToVNode(childDomNode);
//======================================================================================================
// TODO: remove this block of code: we shouldn;t be needing it
// that is: when the alert never rises (which I expect it doesn&#x27;t)


// prevent double definitions (for whatever reason):
// check if there is a vChild with the same domNode and remove it:
var vChildNodes = vnode.vChildNodes;
var len2 = vChildNodes ? vChildNodes.length : 0;
var j;
for (j=0; j&lt;len2; j++) {
    var checkChildVNode = vChildNodes[j];
    if (checkChildVNode.domNode===node) {
        checkChildVNode._destroy();
        alert(&#x27;double deleted&#x27;);
        break;
    }
}
// END OF removable block
//======================================================================================================
                            // add the vnode:
                            vchildnode._moveToParent(vnode, index);
                        }
                    }
                }
            });
        })).observe(DOCUMENT, observerConfig);
    };

    setupObserver();

};

//--- definition API of unmodified &#x60;Element&#x60;-methods ------

/**
 * Returns the specified attribute of the specified element, as an Attr node.
 *
 * @method getAttributeNode
 * @return {attributeNode}
 */

/**
 * Returns a text rectangle object that encloses a group of text rectangles. The returned value is
 * a TextRectangle object which is the union of the rectangles returned by getClientRects() for the element,
 * i.e., the CSS border-boxes associated with the element.
 *
 * The returned value is a TextRectangle object, which contains read-only left, top, right and bottom properties
 * describing the border-box in pixels. top and left are relative to the top-left of the viewport.
 *
 * @method getBoundingClientRect
 * @return {attributeNode} Therectangle object that encloses a group of text rectangles.
 */

/**
 * Returns a collection of rectangles that indicate the bounding rectangles for each box in a client.
 *
 * The returned value is a collection of ClientRect objects, one for each CSS border box associated with the element.
 * Each ClientRect object contains read-only left, top, right and bottom properties describing the border box, in pixels,
 * with the top-left relative to the top-left of the viewport. For tables with captions,
 * the caption is included even though it&#x27;s outside the border box of the table.
 *
 * @method getClientRects
 * @return {Collection}
 */

/**
 * Returns a new NodeIterator object with this Element as root.
 *
 * The NodeIterator is a snapshot of the dom at the time this method was called. It is not updated when changes of the dom are made afterwards.
 *
 * @method createNodeIterator
 * @param [whatToShow] {Number} Filter specification constants from the NodeFilter DOM interface, indicating which nodes to iterate over.
 * You can use or sum one of the next properties:
 * &lt;ul&gt;
 *   &lt;li&gt;window.NodeFilter.SHOW_ELEMENT&lt;/li&gt;
 *   &lt;li&gt;window.NodeFilter.SHOW_COMMENT&lt;/li&gt;
 *   &lt;li&gt;window.NodeFilter.SHOW_TEXT&lt;/li&gt;
 * &lt;/ul&gt;
 * @param [filter] {NodeFilter|function} An object implementing the NodeFilter interface or a function. See https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter
 * @return {NodeIterator}
 * @since 0.0.1
*/

/**
 * Returns an HTMLCollection of all Elements within this Element, that match their classes with the supplied &#x60;classNames&#x60; argument.
 * To match multiple different classes, separate them with a &#x60;comma&#x60;.
 *
 * getElementsByClassName is life presentation of the dom. The returned HTMLCollection gets updated when the dom changes.
 *
 * NOTE: it is highly recomended to use &#x60;document.getAll&#x60; because that method takes advantage of the vdom.
 *
 * @method getElementsByClassName
 * @param classNames {String} the classes to search for
 * @return {HTMLCollection} life Array with Elements
 */

/**
 * Returns an HTMLCollection of all Elements within this Element, that match their &#x60;name&#x60;-attribute with the supplied &#x60;name&#x60; argument.
 *
 * getElementsByName is life presentation of the dom. The returned HTMLCollection gets updated when the dom changes.
 *
 * NOTE: it is highly recomended to use &#x60;document.getAll&#x60; because that method takes advantage of the vdom.
 *
 * @method getElementsByName
 * @param name {String} the property of name-attribute to search for
 * @return {HTMLCollection} life Array with Elements
 */


/**
 * Returns an HTMLCollection of all Elements within this Element, that match their &#x60;name&#x60;-attribute with the supplied &#x60;name&#x60; argument.
 *
 * getElementsByTagName is life presentation of the dom. The returned HTMLCollection gets updated when the dom changes.
 *
 * NOTE: it is highly recomended to use &#x60;document.getAll&#x60; because that method takes advantage of the vdom.
 *
 * @method getElementsByTagName
 * @param tagNames {String} the tags to search for
 * @return {HTMLCollection} life Array with Elements
 */

/**
* Inserts the Element into the DOM tree at a specified position.
*
* @method insertAdjacentElement
* @param position {String}
* &lt;ul&gt;
*     &lt;li&gt;&#x27;beforebegin&#x27; Before the element itself&lt;/li&gt;
*     &lt;li&gt;&#x27;afterbegin&#x27; Just inside the element, before its first child&lt;/li&gt;
*     &lt;li&gt;&#x27;beforeend&#x27; Just inside the element, after its last child&lt;/li&gt;
*     &lt;li&gt;&#x27;afterend&#x27; After the element itself&lt;/li&gt;
* &lt;ul&gt;
* @param element {Element}
*/

/**
* Parses the specified text as HTML and inserts the resulting nodes into the DOM tree at a specified position.
*
* @method insertAdjacentHTML
* @param position {String}
* &lt;ul&gt;
*     &lt;li&gt;&#x27;beforebegin&#x27; Before the element itself&lt;/li&gt;
*     &lt;li&gt;&#x27;afterbegin&#x27; Just inside the element, before its first child&lt;/li&gt;
*     &lt;li&gt;&#x27;beforeend&#x27; Just inside the element, after its last child&lt;/li&gt;
*     &lt;li&gt;&#x27;afterend&#x27; After the element itself&lt;/li&gt;
* &lt;ul&gt;
* @param element {Element}
*/

/**
* Inserts the text into the DOM tree as a TextNode at a specified position.
*
* @method insertAdjacentText
* @param position {String}
* &lt;ul&gt;
*     &lt;li&gt;&#x27;beforebegin&#x27; Before the element itself&lt;/li&gt;
*     &lt;li&gt;&#x27;afterbegin&#x27; Just inside the element, before its first child&lt;/li&gt;
*     &lt;li&gt;&#x27;beforeend&#x27; Just inside the element, after its last child&lt;/li&gt;
*     &lt;li&gt;&#x27;afterend&#x27; After the element itself&lt;/li&gt;
* &lt;ul&gt;
* @param element {Element}
*/

/**
* Removes the attribute specified by an attributeNode from the Element.
*
* @method removeAttributeNode
* @param attributeNode {attributeNode}
* @since 0.0.1
*/

/**
 * Scrolls the element into view.
 *
 * @method scrollIntoView
 */

/**
 * Sets the attribute on the Element specified by &#x60;attributeNode&#x60;
 *
 * @method setAttributeNode
 * @param attributeNode {attributeNode}
*/

//------ events --------

/**
 * Fired when a static &#x60;script&#x60; element  finishes executing its script. Does not fire if the element is added dynamically, eg with appendChild().
 *
 * @event afterscriptexecute
 */


/**
 * Fired when the code in a &#x60;script&#x60; element declared in an HTML document is about to start executing. Does not fire if the element is added dynamically, eg with appendChild().
 *
 * @event beforescriptexecute
 */

//------- properties --------

/**
 * sets or returns an accesskey for an element. An accesskey specifies a shortcut key to activate/focus an element.
 * Note: The way of accessing the shortcut key is varying in different browsers: http://www.w3schools.com/jsref/prop_html_accesskey.asp
 *
 * @property accessKey
 * @type String
 */


/**
 * Returns a live collection of all attribute nodes registered to the specified node.
 * It is a NamedNodeMap, not an Array, so it has no Array methods and the Attr nodes&#x27; indexes may differ among browsers.
 * To be more specific, attributes is a key/value pair of strings that represents any information regarding that attribute.
 *
 * Prefer to use &#x60;getAttrs()&#x60; which is much quicker, but doesn&#x27;t return a life-list.
 *
 * @property attributes
 * @type NamedNodeMap
 */

/**
 * The absolute base URL of a node.
 *
 * @property baseURI
 * @type String
 * @readOnly
 */

/**
 * Returns the number of children (child Elements)
 *
 * @property childElementCount
 * @type Number
 * @readOnly
 */

/**
 * Returns a live collection of childNodes of the given element, either Element, TextNode or CommentNode
 *
 * @property childNodes
 * @type NodeList
 * @readOnly
 */

/**
 * Returns a live collection of child Element&#x27;s of the given element.
 *
 * @property children
 * @type NodeList
 * @readOnly
 */

/**
 * Gets and sets the value of the class attribute of the specified element.
 *
 * @property className
 * @type String
 */

/**
 * Returns the inner height of an element in pixels, including padding but not the horizontal scrollbar height, border, or margin.
 *
 * @property clientHeight
 * @type Number
 * @readOnly
 */

/**
 * The width of the left border of an element in pixels. It includes the width of the vertical scrollbar if the text direction of the element is righttoleft
 * and if there is an overflow causing a left vertical scrollbar to be rendered. clientLeft does not include the left margin or the left padding.
 *
 * @property clientLeft
 * @type Number
 * @readOnly
 */

/**
 * The width of the top border of an element in pixels. It does not include the top margin or padding.
 *
 * @property clientTop
 * @type Number
 * @readOnly
 */

/**
 * Returns the inner width of an element in pixels, including padding but not the vertical scrollbar height, border, or margin.
 *
 * @property clientWidth
 * @type Number
 * @readOnly
 */

/**
 * Reference to the first childNode, where the related dom-node is either an Element, TextNode or CommentNode (nodeType===1, 3 or 8).
 *
 * Better work with Elements only:  use &#x60;firstElementChild&#x60; instead, which returns the first Element-child.
 *
 * @property firstChild
 * @type Node
 * @readOnly
 * @deprecated
 */

/**
 * Reference to the first Element-child, which is an Element (nodeType===1).
 *
 * @property firstElementChild
 * @type Element
 * @readOnly
 */

/**
 * Gets or sets the element&#x27;s attribute &#x60;href&#x60;. Only applies for the &#x60;a&#x60;-element.
 *
 * @property href
 * @type String
 */

/**
 * Gets or sets the element&#x27;s identifier (attribute id).
 *
 * @property id
 * @type String
 */

/**
 * Reference to the last childNode, where the related dom-node is either an Element, TextNode or CommentNode (nodeType===1, 3 or 8).
 *
 * Better use &#x60;lastElementChild&#x60; instead, which returns the last Element-child.
 *
 * @property lastChild
 * @type Node
 * @readOnly
 * @deprecated
 */

/**
 * Reference to the last Element-child, where the related dom-node is an Element (nodeType===1).
 *
 * @property lastElementChild
 * @type Element
 * @readOnly
 */

/**
 * Gets or sets the &#x60;name&#x60; property of a Element; it only applies to the following elements:
 * &#x60;a&#x60;, &#x60;applet&#x60;, &#x60;button&#x60;, &#x60;form&#x60;, &#x60;frame&#x60;, &#x60;iframe&#x60;, &#x60;img&#x60;, &#x60;input&#x60;, &#x60;map&#x60;, &#x60;meta&#x60;, &#x60;object&#x60;, &#x60;param&#x60;, &#x60;select&#x60;, and &#x60;textarea&#x60;.
 *
 * @property name
 * @type String
 */

/**
 * Returns the Element immediately following the specified one in its parent&#x27;s childNodes list, or null if the specified node is the last node in that list.
 * Is an Element (nodeType===1).
 *
 * @property nextElementSibling
 * @type Element
 * @readOnly
 */

/**
 * Returns the Element immediately following the specified one in its parent&#x27;s childNodes list, or null if the specified node is the last node in that list.
 * Is either an Element, TextNode or CommentNode (nodeType===1, 3 or 8).
 *
 * Do not use this, but use &#x60;lastElementChild&#x60; instead, which returns the next Element-child.
 *
 * @property nextElementSibling
 * @type Node
 * @deprecated
 * @readOnly
 */

/**
 * Elements tag-name
 *
 * @property nodeName
 * @type String
 * @readOnly
 */

/**
 * Elements nodetype: 1==Element, 3==TextNode, 8===CommentNode
 *
 * @property nodeType
 * @type String
 * @readOnly
 */

/**
 * Value/text for non-Element Nodes
 *
 * @property nodeValue
 * @type String
 * @since 0.0.1
 */

/**
 * The exact width of the Element on the screen.
 * Included borders and padding (no margin).
 *
 * Returns a number without unity.
 *
 * Better use &#x60;width&#x60; --&gt; it&#x27;s an alias, but has a setter as well
 *
 * @property offsetWidth
 * @type Number
 * @readOnly
 * @since 0.0.1
 */

/**
 * The exact height of the Element on the screen.
 * Included borders and padding (no margin).
 *
 * Returns a number without unity.
 *
 * Better use &#x60;height&#x60; --&gt; it&#x27;s an alias, but has a setter as well
 *
 * @property offsetHeight
 * @type Number
 * @since 0.0.1
 */

/**
 * Returns the Element&#x27;s parent Element.
 *
 * Same as &#x60;parentNode&#x60;
 *
 * @property parentElement
 * @type Element
 */

/**
 * Returns the Element&#x27;s parent Element.
 *
 * Same as &#x60;parentElement&#x60;
 *
 * @property parentNode
 * @type Element
 */

/**
 * Returns the Element immediately preceding the specified one in its parent&#x27;s childNodes list, or null if the specified node is the last node in that list.
 * Is an Element (nodeType===1).
 *
 * @property previousElementSibling
 * @type Element
 * @readOnly
 */

/**
 * Returns the Element immediately preceding the specified one in its parent&#x27;s childNodes list, or null if the specified node is the last node in that list.
 * Is either an Element, TextNode or CommentNode (nodeType===1, 3 or 8).
 *
 * Do not use this, but use &#x60;previousElementSibling&#x60; instead, which returns the previous Element-child.
 *
 * @property previousSibling
 * @deprecated
 * @type Node
 * @readOnly
 */


/**
 * A measurement of the height of an element&#x27;s content, including content not visible on the screen due to overflow.
 * The scrollHeight value is equal to the minimum clientHeight the element would require in order to fit all the content in the viewpoint
 * without using a vertical scrollbar. It includes the element padding but not its margin.
 *
 * Returns a number without unity.
 *
 * @property scrollHeight
 * @type Number
 * @readOnly
 */

/**
 * Gets or sets the number of pixels that an element&#x27;s content is scrolled to the left.
 *
 * @property scrollLeft
 * @type Number
 */

/**
 * Gets or sets the number of pixels that the content of an element is scrolled upward. An element&#x27;s scrollTop is a measurement
 * of the distance of an element&#x27;s top to its topmost visible content. When an element content does not generate a vertical scrollbar,
 * then its scrollTop value defaults to 0.
 *
 * @property scrollTop
 * @type Number
 */

/**
 * Returns either the width in pixels of the content of an element or the width of the element itself, whichever is greater.
 * If the element is wider than its content area (for example, if there are scroll bars for scrolling through the content),
 * the scrollWidth is larger than the clientWidth.
 *
 * Returns a number without unity.
 *
 * @property scrollWidth
 * @type Number
 * @readOnly
 */

/**
 * Gets or sets the element&#x27;s attribute &#x60;type&#x60;. Only applies for the &#x60;script&#x60;, &#x60;img&#x60; and &#x60;style&#x60;-elements.
 *
 * @property src
 * @type String
 */

/**
 * Gets or sets the element&#x27;s attribute &#x60;style&#x60;.
 *
 * @property style
 * @type String
 */

/**
 * Gets or sets the element&#x27;s attribute &#x60;type&#x60;. Only applies for the &#x60;input&#x60;-element.
 *
 * @property type
 * @type String
 */

/**
* Gets or sets the value of an input or select Element.
*
* Note it is highly preferable to use getValue() and setValue().
*
* @property value
* @type String
* @since 0.0.1
*/
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
