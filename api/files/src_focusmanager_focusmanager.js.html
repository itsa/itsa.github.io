<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/focusmanager/focusmanager.js - Itsa</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Itsa"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/DD.html">DD</a></li>
            
                <li><a href="../classes/document.html">document</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/FocusManager.html">FocusManager</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/NS-vdom.html">NS-vdom</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Plugins.html">Plugins</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/String.html">String</a></li>
            
                <li><a href="../classes/USERAGENT.html">USERAGENT</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vnode.html">vnode</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/attribute-extractor.html">attribute-extractor</a></li>
            
                <li><a href="../modules/drag.html">drag</a></li>
            
                <li><a href="../modules/drag-drop.html">drag-drop</a></li>
            
                <li><a href="../modules/element-array.html">element-array</a></li>
            
                <li><a href="../modules/element-plugin.html">element-plugin</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-hover.html">event-hover</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/event-mobile.html">event-mobile</a></li>
            
                <li><a href="../modules/extend-document.html">extend-document</a></li>
            
                <li><a href="../modules/extend-element.html">extend-element</a></li>
            
                <li><a href="../modules/focusmanager.html">focusmanager</a></li>
            
                <li><a href="../modules/html-parser.html">html-parser</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/itsa.build.html">itsa.build</a></li>
            
                <li><a href="../modules/js-ext.html">js-ext</a></li>
            
                <li><a href="../modules/lib_array.js.html">lib/array.js</a></li>
            
                <li><a href="../modules/lib_function.js.html">lib/function.js</a></li>
            
                <li><a href="../modules/lib_object.js.html">lib/object.js</a></li>
            
                <li><a href="../modules/lib_promise.s.html">lib/promise.s</a></li>
            
                <li><a href="../modules/lib_string.js.html">lib/string.js</a></li>
            
                <li><a href="../modules/node-parser.html">node-parser</a></li>
            
                <li><a href="../modules/node-win.html">node-win</a></li>
            
                <li><a href="../modules/useragent.html">useragent</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/vdom.html">vdom</a></li>
            
                <li><a href="../modules/vdom-ns.html">vdom-ns</a></li>
            
                <li><a href="../modules/vnode.html">vnode</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/focusmanager/focusmanager.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;

require(&#x27;js-ext/lib/object.js&#x27;);
require(&#x27;polyfill&#x27;);

/**
 *
 *
 *
 * &lt;i&gt;Copyright (c) 2014 ITSA - https://github.com/itsa&lt;/i&gt;
 * New BSD License - http://choosealicense.com/licenses/bsd-3-clause/
 *
 * @module focusmanager
 * @class FocusManager
 * @since 0.0.1
*/

var NAME = &#x27;[focusmanager]: &#x27;,
    async = require(&#x27;utils&#x27;).async,
    DEFAULT_SELECTOR = &#x27;input, button, select, textarea, .focusable&#x27;,
    SPECIAL_KEYS = {
        shift: &#x27;shiftKey&#x27;,
        ctrl: &#x27;ctrlKey&#x27;,
        cmd: &#x27;metaKey&#x27;,
        alt: &#x27;altKey&#x27;
    },
    DEFAULT_KEYUP = &#x27;shift+9&#x27;,
    DEFAULT_KEYDOWN = &#x27;9&#x27;,
    FM_SELECTION = &#x27;fm-selection&#x27;,
    FM_SELECTION_START = FM_SELECTION+&#x27;start&#x27;,
    FM_SELECTION_END = FM_SELECTION+&#x27;end&#x27;,
    FOCUSSED = &#x27;focussed&#x27;;

module.exports = function (window) {

    var DOCUMENT = window.document,
        nodePlugin, FocusManager, Event, nextFocusNode, searchFocusNode, markAsFocussed, getFocusManagerSelector, setupEvents;

    window._ITSAmodules || Object.protectedProp(window, &#x27;_ITSAmodules&#x27;, {});

/*jshint boss:true */
    if (FocusManager=window._ITSAmodules.FocusManager) {
/*jshint boss:false */
        return FocusManager; // FocusManager was already created
    }

    nodePlugin = require(&#x27;vdom&#x27;)(window).Plugins.nodePlugin;
    Event = require(&#x27;event-dom&#x27;)(window);

    getFocusManagerSelector = function(focusContainerNode) {
        var selector = focusContainerNode.getAttr(&#x27;fm-manage&#x27;);
        (selector.toLowerCase()===&#x27;true&#x27;) &amp;&amp; (selector=DEFAULT_SELECTOR);
        return selector;
    };

    nextFocusNode = function(e, keyCode, actionkey, focusContainerNode, sourceNode, selector, downwards) {
        console.log(NAME+&#x27;nextFocusNode&#x27;);
        var keys, lastIndex, i, specialKeysMatch, specialKey, len, enterPressedOnInput, primaryButtons,
            inputType, foundNode, formNode, primaryonenter, noloop;
        keys = actionkey.split(&#x27;+&#x27;);
        len = keys.length;
        lastIndex = len - 1;

        if ((keyCode===13) &amp;&amp; (sourceNode.getTagName()===&#x27;INPUT&#x27;)) {
            inputType = sourceNode.getAttr(&#x27;type&#x27;).toLowerCase();
            enterPressedOnInput = (inputType===&#x27;text&#x27;) || (inputType===&#x27;password&#x27;);
        }

        if (enterPressedOnInput) {
            // check if we need to press the primary button - if available
/*jshint boss:true */
            if ((primaryonenter=sourceNode.getAttr(&#x27;fm-primaryonenter&#x27;)) &amp;&amp; (primaryonenter.toLowerCase()===&#x27;true&#x27;)) {
/*jshint boss:false */
                primaryButtons = focusContainerNode.getAll(&#x27;button.pure-button-primary&#x27;);
                primaryButtons.some(function(buttonNode) {
                    buttonNode.matches(selector) &amp;&amp; (foundNode=buttonNode);
                    return foundNode;
                });
                if (foundNode) {
                    async(function() {
                        Event.emit(foundNode, &#x27;UI:click&#x27;);
                        // _buttonPressed make event-dom to simulate a pressed button for 200ms
                        Event.emit(foundNode, &#x27;UI:tap&#x27;, {_buttonPressed: true});
                        // if the button is of type &#x60;submit&#x60;, then try to submit the form
                        formNode = foundNode.inside(&#x27;form&#x27;);
                        formNode &amp;&amp; formNode.submit();
                    });
                    return foundNode;
                }
            }
        }
        // double == --&gt; keyCode is number, keys is a string
        if (enterPressedOnInput || (keyCode==keys[lastIndex])) {
            // posible keyup --&gt; check if special characters match:
            specialKeysMatch = true;
            SPECIAL_KEYS.some(function(value) {
                specialKeysMatch = !e[value];
                return !specialKeysMatch;
            });
            for (i=lastIndex-1; (i&gt;=0) &amp;&amp; !specialKeysMatch; i--) {
                specialKey = keys[i].toLowerCase();
                specialKeysMatch = e[SPECIAL_KEYS[specialKey]];
            }
        }
        if (specialKeysMatch) {
            noloop = focusContainerNode.getAttr(&#x27;fm-noloop&#x27;);
            noloop = noloop &amp;&amp; (noloop.toLowerCase()===&#x27;true&#x27;);
            if (downwards) {
                return sourceNode.next(selector) || (noloop ? sourceNode.last(selector) : sourceNode.first(selector));
            }
            else {
                return sourceNode.previous(selector) || (noloop ? sourceNode.first(selector) : sourceNode.last(selector));
            }
        }
        return false;
    };

    markAsFocussed = function(focusContainerNode, node) {
        console.log(NAME+&#x27;markAsFocussed&#x27;);
        var selector = getFocusManagerSelector(focusContainerNode),
            index = focusContainerNode.getAll(selector).indexOf(node) || 0;
        // we also need to set the appropriate nodeData, so that when the itags re-render,
        // they don&#x27;t reset this particular information
        focusContainerNode.getAll(&#x27;[fm-lastitem]&#x27;)
                          .removeAttrs([&#x27;fm-lastitem&#x27;, &#x27;tabindex&#x27;], true)
                          .removeData(&#x27;fm-tabindex&#x27;);

        // also store the lastitem&#x27;s index --&gt; in case the node gets removed,
        // or re-rendering itags which don&#x27;t have the attribute-data.
        // otherwise, a refocus on the container will set the focus to the nearest item
        focusContainerNode.setData(&#x27;fm-lastitem-bkp&#x27;, index);
        node.setData(&#x27;fm-tabindex&#x27;, true);

        node.setAttrs([
            {name: &#x27;tabindex&#x27;, value: &#x27;0&#x27;},
            {name: &#x27;fm-lastitem&#x27;, value: true}
        ]);
    };

    searchFocusNode = function(initialNode) {
        console.log(NAME+&#x27;searchFocusNode&#x27;);
        var focusContainerNode = initialNode.hasAttr(&#x27;fm-manage&#x27;) ? initialNode : initialNode.inside(&#x27;[fm-manage]&#x27;),
            focusNode, alwaysDefault, fmAlwaysDefault, selector, allFocusableNodes, index;

        if (focusContainerNode) {
            if (initialNode.matches(getFocusManagerSelector(focusContainerNode))) {
                markAsFocussed(focusContainerNode, initialNode);
                focusNode = initialNode;
            }
            else {
                // find the right node that should get focus
/*jshint boss:true */
                alwaysDefault = ((fmAlwaysDefault=focusContainerNode.getAttr(&#x27;fm-alwaysdefault&#x27;)) &amp;&amp; (fmAlwaysDefault.toLowerCase()===&#x27;true&#x27;));
/*jshint boss:false */
                alwaysDefault &amp;&amp; (focusNode=focusContainerNode.getElement(&#x27;[fm-defaultitem=&quot;true&quot;]&#x27;));
                if (!focusNode) {
                    // search for last item
                    focusNode = focusContainerNode.getElement(&#x27;[fm-lastitem=&quot;true&quot;]&#x27;);
                    if (!focusNode) {
                        // set &#x60;selector&#x60; right now: we might use it later on even when index is undefined
                        selector = getFocusManagerSelector(focusContainerNode);
                        // look at the lastitemindex of the focuscontainer
                        index = focusContainerNode.getData(&#x27;fm-lastitem-bkp&#x27;);
                        if (index!==undefined) {
                            allFocusableNodes = focusContainerNode.getAll(selector);
                            focusNode = allFocusableNodes[index];
                        }
                    }
                }
                // still not found and alwaysDefault was falsy: try the defualt node:
                !focusNode &amp;&amp; !alwaysDefault &amp;&amp; (focusNode=focusContainerNode.getElement(&#x27;[fm-defaultitem=&quot;true&quot;]&#x27;));
                // still not found: try the first focussable node (which we might find inside &#x60;allFocusableNodes&#x60;:
                !focusNode &amp;&amp; (focusNode = allFocusableNodes ? allFocusableNodes[0] : focusContainerNode.getElement(selector));
                if (focusNode) {
                    markAsFocussed(focusContainerNode, focusNode);
                }
                else {
                    focusNode = initialNode;
                }
            }
        }
        else {
            focusNode = initialNode;
        }
        return focusNode;
    };

    setupEvents = function() {

        Event.before(&#x27;keydown&#x27;, function(e) {
            console.log(NAME+&#x27;before keydown-event&#x27;);
            var focusContainerNode,
                sourceNode = e.target,
                node = sourceNode.getParent(),
                selector, keyCode, actionkey, focusNode;

            focusContainerNode = sourceNode.inside(&#x27;[fm-manage]&#x27;);
            if (focusContainerNode) {
                // key was pressed inside a focusmanagable container
                selector = getFocusManagerSelector(focusContainerNode);
                keyCode = e.keyCode;

                // first check for keydown:
                actionkey = node.getAttr(&#x27;fm-keydown&#x27;) || DEFAULT_KEYDOWN;
                focusNode = nextFocusNode(e, keyCode, actionkey, focusContainerNode, sourceNode, selector, true);
                if (!focusNode) {
                    // check for keyup:
                    actionkey = node.getAttr(&#x27;fm-keyup&#x27;) || DEFAULT_KEYUP;
                    focusNode = nextFocusNode(e, keyCode, actionkey, focusContainerNode, sourceNode, selector);
                }
                if (focusNode) {
                    e.preventDefaultContinue();
                    // prevent default action --&gt; we just want to re-focus, but we DO want afterlisteners
                    // to be handled in the after-listener: someone else might want to halt the keydown event.
                    sourceNode.matches(selector) &amp;&amp; (e._focusNode=focusNode);
                }
            }
        });

        Event.after(&#x27;keydown&#x27;, function(e) {
            console.log(NAME+&#x27;after keydown-event&#x27;);
            var focusNode = e._focusNode;
            focusNode &amp;&amp; focusNode.focus &amp;&amp; focusNode.focus();
        });

        Event.after(&#x27;blur&#x27;, function(e) {
            console.log(NAME+&#x27;after blur-event&#x27;);
            var node = e.target,
                body = DOCUMENT.body;
            if (node &amp;&amp; node.removeAttr) {
                do {
                    // we also need to set the appropriate nodeData, so that when the itags re-render,
                    // they don&#x27;t reset this particular information
                    node.removeData(FOCUSSED);
                    node.removeClass(FOCUSSED, null, null, true);
                    node = (node===body) ? null : node.getParent();
                } while (node);
            }
        });

        Event.after(&#x27;focus&#x27;, function(e) {
            console.log(NAME+&#x27;after focus-event&#x27;);
            var node = e.target,
                body = DOCUMENT.body;
            if (node &amp;&amp; node.setClass) {
                do {
                    // we also need to set the appropriate nodeData, so that when the itags re-render,
                    // they don&#x27;t reset this particular information
                    node.setData(FOCUSSED, true);
                    node.setClass(FOCUSSED, null, null, true);
                    node = (node===body) ? null : node.getParent();
                } while (node);
            }
        });

        // focus-fix for keeping focus when a mouse gets down for a longer time
        Event.after([&#x27;mousedown&#x27;, &#x27;press&#x27;], function(e) {
            console.log(NAME+&#x27;after focus-event&#x27;);
            var node = e.target;
            node.hasFocus() || node.focus();
        }, &#x27;button&#x27;);

        Event.after(&#x27;tap&#x27;, function(e) {
            console.log(NAME+&#x27;after tap-event&#x27;);
            var focusNode = e.target,
                focusContainerNode;

            if (focusNode &amp;&amp; focusNode.inside) {
                focusContainerNode = focusNode.hasAttr(&#x27;fm-manage&#x27;) ? focusNode : focusNode.inside(&#x27;[fm-manage]&#x27;);
            }
            if (focusContainerNode) {
                if ((focusNode===focusContainerNode) || !focusNode.matches(getFocusManagerSelector(focusContainerNode))) {
                    focusNode = searchFocusNode(focusNode);
                }
                if (focusNode.hasFocus()) {
                    markAsFocussed(focusContainerNode, focusNode);
                }
                else {
                    focusNode.focus();
                }
            }
        });

        Event.after([&#x27;keypress&#x27;, &#x27;mouseup&#x27;, &#x27;panup&#x27;, &#x27;mousedown&#x27;, &#x27;pandown&#x27;], function(e) {
            console.log(NAME+&#x27;after &#x27;+e.type+&#x27;-event&#x27;);
            var focusContainerNode,
                sourceNode = e.target,
                selector;

            focusContainerNode = sourceNode.inside(&#x27;[fm-manage]&#x27;);
            if (focusContainerNode) {
                // key was pressed inside a focusmanagable container
                selector = getFocusManagerSelector(focusContainerNode);
                if (sourceNode.matches(selector)) {
                    sourceNode.setAttr(FM_SELECTION_START, sourceNode.selectionStart || &#x27;0&#x27;)
                              .setAttr(FM_SELECTION_END, sourceNode.selectionEnd || &#x27;0&#x27;);
                }
            }
        }, &#x27;input[type=&quot;text&quot;], textarea&#x27;);

        Event.after(&#x27;focus&#x27;, function(e) {
            console.log(NAME+&#x27;after focus-event&#x27;);
            var focusContainerNode,
                sourceNode = e.target,
                selector, selectionStart, selectionEnd;

            focusContainerNode = sourceNode.inside(&#x27;[fm-manage]&#x27;);
            if (focusContainerNode) {
                // key was pressed inside a focusmanagable container
                selector = getFocusManagerSelector(focusContainerNode);
                if (sourceNode.matches(selector)) {
                    // cautious: fm-selectionstart can be 0 --&gt; which would lead into a falsy value
                    selectionStart = sourceNode.getAttr(FM_SELECTION_START);
                    (selectionStart===undefined) &amp;&amp; (selectionStart=sourceNode.getValue().length);
                    selectionEnd = Math.max(sourceNode.getAttr(FM_SELECTION_END) || selectionStart, selectionStart);
                    sourceNode.selectionEnd = selectionEnd;
                    sourceNode.selectionStart = selectionStart;
                    markAsFocussed(focusContainerNode, sourceNode);
                }
            }
        }, &#x27;input[type=&quot;text&quot;], textarea&#x27;);

    };

    setupEvents();

    window._ITSAmodules.FocusManager = FocusManager = nodePlugin.definePlugin(&#x27;fm&#x27;, {manage: &#x27;true&#x27;});

    /**
     * In case of a manual focus (node.focus()) the node will fire an &#x60;manualfocus&#x60;-event
     * which can be prevented.
     * @event manualfocus
    */
    Event.defineEvent(&#x27;UI:manualfocus&#x27;)
         .defaultFn(function(e) {
             e.target._focus();
         });

    (function(HTMLElementPrototype) {

        HTMLElementPrototype._focus = HTMLElementPrototype.focus;
        HTMLElementPrototype.focus = function() {
            console.log(NAME+&#x27;focus&#x27;);
            searchFocusNode(this).emit(&#x27;manualfocus&#x27;);
        };

    }(window.HTMLElement.prototype));


    return FocusManager;
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
