<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/polyfill/lib/mutationobserver.js - Itsa</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Itsa"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/BaseClass.html">BaseClass</a></li>
            
                <li><a href="../classes/Classes.html">Classes</a></li>
            
                <li><a href="../classes/DD.html">DD</a></li>
            
                <li><a href="../classes/Dialog.html">Dialog</a></li>
            
                <li><a href="../classes/document.html">document</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/FocusManager.html">FocusManager</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/HTMLElement.html">HTMLElement</a></li>
            
                <li><a href="../classes/Icons.html">Icons</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/Math.html">Math</a></li>
            
                <li><a href="../classes/Messages.html">Messages</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/NodePlugin.html">NodePlugin</a></li>
            
                <li><a href="../classes/NS-vdom.html">NS-vdom</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Panel.html">Panel</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/String.html">String</a></li>
            
                <li><a href="../classes/USERAGENT.html">USERAGENT</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vnode.html">vnode</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/attribute-extractor.html">attribute-extractor</a></li>
            
                <li><a href="../modules/dialog.html">dialog</a></li>
            
                <li><a href="../modules/drag.html">drag</a></li>
            
                <li><a href="../modules/drag-drop.html">drag-drop</a></li>
            
                <li><a href="../modules/element-array.html">element-array</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-blurnode.html">event-blurnode</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-focusnode.html">event-focusnode</a></li>
            
                <li><a href="../modules/event-hover.html">event-hover</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/event-mobile.html">event-mobile</a></li>
            
                <li><a href="../modules/extend-document.html">extend-document</a></li>
            
                <li><a href="../modules/extend-element.html">extend-element</a></li>
            
                <li><a href="../modules/extra_classes.js.html">extra/classes.js</a></li>
            
                <li><a href="../modules/focusmanager.html">focusmanager</a></li>
            
                <li><a href="../modules/html-parser.html">html-parser</a></li>
            
                <li><a href="../modules/icons.html">icons</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/itsa.build.html">itsa.build</a></li>
            
                <li><a href="../modules/js-ext.html">js-ext</a></li>
            
                <li><a href="../modules/lib_array.js.html">lib/array.js</a></li>
            
                <li><a href="../modules/lib_function.js.html">lib/function.js</a></li>
            
                <li><a href="../modules/lib_math.js.html">lib/math.js</a></li>
            
                <li><a href="../modules/lib_object.js.html">lib/object.js</a></li>
            
                <li><a href="../modules/lib_promise.s.html">lib/promise.s</a></li>
            
                <li><a href="../modules/lib_string.js.html">lib/string.js</a></li>
            
                <li><a href="../modules/messages.html">messages</a></li>
            
                <li><a href="../modules/node-parser.html">node-parser</a></li>
            
                <li><a href="../modules/node-plugin.html">node-plugin</a></li>
            
                <li><a href="../modules/node-win.html">node-win</a></li>
            
                <li><a href="../modules/panel.html">panel</a></li>
            
                <li><a href="../modules/useragent.html">useragent</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/vdom.html">vdom</a></li>
            
                <li><a href="../modules/vdom-ns.html">vdom-ns</a></li>
            
                <li><a href="../modules/vnode.html">vnode</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/polyfill/lib/mutationobserver.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 * Copyright 2012 The Polymer Authors. All rights reserved.
 * Use of this source code is goverened by a BSD-style
 * license that can be found in the LICENSE file.
 */

(function(global) {
  &quot;use strict&quot;;


    var navigator = global.navigator,
        useragent = navigator &amp;&amp; navigator.userAgent,
        ieTest = useragent &amp;&amp; useragent.match(/MSIE (\d+)\./),
        isIE = !!ieTest,
        ieVersion = isIE &amp;&amp; parseFloat(ieTest[1]),
        ie11 = (ieVersion===11);

    /*!
     * Shim for MutationObserver interface
     * Author: Graeme Yeates (github.com/megawac)
     * Repository: https://github.com/megawac/MutationObserver.js
     * License: WTFPL V2, 2004 (wtfpl.net).
     * Though credit and staring the repo will make me feel pretty, you can modify and redistribute as you please.
     * Attempts to follow spec (http:// www.w3.org/TR/dom/#mutation-observers) as closely as possible for native javascript
     * See https://github.com/WebKit/webkit/blob/master/Source/WebCore/dom/MutationObserver.cpp for current webkit source c++ implementation
     */

    /**
     * prefix bugs:
        - https://bugs.webkit.org/show_bug.cgi?id=85161
        - https://bugzilla.mozilla.org/show_bug.cgi?id=749920
     * Don&#x27;t use WebKitMutationObserver as Safari (6.0.5-6.1) use a buggy implementation
    */

    // We also need the shim for IE11 --&gt; see:
    // https://connect.microsoft.com/IE/feedback/details/817132/ie-11-childnodes-are-missing-from-mutationobserver-mutations-removednodes-after-setting-innerhtml

    if (!global.MutationObserver || ie11) {
        global.MutationObserver = (function() {
            /**
             * @param {function(Array.&lt;MutationRecord&gt;, MutationObserver)} listener
             * @constructor
             */
            function MutationObserver(listener) {
                /**
                 * @type {Array.&lt;Object&gt;}
                 * @private
                 */
                this._watched = [];
                /** @private */
                this._listener = listener;
            }

            /**
             * Start a recursive timeout function to check all items being observed for mutations
             * @type {MutationObserver} observer
             * @private
             */
            function startMutationChecker(observer) {
                (function check() {
                    var mutations = observer.takeRecords();

                    if (mutations.length) { // fire away
                        // calling the listener with context is not spec but currently consistent with FF and WebKit
                        observer._listener(mutations, observer);
                    }
                    /** @private */
                    observer._timeout = setTimeout(check, MutationObserver._period);
                })();
            }

            /**
             * Period to check for mutations (~32 times/sec)
             * @type {number}
             * @expose
             */
            MutationObserver._period = 30 /*ms+runtime*/ ;

            /**
             * Exposed API
             * @expose
             * @final
             */
            MutationObserver.prototype = {
                /**
                 * see http:// dom.spec.whatwg.org/#dom-mutationobserver-observe
                 * not going to throw here but going to follow the current spec config sets
                 * @param {Node|null} $target
                 * @param {Object|null} config : MutationObserverInit configuration dictionary
                 * @expose
                 * @return undefined
                 */
                observe: function($target, config) {
                    /**
                     * Using slightly different names so closure can go ham
                     * @type {!Object} : A custom mutation config
                     */
                    var settings = {
                        attr: !! (config.attributes || config.attributeFilter || config.attributeOldValue),

                        // some browsers are strict in their implementation that config.subtree and childList must be set together. We don&#x27;t care - spec doesn&#x27;t specify
                        kids: !! config.childList,
                        descendents: !! config.subtree,
                        charData: !! (config.characterData || config.characterDataOldValue)
                    };

                    var watched = this._watched;

                    // remove already observed target element from pool
                    for (var i = 0; i &lt; watched.length; i++) {
                        if (watched[i].tar === $target) watched.splice(i, 1);
                    }

                    if (config.attributeFilter) {
                        /**
                         * converts to a {key: true} dict for faster lookup
                         * @type {Object.&lt;String,Boolean&gt;}
                         */
                        settings.afilter = reduce(config.attributeFilter, function(a, b) {
                            a[b] = true;
                            return a;
                        }, {});
                    }

                    watched.push({
                        tar: $target,
                        fn: createMutationSearcher($target, settings)
                    });

                    // reconnect if not connected
                    if (!this._timeout) {
                        startMutationChecker(this);
                    }
                },

                /**
                 * Finds mutations since last check and empties the &quot;record queue&quot; i.e. mutations will only be found once
                 * @expose
                 * @return {Array.&lt;MutationRecord&gt;}
                 */
                takeRecords: function() {
                    var mutations = [];
                    var watched = this._watched;

                    for (var i = 0; i &lt; watched.length; i++) {
                        watched[i].fn(mutations);
                    }

                    return mutations;
                },

                /**
                 * @expose
                 * @return undefined
                 */
                disconnect: function() {
                    this._watched = []; // clear the stuff being observed
                    clearTimeout(this._timeout); // ready for garbage collection
                    /** @private */
                    this._timeout = null;
                }
            };

            /**
             * Simple MutationRecord pseudoclass. No longer exposing as its not fully compliant
             * @param {Object} data
             * @return {Object} a MutationRecord
             */
            function MutationRecord(data) {
                var settings = { // technically these should be on proto so hasOwnProperty will return false for non explicitly props
                    type: null,
                    target: null,
                    addedNodes: [],
                    removedNodes: [],
                    previousSibling: null,
                    nextSibling: null,
                    attributeName: null,
                    attributeNamespace: null,
                    oldValue: null
                };
                for (var prop in data) {
                    if (has(settings, prop) &amp;&amp; data[prop] !== undefined) settings[prop] = data[prop];
                }
                return settings;
            }

            /**
             * Creates a func to find all the mutations
             *
             * @param {Node} $target
             * @param {!Object} config : A custom mutation config
             */
            function createMutationSearcher($target, config) {
                /** type {Elestuct} */
                var $oldstate = clone($target, config); // create the cloned datastructure

                /**
                 * consumes array of mutations we can push to
                 *
                 * @param {Array.&lt;MutationRecord&gt;} mutations
                 */
                return function(mutations) {
                    var olen = mutations.length, dirty;

                    // Alright we check base level changes in attributes... easy
                    if (config.attr &amp;&amp; $oldstate.attr) {
                        findAttributeMutations(mutations, $target, $oldstate.attr, config.afilter);
                    }

                    // check childlist or subtree for mutations
                    if (config.kids || config.descendents) {
                        dirty = searchSubtree(mutations, $target, $oldstate, config);
                    }

                    // reclone data structure if theres changes
                    if (dirty || mutations.length !== olen) {
                        /** type {Elestuct} */
                        $oldstate = clone($target, config);
                    }
                };
            }

            /* attributes + attributeFilter helpers */

            /**
             * fast helper to check to see if attributes object of an element has changed
             * doesnt handle the textnode case
             *
             * @param {Array.&lt;MutationRecord&gt;} mutations
             * @param {Node} $target
             * @param {Object.&lt;string, string&gt;} $oldstate : Custom attribute clone data structure from clone
             * @param {Object} filter
             */
            function findAttributeMutations(mutations, $target, $oldstate, filter) {
                var checked = {};
                var attributes = $target.attributes;
                var attr;
                var name;
                var i = attributes.length;
                while (i--) {
                    attr = attributes[i];
                    name = attr.name;
                    if (!filter || has(filter, name)) {
                        if (attr.value !== $oldstate[name]) {
                            // The pushing is redundant but gzips very nicely
                            mutations.push(new MutationRecord({
                                type: &quot;attributes&quot;,
                                target: $target,
                                attributeName: name,
                                oldValue: $oldstate[name],
                                attributeNamespace: attr.namespaceURI // in ie&lt;8 it incorrectly will return undefined
                            }));
                        }
                        checked[name] = true;
                    }
                }
                for (name in $oldstate) {
                    if (!(checked[name])) {
                        mutations.push(new MutationRecord({
                            target: $target,
                            type: &quot;attributes&quot;,
                            attributeName: name,
                            oldValue: $oldstate[name]
                        }));
                    }
                }
            }

            /**
             * searchSubtree: array of mutations so far, element, element clone, bool
             * synchronous dfs comparision of two nodes
             * This function is applied to any observed element with childList or subtree specified
             * Sorry this is kind of confusing as shit, tried to comment it a bit...
             * codereview.stackexchange.com/questions/38351 discussion of an earlier version of this func
             *
             * @param {Array} mutations
             * @param {Node} $target
             * @param {!Object} $oldstate : A custom cloned node from clone()
             * @param {!Object} config : A custom mutation config
             */
            function searchSubtree(mutations, $target, $oldstate, config) {
                // Track if the tree is dirty and has to be recomputed (#14).
                var dirty;
                /*
                 * Helper to identify node rearrangment and stuff...
                 * There is no gaurentee that the same node will be identified for both added and removed nodes
                 * if the positions have been shuffled.
                 * conflicts array will be emptied by end of operation
                 */
                function resolveConflicts(conflicts, node, $kids, $oldkids, numAddedNodes) {
                    // the distance between the first conflicting node and the last
                    var distance = conflicts.length - 1;
                    // prevents same conflict being resolved twice consider when two nodes switch places.
                    // only one should be given a mutation event (note -~ is used as a math.ceil shorthand)
                    var counter = -~((distance - numAddedNodes) / 2);
                    var $cur;
                    var oldstruct;
                    var conflict;
                    while ((conflict = conflicts.pop())) {
                        $cur = $kids[conflict.i];
                        oldstruct = $oldkids[conflict.j];

                        // attempt to determine if there was node rearrangement... won&#x27;t gaurentee all matches
                        // also handles case where added/removed nodes cause nodes to be identified as conflicts
                        if (config.kids &amp;&amp; counter &amp;&amp; Math.abs(conflict.i - conflict.j) &gt;= distance) {
                            mutations.push(new MutationRecord({
                                type: &quot;childList&quot;,
                                target: node,
                                addedNodes: [$cur],
                                removedNodes: [$cur],
                                // haha don&#x27;t rely on this please
                                nextSibling: $cur.nextSibling,
                                previousSibling: $cur.previousSibling
                            }));
                            counter--; // found conflict
                        }

                        // Alright we found the resorted nodes now check for other types of mutations
                        if (config.attr &amp;&amp; oldstruct.attr) findAttributeMutations(mutations, $cur, oldstruct.attr, config.afilter);
                        if (config.charData &amp;&amp; $cur.nodeType === 3 &amp;&amp; $cur.nodeValue !== oldstruct.charData) {
                            mutations.push(new MutationRecord({
                                type: &quot;characterData&quot;,
                                target: $cur
                            }));
                        }
                        // now look @ subtree
                        if (config.descendents) findMutations($cur, oldstruct);
                    }
                }

                /**
                 * Main worker. Finds and adds mutations if there are any
                 * @param {Node} node
                 * @param {!Object} old : A cloned data structure using internal clone
                 */
                function findMutations(node, old) {
                    var $kids = node.childNodes;
                    var $oldkids = old.kids;
                    var klen = $kids.length;
                    // $oldkids will be undefined for text and comment nodes
                    var olen = $oldkids ? $oldkids.length : 0;
                    // if (!olen &amp;&amp; !klen) return; // both empty; clearly no changes

                    // we delay the intialization of these for marginal performance in the expected case (actually quite signficant on large subtrees when these would be otherwise unused)
                    // map of checked element of ids to prevent registering the same conflict twice
                    var map;
                    // array of potential conflicts (ie nodes that may have been re arranged)
                    var conflicts;
                    var id; // element id from getElementId helper
                    var idx; // index of a moved or inserted element

                    var oldstruct;
                    // current and old nodes
                    var $cur;
                    var $old;
                    // track the number of added nodes so we can resolve conflicts more accurately
                    var numAddedNodes = 0;

                    // iterate over both old and current child nodes at the same time
                    var i = 0, j = 0;
                    // while there is still anything left in $kids or $oldkids (same as i &lt; $kids.length || j &lt; $oldkids.length;)
                    while( i &lt; klen || j &lt; olen ) {
                        // current and old nodes at the indexs
                        $cur = $kids[i];
                        oldstruct = $oldkids[j];
                        $old = oldstruct &amp;&amp; oldstruct.node;

                        if ($cur === $old) { // expected case - optimized for this case
                            // check attributes as specified by config
                            if (config.attr &amp;&amp; oldstruct.attr) /* oldstruct.attr instead of textnode check */findAttributeMutations(mutations, $cur, oldstruct.attr, config.afilter);
                            // check character data if node is a comment or textNode and it&#x27;s being observed
                            if (config.charData &amp;&amp; oldstruct.charData !== undefined &amp;&amp; $cur.nodeValue !== oldstruct.charData) {
                                mutations.push(new MutationRecord({
                                    type: &quot;characterData&quot;,
                                    target: $cur
                                }));
                            }

                            // resolve conflicts; it will be undefined if there are no conflicts - otherwise an array
                            if (conflicts) resolveConflicts(conflicts, node, $kids, $oldkids, numAddedNodes);

                            // recurse on next level of children. Avoids the recursive call when there are no children left to iterate
                            if (config.descendents &amp;&amp; ($cur.childNodes.length || oldstruct.kids &amp;&amp; oldstruct.kids.length)) findMutations($cur, oldstruct);

                            i++;
                            j++;
                        } else { // (uncommon case) lookahead until they are the same again or the end of children
                            dirty = true;
                            if (!map) { // delayed initalization (big perf benefit)
                                map = {};
                                conflicts = [];
                            }
                            if ($cur) {
                                // check id is in the location map otherwise do a indexOf search
                                if (!(map[id = getElementId($cur)])) { // to prevent double checking
                                    // mark id as found
                                    map[id] = true;
                                    // custom indexOf using comparitor checking oldkids[i].node === $cur
                                    if ((idx = indexOfCustomNode($oldkids, $cur, j)) === -1) {
                                        if (config.kids) {
                                            mutations.push(new MutationRecord({
                                                type: &quot;childList&quot;,
                                                target: node,
                                                addedNodes: [$cur], // $cur is a new node
                                                nextSibling: $cur.nextSibling,
                                                previousSibling: $cur.previousSibling
                                            }));
                                            numAddedNodes++;
                                        }
                                    } else {
                                        conflicts.push({ // add conflict
                                            i: i,
                                            j: idx
                                        });
                                    }
                                }
                                i++;
                            }

                            if ($old &amp;&amp;
                               // special case: the changes may have been resolved: i and j appear congurent so we can continue using the expected case
                               $old !== $kids[i]
                            ) {
                                if (!(map[id = getElementId($old)])) {
                                    map[id] = true;
                                    if ((idx = indexOf($kids, $old, i)) === -1) {
                                        if (config.kids) {
                                            mutations.push(new MutationRecord({
                                                type: &quot;childList&quot;,
                                                target: old.node,
                                                removedNodes: [$old],
                                                nextSibling: $oldkids[j + 1], // praise no indexoutofbounds exception
                                                previousSibling: $oldkids[j - 1]
                                            }));
                                            numAddedNodes--;
                                        }
                                    } else {
                                        conflicts.push({
                                            i: idx,
                                            j: j
                                        });
                                    }
                                }
                                j++;
                            }
                        }// end uncommon case
                    }// end loop

                    // resolve any remaining conflicts
                    if (conflicts) resolveConflicts(conflicts, node, $kids, $oldkids, numAddedNodes);
                }
                findMutations($target, $oldstate);
                return dirty;
            }

            /**
             * Utility
             * Cones a element into a custom data structure designed for comparision. https://gist.github.com/megawac/8201012
             *
             * @param {Node} $target
             * @param {!Object} config : A custom mutation config
             * @return {!Object} : Cloned data structure
             */
            function clone($target, config) {
                var recurse = true; // set true so childList we&#x27;ll always check the first level
                return (function copy($target) {
                    var elestruct = {
                        /** @type {Node} */
                        node: $target
                    };

                    // Store current character data of target text or comment node if the config requests
                    // those properties to be observed.
                    if (config.charData &amp;&amp; ($target.nodeType === 3 || $target.nodeType === 8)) {
                        elestruct.charData = $target.nodeValue;
                    }
                    // its either a element, comment, doc frag or document node
                    else {
                        // Add attr only if subtree is specified or top level and avoid if
                        // attributes is a document object (#13).
                        if (config.attr &amp;&amp; recurse &amp;&amp; $target.nodeType === 1) {
                            /**
                             * clone live attribute list to an object structure {name: val}
                             * @type {Object.&lt;string, string&gt;}
                             */
                            elestruct.attr = reduce($target.attributes, function(memo, attr) {
                                if (!config.afilter || config.afilter[attr.name]) {
                                    memo[attr.name] = attr.value;
                                }
                                return memo;
                            }, {});
                        }

                        // whether we should iterate the children of $target node
                        if (recurse &amp;&amp; ((config.kids || config.charData) || (config.attr &amp;&amp; config.descendents)) ) {
                            /** @type {Array.&lt;!Object&gt;} : Array of custom clone */
                            elestruct.kids = map($target.childNodes, copy);
                        }

                        recurse = config.descendents;
                    }
                    return elestruct;
                })($target);
            }

            /**
             * indexOf an element in a collection of custom nodes
             *
             * @param {NodeList} set
             * @param {!Object} $node : A custom cloned node
             * @param {number} idx : index to start the loop
             * @return {number}
             */
            function indexOfCustomNode(set, $node, idx) {
                return indexOf(set, $node, idx, jsCompiler_renameProperty(&quot;node&quot;));
            }

            // using a non id (eg outerHTML or nodeValue) is extremely naive and will run into issues with nodes that may appear the same like &lt;li&gt;&lt;/li&gt;
            var counter = 1; // don&#x27;t use 0 as id (falsy)
            /** @const */
            var expando = &quot;mo_id&quot;;

            /**
             * Attempt to uniquely id an element for hashing. We could optimize this for legacy browsers but it hopefully wont be called enough to be a concern
             *
             * @param {Node} $ele
             * @return {(string|number)}
             */
            function getElementId($ele) {
                try {
                    return $ele.id || ($ele[expando] = $ele[expando] || counter++);
                } catch (o_O) { // ie &lt;8 will throw if you set an unknown property on a text node
                    try {
                        return $ele.nodeValue; // naive
                    } catch (shitie) { // when text node is removed: https://gist.github.com/megawac/8355978 :(
                        return counter++;
                    }
                }
            }

            /**
             * **map** Apply a mapping function to each item of a set
             * @param {Array|NodeList} set
             * @param {Function} iterator
             */
            function map(set, iterator) {
                var results = [];
                for (var index = 0; index &lt; set.length; index++) {
                    results[index] = iterator(set[index], index, set);
                }
                return results;
            }

            /**
             * **Reduce** builds up a single result from a list of values
             * @param {Array|NodeList|NamedNodeMap} set
             * @param {Function} iterator
             * @param {*} [memo] Initial value of the memo.
             */
            function reduce(set, iterator, memo) {
                for (var index = 0; index &lt; set.length; index++) {
                    memo = iterator(memo, set[index], index, set);
                }
                return memo;
            }

            /**
             * **indexOf** find index of item in collection.
             * @param {Array|NodeList} set
             * @param {Object} item
             * @param {number} idx
             * @param {string} [prop] Property on set item to compare to item
             */
            function indexOf(set, item, idx, prop) {
                for (/*idx = ~~idx*/; idx &lt; set.length; idx++) {// start idx is always given as this is internal
                    if ((prop ? set[idx][prop] : set[idx]) === item) return idx;
                }
                return -1;
            }

            /**
             * @param {Object} obj
             * @param {(string|number)} prop
             * @return {boolean}
             */
            function has(obj, prop) {
                return obj[prop] !== undefined; // will be nicely inlined by gcc
            }

            // GCC hack see http:// stackoverflow.com/a/23202438/1517919
            function jsCompiler_renameProperty(a) {
                return a;
            }

            return MutationObserver;
        })();
    }

}(typeof global !== &#x27;undefined&#x27; ? global : /* istanbul ignore next */ this));
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
